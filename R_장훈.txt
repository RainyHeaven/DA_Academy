# [문제1] x변수에 1,3,5,7,9 값을 입력, y 변수에 1,2,3,4,5 값을 입력하세요.
x <- c(1,3,5,7,9)
y <- c(1,2,3,4,5)

# [문제2] x 변수와 y 변수를 중복성 없이 하나로 합친후에 u 변수에 넣어 주세요.
u <- sort(union(x,y), decreasing = FALSE)
u
# [문제3] x 변수와 y 변수의 값들중에 중복성만 추출해서 i 변수에 넣어주세요.
i <- intersect(x,y)

# [문제4] x 변수의 값과 y 변수의 값중에 순수하게 x 변수에 들어 있는 값만 추출해서 m 변수에 넣어 주세요.
m <- setdiff(x, y)
m
# [문제5] x 변수의 값과 y 변수의 값이 일치가 되면 TRUE 아니면 FALSE를 출력해주세요.
identical(x, y)

# [문제6] x 변수에 값들을 10을 곱한 결과를 x 변수에 적용하세요.
x <- x * 10

# [문제7] x 변수에 있는 50을 5로 수정하세요.
x
x[3] <- 5

# [문제8]  x 변수에 있는 10 30  5 70 90을  원래의 값으로 1,3,5,7,9로 되돌려 주세요.단 union, 정수 나누기, sort 만 사용하세요
x <- c(10, 30, 5, 70, 90)
x <- sort(union((x[-3]%/%10), x[3]))

x[which(5 == x)] <- 50
x <- x%/%10
x
# [문제9] x변수에 11숫자를 제일 뒤에 입력하세요. 단 append와 length를 이용하세요.
append(x, 11, after=length(x))

# [문제10] x 변수에 제일 뒤에 있는 값을 NA로 수정하세요. 단 length를 이용하세요.
x[length(x)] <- NA

# [문제11] lst 변수에 name = 'king' , height = 180, weight = 70 값을 넣어 주세요.
lst <- list(name = 'king', height = 180, weight = 70)
lst

# [문제12] lst 변수에  blood = 'A' 추가하세요.
lst$blood <- 'A'
lst

# [문제13] lst 변수에 name의 값을 'scott'로 수정하세요.
lst$name <- 'scott'

# [문제14] lst변수에 2번인덱스 값만 출력해주세요.
lst[[2]]

# [문제15] lst변수에 blood 이름을 blood type 이름으로 수정하세요.
names(lst) <- c('name', 'height', 'weight', 'blood type')
names(lst)[4] <- 'blood type'
lst

# [문제16] x 변수에 벡터값 1,2,3,5,6 을 입력한 후 3번째 요소 뒤에 4를 입력하세요.
x <- c(1,2,3,5,6)
x <- append(x, 4, after = 3)

# [문제17] 1부터  3씩 증가하는 10 이하의 정수값을 출력하세요.
seq(1, 10, 3)
seq(1, 10, length.out=100) #length.out = x : x개만큼 등분

# [문제18] 10 부터 20 까지의 값을 x 변수에 생성한 후 원소의 값이 15 이상이고 18 이하인 값들만 출력하세요.
x <- c(10:20)
x[which(15 <= x & 18 >= x)]

# [문제19] 10 부터 20 까지의 값을 x 변수에 생성한 후 원소의 값이 15 이상이고 18 이하인 값들만 2곱한 값으로 수정하세요.
x <- c(10:20)
x[which(15 <= x & 18 >= x)] <- x[which(15 <= x & 18 >= x)]*2

# [문제20] x 변수에 행렬을 구성하세요. 값은 1부터 10까지 입력하시고 5행 2열으로 만들면서 값은 열을 기준으로 생성하세요.
x <- matrix(c(1:10), nrow=5, byrow=FALSE)

#[문제21] x 변수에 열을 기준으로 11,12,13,14,15 값을 추가하세요.
x <- cbind(x, c(11:15))
x
# [문제22] x 변수에 행을 기준으로 16,17,18 값을 추가하세요.
x <- rbind(x, c(16:18))
x

# [문제23] x변수에 6행의 값을 20,21,22 로 수정하세요.
x[6,] <- c(20:22)
x

# [문제24] x 변수에 6행을 제거해주세요.
x <- x[-6,]
x

# [문제25] x 배열을 생성하세요. 1부터 12까지 값을 가지고있는 배열을 생성하세요. 면은 3개가 만들어지도록하세요.
x <- array(c(1:12), dim=c(2,2,3))
x <- array(1:12, dim=c(2,2,3))

#[문제26] x 배열 변수에 컬럼이름은 'a','b'로 설정하세요.
colnames(x) <- c('a','b')

#[문제27] x 배열 변수에 행이름은 'row1','row2'로 설정하세요.
rownames(x) <- c('row1','row2')

#[문제28] x 배열 변수에 면을 2로 수정하세요.
dim(x) <- c(3,2,2)
x

# [문제29] 벡터에 있는 값 "large", "medium", "small", "small", "large", "medium" 을 factor 변수로 구성하세요. 
# 변수이름은x로 생성하시고 levels samall, medium, large 순으로 지정하세요.
x <- factor(c('large','medium','small','small','large','medium'), levels=c('small', 'medium','large'),ordered=TRUE)
x

#[문제30] x factor형 목록이름중에 small 을 s로 수정하세요.
levels(x)[1] <- 's'
levels(x)[levels(x) == 'small'] <- 's'
x

# [문제31] 아래와 같은 모양의 변수를 생성하세요. 변수 이름은 df로 하세요.
# <화면출력>
# df
# name sql  plsql
# 1  king  96     75
# 2 smith  82     91
# 3  jane  78     86
df <- data.frame(name=c('king','smith','jane'), sql=c(96, 82, 78), plsql=c(75, 91, 86), stringsAsFactors=FALSE)
df

# [문제32] df변수에 james, 90, 80 추가 해주세요.
# <화면출력>
# > df
# name sql plsql
# 1  king  96    75
# 2 smith  82    91
# 3  jane  78    86
# 4 james  90    80
df[4,] <- c('james', 90, 80)
df
df <- rbind(df, c('james',90,80))
df <- rbind(df, data.frame(name='james',sql=90,plsql=80))

# [문제33] james에 대한 row 정보만 출력하세요.
# <화면출력>
# name sql plsql  r
# 4 james  90    80 60
df[df$name=='james',]

# [문제34]. emp 변수에 있는 데이터 중에 급여가 3000 인 사원들의 last_name, salary를 출력하세요. 단 emp 변수에 컬럼정보를 확인하시고 수행하세요.
names(emp)
emp[emp$SALARY==3000, c('LAST_NAME', 'SALARY')]
# desc emp
# select last_name, salary from emp where salary = 3000;

# [문제35] 급여가 2000 이상인 사원들의 last_name, salary를 출력하세요.
emp[emp$SALARY>=2000, c('LAST_NAME', 'SALARY')]
# select last_name, salary from emp where salary >= 2000;

# [문제36] job이 ST_CLERK인 사원들의 이름과 월급과 직업을  출력하세요.
emp[emp$JOB_ID=='ST_CLERK', c('LAST_NAME', 'SALARY', 'JOB_ID')]
# select last_name, salary, job_id from emp where job_id = 'ST_CLERK';

# [문제37] job이 ST_CLERK이 아닌 사원들의 이름과 월급과 직업을  출력하세요.
emp[emp$JOB_ID!='ST_CLERK', c('LAST_NAME', 'SALARY', 'JOB_ID')]
# select last_name, salary, job_id from emp where job_id != 'ST_CLERK';

# [문제38] 오라클의 in 연산자와 비슷한 R연산자는?
%in%

# [문제39] job이 AD_ASST, MK_MAN 인 사원들의 employee_id,last_name,job_id를 출력하세요.
emp[emp$JOB_ID%in%c('AD_ASST', 'MK_MAN'), c('EMPLOYEE_ID', 'LAST_NAME', 'JOB_ID')]
#select employee_id, last_name, job_id from emp where job_id in ('AD_ASST', 'MK_MAN');

# [문제40] job이 ST_CLERK, SH_CLERK, SA_REP 아닌 사원들의 employee_id,last_name,job_id를 출력하세요.
emp[!emp$JOB_ID%in%c('ST_CLERK','SH_CLERK', 'SA_REP'), c('EMPLOYEE_ID', 'LAST_NAME', "JOB_ID")]
#select employee_id, last_name, job_id from emp where job_id not in ('ST_CLERK', 'SH_CLERK', 'SA_REP');

# [문제41] 부서번호가 10번,20번인 사원들의 last_name, salary, department_id를 출력하세요.
emp[emp$DEPARTMENT_ID%in%c(10, 20), c("LAST_NAME", "SALARY", "DEPARTMENT_ID")]
#select last_name, salary, department_id from emp where department_id in (10, 20);

# [문제42] 오라클의 연결 연산자 와 비슷한 R 연산자는?
# 오라클		       R
# || concat   		paste(,,,,)

# [문제43] 아래결과와 같이 출력되도록하세요. 
# Grant 의 직업은  SH_CLERK  입니다.
help(paste)
paste(emp[,'LAST_NAME'],'의 직업은',emp[,'JOB_ID'],'입니다.')
paste0(emp$LAST_NAME,'의 직업은',emp$JOB_ID,'입니다.')

# [문제44] R에서 NA(결측치)를 체크하는 함수는?
is.na()

# [문제45] commission_pct에  NA 인 사원들의 last_name, salary, commission_pct를 출력하세요.
emp[is.na(emp$COMMISSION_PCT), c("LAST_NAME", "SALARY", "COMMISSION_PCT")]
# select last_name, salary, commission_pct from emp where commission_pct is null;

# [문제46] department_id에 NA 인 사원들의 last_name, salary, department_id를 출력하세요.
emp[is.na(emp$DEPARTMENT_ID), c("LAST_NAME", "SALARY", "DEPARTMENT_ID")]
# select last_name, salary, department_id from emp where department_id is null;

# [문제47] commission_pct에  NA가 아닌 사원들의 last_name, salary, commission_pct를 출력하세요.
emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "SALARY", "COMMISSION_PCT")]
# select last_name, salary, commission_pct from emp where commission_pct is not null;

# [문제48] 30번 부서 사원들이면서 급여는 3000이상인 사원들의 employee_id, salary, department_id를 출력하세요.
emp[emp$DEPARTMENT_ID==30 & emp$SALARY >= 3000 , c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
# select employee_id, salary, department_id from emp where department_id = 30 and salary >= 3000;
#조건이 걸린 키값에 NA값이 있다면 해당열은 모두 NA가 되어 출력됨
#na.omit(): na가 있는 행을 모두 제거
na.omit(emp[emp$DEPARTMENT_ID==30 & emp$SALARY >= 3000 , c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]) 

# [문제49] 20번부서 사원이면서 급여는 10000를 초과한 사원 또는 급여가 2500 미만의 사원들의 employee_id, salary, department_id를 출력하세요.
emp[(emp$DEPARTMENT_ID==20 & emp$SALARY > 10000)|emp$SALARY<2500, c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
emp[emp$DEPARTMENT_ID==20 & emp$SALARY > 10000|emp$SALARY<2500, c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
emp[emp$SALARY<2500, c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
# select employee_id, salary, department_id from emp where (department_id = 20 and salary > 10000) or salary < 2500;

# [문제50]last_name의 첫번째 글자가 A 로 시작하는 사원들의 last_name, salary를 출력하세요.
emp[grep('^A', emp$LAST_NAME,ignore.case=FALSE), c("LAST_NAME", "SALARY")]
emp[grep('^A.*', emp$LAST_NAME,ignore.case=FALSE), c("LAST_NAME", "SALARY")]

# [문제51]last_name의 끝글자가 g 로 끝나는 사원들의 last_name, salary를 출력하세요.
emp[grep('g$', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]
emp[grep('*g$', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]
emp[grep('*.g$', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]
 
# [문제52]last_name의 z 를 포함하고 있는 사원들의 last_name, salary를 출력하세요.
emp[grep('z', emp$LAST_NAME, ignore.case=TRUE), c("LAST_NAME","SALARY")]
emp[grep('z', emp$LAST_NAME, ignore.case=TRUE), c("LAST_NAME","SALARY")]
emp[grep('^.*z.*$', emp$LAST_NAME, ignore.case=TRUE), c("LAST_NAME","SALARY")]
 
# [문제53]last_name의 두번째 철자가 u 인 사원들의 last_name, salary를 출력하세요.
emp[grep('^.u', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]

# [문제54] developer글자를 첫글자 대문자, 뒤글자는 소문자로 변환하세요.
word <- 'developer'
last <- nchar(word)
paste0(toupper(substr(word, 1, 1)),tolower(substr(word,2,last)))

library(tools)
toTitleCase(word)

install.packages('stringr')
library(stringr)
str_to_title(word)

#[문제55] last_name의 글자의 수가 10이상인 사원의 employee_id, last_name 출력하세요.
setwd('c:/data')
getwd()
emp <- read.csv('emp_new.csv', header=TRUE, stringsAsFactors=FALSE)
emp[ nchar(emp$LAST_NAME)>= 10, c("EMPLOYEE_ID", "LAST_NAME")]
#select employee_id, last_name from emp where len(last_name ) >= 10;

# [문제56] last_name, last_name의 첫번째 철자부터 세번째 철자까지 함께 출력하세요.
paste0(emp[, "LAST_NAME"], substr(emp[,"LAST_NAME"], 1, 3))
#select last_name||substr(last_name, 1, 3) from emp;

# [문제57] last_name의 두번째 철자가 m  인 사원들의 last_name, salary를 출력하세요.
emp[substr(emp[,"LAST_NAME"],2,2)=='m', c("LAST_NAME", "SALARY")]
# select last_name, salary from emp where substr(last_name, 2, 1) = 'm';
emp[grep('^.m', emp$LAST_NAME), c("LAST_NAME", "SALARY")]

# [문제58] last_name의 두번째 철자가 m 또는 g 인 사원들의 last_name, salary를 출력하세요.
emp[substr(emp[,"LAST_NAME"],2,2)=='m'|substr(emp[,"LAST_NAME"],2,2)=='g', c("LAST_NAME","SALARY")]
#select last_name, salary from emp where substr(last_name,2,1)='m' or substr(last_name,2,1)='g';
emp[substr(emp$LAST_NAME, 2, 2)%in%c('m','g'), c("LAST_NAME", "SALARY")]
emp[c(grep('^.m', emp$LAST_NAME), grep('^.g', emp$LAST_NAME)), c("LAST_NAME", "SALARY")]
emp[grep('^.m|^.g', emp$LAST_NAME), c("LAST_NAME", "SALARY")]
emp[grepl('^.m', emp$LAST_NAME)|grepl('^.g', emp$LAST_NAME), c("LAST_NAME", "SALARY")]

# [문제59] last_name, salary값을 화면에 출력할때 0은 * 로 출력하세요.
gsub(0, '*',emp[,c("LAST_NAME","SALARY")])
data.frame('last_name'=emp[, "LAST_NAME"], 'salary'=gsub(0, '*', emp[, "SALARY"]), stringsAsFactors = FALSE)
#select last_name, replace(salary, 0, '*') from emp;
paste(emp$LAST_NAME, gsub(0, '*', emp$SALARY))

# [문제60] last_name의 제일 뒷글자만 대문자 앞글자들은 소문자로 출력하세요.
lname <- emp[,"LAST_NAME"]
paste0(tolower(substr(lname,1, nchar(lname)-1)),toupper(substr(lname,nchar(lname), nchar(lname))))
# select lower(substr(last_name,1,length(last_name)-1))||upper(substr(last_name,length(last_name))) from emp;

# [문제61] s 백터 변수를 생성해서 "BIG DATA MARKETING" 입력한 후 단어로 분리해주세요.
s <- c('BIG DATA MARKETING')
strsplit(s, split=' ')
# declare
# v_sentence varchar2(100) := 'BIG DATA MARKETING';
# v_blank number;
# v_start number := 1;
# v_word varchar2(20);
# v_ind number := 1;
# begin
# loop
# select instr(v_sentence, ' ', 1, v_ind) into v_blank from dual;
# if v_blank = 0 then
# select substr(v_sentence, v_start) into v_word from dual;
# else
#   select substr(v_sentence, v_start, v_blank-v_start) into v_word from dual;
# end if;
# v_start := v_blank+1;
# v_ind := v_ind + 1;
# dbms_output.put_line(v_word);
# exit when v_blank = 0;
# end loop;
# end;
# /

#[문제62] 2002-06-07에 입사한 사원들의 last_name, hire_date를  출력하세요.
emp[emp$HIRE_DATE == 20020607, c("LAST_NAME", "HIRE_DATE")]
# select last_name, hire_date from emp where hire_date = '20020607';

#[문제63] 사원의 last_name, 근무일수를 출력하세요.
data.frame('last_name' = emp$LAST_NAME, '근무일수' = difftime(Sys.Date(), as.Date(as.character(emp$HIRE_DATE), '%Y%m%d')))
# select last_name, trunc(months_between(sysdate, hire_date)*30) as Work_day from emp;

# [문제64] 사원의 last_name, 입사한 요일을 출력하세요.
data.frame('last_name' = emp$LAST_NAME, '입사요일' = weekdays(as.Date(as.character(emp$HIRE_DATE), '%Y%m%d')))
# select last_name, to_char(hire_date, 'day') from emp;

# [문제65] 오늘 날짜를 기준으로  100개월 되는 날짜의 요일을 출력하세요.
weekdays(Sys.Date() + months(100))
# select to_char(add_months(sysdate, 100), 'day') from dual;
format(Sys.Date() + months(100), '%A')
wday(Sys.Date() + months(100), label=T)
#일일이 형변환을 하기보다 데이터셋의 형을 바꿔주면 편함
emp$HIRE_DATE <- as.Date(as.character(emp$HIRE_DATE), format='%Y%m%d')

# [문제 66] 부서번호를 중복제거해주세요.
as.integer(na.omit(unique(emp$DEPARTMENT_ID)))
sort(unique(emp$DEPARTMENT_ID))
# select distinct(department_id) from emp;

# [문제67] last_name, hire_date를  출력하는데 먼저 입사한 사원부터 출력하세요.
getwd()
setwd('c:/data')
emp <- read.csv('emp_new.csv', stringsAsFactors = F, header = T)
library(doBy)
orderBy(~HIRE_DATE, emp[, c("LAST_NAME", "HIRE_DATE")])

# [문제68] df이름의 data frame 변수를 선언합니다.
# id 컬럼의 값은 100,101,102,103,104,  
# weight 컬럼의 값은 60,90,75,95,65, 
# size 컬럼의 값은 small, large, medium,large,small 값으로 생성하세요.
df <- data.frame(id = c(100:104), weight = c(60, 90, 75, 95, 65), size = c('small', 'large', 'medium', 'large', 'small'))

# [문제69] df변수에 weight 컬럼을 기준으로 오름차순 정렬해서 df 변수에 값을 출력하세요.(order 함수를 이용하세요)
df[order(df$weight),]
# select weight from df order by weight;

# [문제70] df변수에 size, weight 컬럼을 기준으로 오름차순 정렬하세요.(order 함수를 이용하세요)
df[order(df$weight, df$size), ] #선행컬럼을 먼저 정렬 후 후행 컬럼 정렬
# select size, weight from df order by size, weight;

# [문제71] df 변수에 있는 weight 컬럼을 기준으로 내림차순 정렬하세요.(order 함수를 이용하세요)
df[order(df$weight, decreasing = T), ]
df[order(-df$weight), ]
# select weight from df order by weight desc;

# [문제72] 30번 부서 사원들의 last_name, salary를  출력하세요.
# 단 salary를 기준으로 내림차순정렬하세요.
na.omit(orderBy(~-SALARY, emp[emp$DEPARTMENT_ID==30, c("LAST_NAME", "SALARY")]))
# select last_name, salary from emp where department_id = 30 order by salary desc;

# [문제73] job_id가  ST_CLERK 가 아닌 사원들의 last_name, salary, job_id를 출력하는데 급여가 높은 사원부터 출력되게하세요.(orderBy 함수를 이용하세요)
orderBy(~-SALARY, emp[emp$JOB_ID!='ST_CLERK', c("LAST_NAME", "SALARY", "JOB_ID")])
# select last_name, salary, job_id from emp where job_id != 'ST_CLERK' order by salary desc;

# [문제74] 사원 last_name, salary, commission_pct를 출력하는데 commission_pct를 기준으로 오름차순정렬하세요.(orderBy를 이용하세요)
orderBy(~COMMISSION_PCT, emp[, c("LAST_NAME", "SALARY", "COMMISSION_PCT")])
# select last_name, salary, commission_pct from emp order by commission_pct;

# [문제75] commission_pct를 받고 있는 사원들의 last_name, salary, commission_pct를 출력하는데 commission_pct를 기준으로 오름차순정렬하세요.(orderBy를 이용하세요)
na.omit(orderBy(~COMMISSION_PCT, emp[, c("LAST_NAME", "SALARY", "COMMISSION_PCT")]))
orderBy(~COMMISSION_PCT, emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "SALARY", "COMMISSION_PCT")])
# select last_name, salary, commission_pct from emp where commission_pct is not null order by commission_pct;

# [문제76] 6의 9승을 출력하세요 
6^9
# select power(6, 9) from dual;

# [문제77] 10을 3으로 나눈 나머지값을 출력하세요 
10%%3
# select mod(10, 3) from dual;

# [문제78] last_name, salary에 12를  곱해서 출력하고 컬럼명이 한글로 연봉으로  데이터 프레임으로 출력하세요 
x <- data.frame(last_name = emp$LAST_NAME, '연봉' = emp$SALARY*12, stringsAsFactors = F)
# select last_name, salary * 12 as 연봉 from emp;

# [문제79] last_name과 연봉을 출력하는데 연봉이 높은것부터 출력하세요 
orderBy(~-연봉, x[, c("last_name", "연봉")])
# select last_name, 연봉 from x order by 연봉 desc;
orderBy(~-연봉, data.frame(emp$LAST_NAME, 연봉=emp$SALARY*12))

# [문제80] 문제79를 round 함수를 이용해서 아래와 같이 백단위에서 반올림되게 하세요. 
# 4:  JONES 35700  ----->  36000
x$연봉 <- round(x$연봉, -3)
orderBy(~-연봉, data.frame(emp$LAST_NAME, 연봉=round(emp$SALARY*12, -3)))
# select last_name, round(연봉, -3) from x;

# [문제81] 최대월급을 출력하세요
max(emp$SALARY)
# select max(salary) from emp;
 
# [문제82] 직업이 ST_CLERK 인 사원들중에 최대월급을 출력하세요
max(emp[emp$JOB_ID=='ST_CLERK', "SALARY"])
# select max(salary) from emp where job_id = 'ST_CLERK';

# [문제83] 부서번호별로 급여에 총액을 출력하세요.
aggregate(SALARY~DEPARTMENT_ID,emp,sum)
# select department_id, sum(salary) from emp group by department_id;

# [문제84] 부서번호, 직업별로 급여에 총액을 출력하세요.
aggregate(SALARY~DEPARTMENT_ID+JOB_ID,emp,sum)
# select department_id, job_id, sum(salary) from emp group by department_id, job_id;

# [문제85] 부서번호별 최대월급을 출력하는데 최대월급이 높은것부터 출력하세요.
orderBy(~-SALARY, aggregate(SALARY~DEPARTMENT_ID,emp,max))
# select department_id, max(salary) as maxsal from emp group by department_id order by maxsal desc;

# [문제86] 직업별 인원수를 출력하세요.
aggregate(EMPLOYEE_ID~JOB_ID,emp,NROW)
# select job_id, count(*) from emp group by job_id;

# [문제87] 아래화면의 결과 처럼 데이터 프레임을 생성한 후 
# total 컬럼을 생성해서 sql과 python 의 합을 구하세요.(단 apply함수를 이용하세요)
# name 	sql 	python
# king	96	75
# smith	NA	91
# jane	78	86
# scott	90	NA

score <- data.frame(name=c('king', 'smith', 'jane','scott'), sql=c(96, NA, 78, 90), python=c(75, 91, 86, NA), stringsAsFactors = F)
score$total <- apply(score[,2:3], 1, sum, na.rm=T)
score

score <- cbind(score, total=apply(score[,c(2,3)], 1, sum, na.rm=T))
# create table score(name varchar2(10), sql number(10), python number(10)) tablespace users;
# insert into score values('king', 96, 75);
# insert into score values('smith', null, 91);
# insert into score values('jane', 78, 86);
# insert into score values('scott', 90, null);

# alter table score add total number(20);

# declare 
#   type sum_type is record(lname varchar2(20), sums number);
#   type tab_type is table of sum_type;
#   ssum tab_type;
# begin
#   select name, nvl(sql,0) + nvl(python,0) bulk collect into ssum from score;
#   forall i in 1..ssum.last
#     update score set total = ssum(i).sums where name = ssum(i).lname;
# end;
# /

#[문제88] 입사한 년도별 평균월급을 세로(aggregate), 가로(tapply)로 출력하세요.
getwd()
setwd('c:/data')
emp <- read.csv('emp_new.csv', stringsAsFactors = F)
#세로
class(emp$HIRE_DATE)
x <- aggregate(SALARY~format(as.Date(as.character(HIRE_DATE), format='%Y%m%d'), '%Y'), emp, mean)
colnames(x) <- c('hiredate','avgsal')
x

aggregate(list(AvgSal = emp$SALARY), list(HireYear = substr(emp$HIRE_DATE, 1, 4)), mean)
# select substr(hire_date,1,4) as HireYear, round(avg(salary)) as AvgSal from emp group by substr(hire_date,1,4) order by 1;

#가로
tapply(emp$SALARY, substr(emp$HIRE_DATE, 1, 4), mean)

# [문제89] 부서별 인원수를 세로(aggregate), 가로(tapply)로 출력하세요.
#세로
x <- aggregate(EMPLOYEE_ID~DEPARTMENT_ID, emp, NROW)
colnames(x) <- c('DEPARTMENT_ID', 'NET_PEOPLE')
x

aggregate(list(EmpId=emp$EMPLOYEE_ID), list(DepId=emp$DEPARTMENT_ID), NROW)
# select department_id, count(*) from emp group by department_id order by 1;

#가로
tapply(emp$EMPLOYEE_ID, emp$DEPARTMENT_ID, NROW)

# [문제90]job_id, hire_date(년도4자리) 총액 급여를 aggregate함수를 이용해서 생성하세요.
aggregate(list(SumSal=emp$SALARY), list(JobId=emp$JOB_ID, HireYear=substr(emp$HIRE_DATE, 1, 4)), sum)
# select job_id, substr(hire_date, 1, 4) as hireyear, sum(salary) from emp group by job_id,substr(hire_date, 1, 4) order by 2, 1;

# [문제91] job_id, hire_date(년도4자리) 총액 급여를 tapply함수를 이용해서 생성하세요.
# 단 NA 대신에 0 으로 출력하세요.
tapply(emp$SALARY, data.frame(JobId=emp$JOB_ID, HireYear=substr(emp$HIRE_DATE, 1, 4)), sum, default=0)

# [문제 92] 변수에 2를 입력한 후 그 변수의 값이 2의 배수면 '2의 배수'를 출력, 아니면 '2의 배수가 아니다' 출력해주세요
x <- 2
yes <- '2의 배수'
no <- '2의 배수가 아닙니다'
if(x%%2==0){yes}else{no}
ifelse(x%%2==0,yes, no)
# declare
# x number := 2;
# begin
# if mod(x,2)=0 then
# dbms_output.put_line('2의 배수');
# else
#   dbms_output.put_line('2의 배수가 아닙니다');
# end if;
# end;
# /


# [문제93] emp 변수에 있는 데이터를 가지고 새로운 df변수를 생성하세요.
# last_name, salary, 급여가 10000  이상이면 A, 5000이상 10000보다 작으면 B 나머지는 C가 입력되어 있는 새로운 컬럼을 생성하세요.  
# 컬럼이름은 name, sal, level 로 설정하세요.
df <- data.frame(name=emp$LAST_NAME, sal=emp$SALARY, level=ifelse(emp$SALARY>=10000, 'A', ifelse(emp$SALARY>=5000, 'B', 'C')))
df
# declare
#   type rec_type is record(name emp.last_name%type, sal emp.salary%type, level varchar2(10));
#   type tab_type is table of rec_type;
#   df tab_type;
# begin
#   select last_name, salary, null bulk collect into df from emp;
#   for i in df.first..df.last loop
#     if df(i).sal >= 10000 then
#       df(i).level := 'A';
#     elsif df(i).sal between 5000 and 9999 then
#       df(i).level := 'B';
#     else
#       df(i).level := 'C';
#     end if;
#     dbms_output.put_line(df(i).name||' '||df(i).sal||' '||df(i).level);
#   end loop;
# end;
# /


# [문제94] x 변수에 1부터 100까지 입력한 후 짝수값은 자신의 값에 10을 곱한 값으로 수정하세요.
x <- 1:100
x <- ifelse(x%%2==0,x*10,x)
x

x[x%%2==0] <- x[x%%2==0] * 10
# declare
#   type tab_type is table of number index by pls_integer;
#   x tab_type;
# begin
#   for i in 1..100 loop
#     x(i) := i;
#   end loop;
#   for i in 1..x.last loop
#     if mod(x(i), 2)=0 then
#       x(i) := i*10;
#     end if;
#     dbms_output.put_line(x(i));
#   end loop;
# end;
# /

# [문제95]  x <- c(2,10,6,4,3,NA,7,9,1)  x변수에 NA가 있는지를 검사하세요.
x <- c(2,10,6,4,3,NA,7,9,1)
is.na(x)

# [문제96] x 변수에 NA가 있는 인덱스 번호를 찾아 주세요.
which(is.na(x))
# declare
#   type tab_type is table of number;
#   x tab_type := tab_type(2, 10, 6, 4, 3, null, 7, 8, 1);
# begin
#   for i in x.first..x.last loop
#     if x(i) is null then
#       dbms_output.put_line(i);
#     end if;
#   end loop;
# end;
# /

# [문제97] x 변수에 NA가 있으면 0으로 설정하세요
x <- ifelse(is.na(x), 0,x)
# declare
#   type tab_type is table of number;
#   x tab_type := tab_type(2, 10, 6, 4, 3, null, 7, 8, 1);
# begin
#   for i in x.first..x.last loop
#     if x(i) is null then
#       x(i) := 0;
#     end if;
#   end loop;
# end;
# /

x[which(is.na(x))] <- 0

# [문제98] last_name, salary, commission_pct, 
# commission_pct NA 면 salary * 12,
# 아니면 (salary * 12) + (salary * 12 * commission_pct)을 수행하세요.
# > head(df)
# name   sal comm ann_sal
# 1  OConnell  2600   NA   31200
# 2     Grant  2600   NA   31200
# 3    Whalen  4400   NA   52800
# 4 Hartstein 13000   NA  156000
# 5       Fay  6000   NA   72000
# 6    Mavris  6500   NA   78000
df <- data.frame(name=emp$LAST_NAME, sal=emp$SALARY, comm=emp$COMMISSION_PCT, ann_sal=ifelse(is.na(emp$COMMISSION_PCT), emp$SALARY*12, (emp$SALARY*12)+(emp$SALARY*12*emp$COMMISSION_PCT)))
df
# declare
#   type rec_type is record(name emp.last_name%type, sal emp.salary%type, comm emp.commission_pct%type, ann_sal number);
#   type tab_type is table of rec_type;
#   df tab_type;
# begin
#   select last_name, salary, commission_pct, null bulk collect into df from emp;
#   for i in df.first..df.last loop
#     if df(i).comm is not null then
#       df(i).ann_sal := (df(i).sal * 12) * (1+df(i).comm);
#     else
#       df(i).ann_sal := df(i).sal * 12;
#     end if;
#     dbms_output.put_line(df(i).name||' '||df(i).sal||' '||df(i).comm||' '||df(i).ann_sal);
#   end loop;
# end;
# /

# [문제99] x변수에 1부터 100까지 입력한 후
# 1은 합을, 2는 평균, 3은 분산, 4는 표준편차를
# 구하는 switch문을 생성하세요.
x <- 1:100
y <- 4
switch(y, sum(x), mean(x), var(x), sd(x))
# create or replace procedure calc(p_num in number)
# is
#   rst number;
# begin
#   if p_num = 1 then
#     select sum(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   elsif p_num = 2 then
#     select avg(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   elsif p_num = 3 then
#     select variance(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   elsif p_num = 4 then
#     select stddev(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   end if;
# end;
# /

# [문제 100] 1부터 10까지 합을 for문을 이용해서 구하세요
x <- 0
for(i in 1:10){x <- x+i}
# declare
#   rst number := 0;
# begin
#   for i in 1..100 loop
#     rst := rst+i;
#   end loop;
#   dbms_output.put_line(rst);
# end;
# /

# [문제 101] 1부터 100까지 전체합, 짝수합, 홀수합을 출력하세요
t_sum <- 0
o_sum <- 0
e_sum <- 0
#if
for(i in 1:100){
  if(i%%2 == 0){e_sum <- e_sum + i
  }else{o_sum <- o_sum + i
  }
  t_sum <- t_sum + i
}
#switch
for(i in 1:100){
  x <- (i%%2)+1 
  switch(x, e_sum <- e_sum+i, o_sum <- o_sum+i)
  t_sum <- t_sum + i
}
o_sum
e_sum
t_sum
# declare
#   rst number := 0;
#   o_sum number := 0;
#   e_sum number := 0;
# begin
#   for i in 1..100 loop
#     rst := rst + i;
#     if mod(i, 2) = 0 then
#       e_sum := e_sum + i;
#     else
#       o_sum := o_sum + i;
#     end if;
#   end loop;
#   dbms_output.put_line('전체합:'||rst||' 짝수합: '||e_sum||' 홀수합: '||o_sum);
# end;
# /

# [문제 102] 1부터 100까지 짝수합, 홀수합을 tapply를 이용해서 구하세요
x <- 1:100
a <- tapply(x, x%%2==0, sum)
names(a) <- c('Odd Sum', 'Even Sum')
a

# [문제103] 1부터100까지 홀수만 x 변수에 입력해주세요.(for문을 이용하세요)
#list사용
x <- list()
#append(list, element)를 하면 순서대로 저장
for(i in 1:100){
  if(i%%2==1){x <- append(x, i)}
}
#append(element, list)를 하면 stack처럼 역순으로 저장
for(i in 1:100){
  if(i%%2==1){x <- append(i, x)}
}
x
#벡터 사용
z <- NULL
for(i in 1:100){
  if(i%%2==1){z <- c(z, i)}
}

#cbind
for(i in 1:100){
  if(i%%2==1){z <- cbind(z, i)}
}

#rbind
for(i in 1:100){
  if(i%%2==1){z <- rbind(z, i)}
}
z
# create table test_table(x number);
# begin
#   for i in 1..100 loop
#     if mod(i,2)=1 then
#       insert into test_table(x) values(i);
#     end if;
#   end loop;
# end;
# /


# [문제104] while문을 이용해서 2단을 출력하세요.
# [1] "2 x 1 = 2"
# [1] "2 x 2 = 4"
# [1] "2 x 3 = 6"
# [1] "2 x 4 = 8"
# [1] "2 x 5 = 10"
# [1] "2 x 6 = 12"
# [1] "2 x 7 = 14"
# [1] "2 x 8 = 16"
# [1] "2 x 9 = 18"
i <- 1
while(i <= 9){
  print(paste0('2 x ',i,' = ',2*i))
  i <- i + 1
}
# declare
#   i number := 1;
# begin
#   while i < 10 loop
#     dbms_output.put_line('2 x '||i||' = '||i*2);
#     i := i + 1;
#   end loop;
# end;
# /

# [문제105] repeat문을 이용해서 2단을 출력하세요.
# [1] "2 x 1 = 2"
# [1] "2 x 2 = 4"
# [1] "2 x 3 = 6"
# [1] "2 x 4 = 8"
# [1] "2 x 5 = 10"
# [1] "2 x 6 = 12"
# [1] "2 x 7 = 14"
# [1] "2 x 8 = 16"
# [1] "2 x 9 = 18"
i <- 1
repeat{
  if(i == 10){break
  }else{
      print(paste0('2 x ',i,' = ',2*i))
      i <- i +1}
}
# declare
#   i number := 1;
# begin
#   loop
#     dbms_output.put_line('2 x '||i||' = '||i*2);
#     i := i + 1;
#     exit when i = 10;
#   end loop;
# end;
# /

# [문제106] x변수에 1부터 10까지 입력한 후 홀수인지 짝수인지를 출력하세요.
# 1  2  3  4  5  6  7  8  9 10
# "홀수" "짝수" "홀수" "짝수" "홀수" "짝수" "홀수" "짝수" "홀수" "짝수"
x <- 1:10
#ifelse
ifelse(x%%2==0,'짝수','홀수')

#if
for(i in x){if(i%%2==0){print('짝수')}else{print('홀수')}}

#switch
for(i in x){switch(i%%2+1,print('짝수'), print('홀수'))}

#sql
# declare
#   type tab_type is table of number index by pls_integer;
#   x tab_type;
# begin
#   for i in 1..10 loop
#     x(i) := i;
#   end loop;
#   for i in x.first..x.last loop
#     if mod(x(i),2)=0 then
#     dbms_output.put_line('짝수');
#   else
#     dbms_output.put_line('홀수');
#   end if;
#   end loop;
# end;
# /

# [문제107] mysentence 이름의 벡터 변수에 'Well begun is half done' 이 값을 입력한 후 공백문자를 기준으로 분리해서 word 변수에 입력하세요. 
# word 변수에 타입을 체크한 후 word 변수에 입력된 값의 수를 출력하세요.
mysentence <- 'Well begun is half done'
word <- strsplit(mysentence,' ')
class(word)
mode(word)       
str(word)

class(word[1])
mode(word[1])       
str(word[1])

class(word[[1]])
mode(word[[1]])       
str(word[[1]])

#length
length(word[[1]])

#NROW
NROW(word[[1]])

#sapply
sapply(word, length)

# [문제108] 문제107에서 만든 word변수에 있는 값을  리스트 변수 letters에 하나씩 저장하세요.
letters <- list()
for(i in word[[1]]){letters <- append(letters, i)}
letters

letters <- list(rep(NA, 5))
for(i in 1:length(word[[1]])){letters[i] <- word[[1]][i]}
letters

# [문제109] 문제108에서 생성한 letters 변수에 있는 값을 myword변수에 하나의 문장으로 넣어 주세요.
# > myword
# [1] "Well begun is half done"
myword <- NULL
#for
for(i in letters){myword <- paste0(myword, i,' ')}

#뒷공백 제거
for(i in 1:length(letters)){if(i < length(letters)){myword <- paste0(myword,letters[i],' ')}else{myword <- paste0(myword,letters[i])}}

#while
i <- 0
while(i<=length(letters)){
  i <- i + 1
  if(i < length(letters)){paste0(myword,letters[i],' ')}else{paste0(myword,letters[i])}
  }

#for / paste & collapse
for(i in letters){myword <- paste(c(myword, i), collapse = ' ')}
myword
# [문제 110] hap함수에 인자값을 입력하게 되면 1부터 입력한 숫자까지누적합을 구하세요
hap <- function(x){
  res <- 0
  for(i in 1:x){res <- res + i}
  return(res)
}

# [문제 111] 인수값에 따라 합을 구하세요.
hap <- function(...){
  x <- list(...)
  res <- 0
  for(i in x){res <- res + i}
  return(res)
}
hap(1,2)
hap(1,2,3)
hap(10,20,30,40)
hap(1,3,5,1:100)

# [문제112] x변수에 1:5 까지 입력되어 있다 아래 화면 처럼 출력하세요.
x <- 1:5
result <- list()
#if
for(i in x){
  if(i%%2==0){result[i] <- '짝수'}else{result[i] <- '홀수'}
}

#ifelse
as.list(ifelse(x%%2==0, '짝수', '홀수'))


#lapply
checker <- function(x){
  if(x%%2==0){return('짝수')}else{return('홀수')}
}
result <- lapply(x, checker)

lapply(x, function(x){ifelse(x%%2==0, '짝수', '홀수')})

# [문제113] 사원 번호를 입력 값으로 받아서 사원의 LAST_NAME, SALARY를 출력하는 함수를 생성하세요.
# > find(100)
# LAST_NAME SALARY
# 10      King  24000
setwd('c:/data')
emp <- read.csv('emp_new.csv')
find <- function(id){emp[emp$EMPLOYEE_ID==id,c("LAST_NAME", "SALARY")]}
find(100)

# [문제114] 20번 부서에 소속되어 있는 사원들의 LAST_NAME, SALARY, JOB_ID, DEPARTMENT_NAME을 출력하세요
x <- merge(emp, dept, by='DEPARTMENT_ID')[, c('LAST_NAME', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID')]
x[x$DEPARTMENT_ID==20,]

merge(emp, dept, by='DEPARTMENT_ID')[merge(emp, dept, by='DEPARTMENT_ID')$DEPARTMENT_ID == 20, c('LAST_NAME', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID')]

merge(emp[emp$DEPARTMENT_ID==20,c("LAST_NAME","SALARY","JOB_ID","DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.last_name, e.salary, e.job_id, d.department_name from emp e, dept d where d.department_id = 20 and e.department_id = 20;

# [문제115] salary가 3000 이상이고 job_id는 ST_CLERK인 사원들의 employee_id, salary, job_id, department_id,department_name을 출력하세요.
x <- merge(emp, dept, by='DEPARTMENT_ID')[, c('EMPLOYEE_ID', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[emp$SALARY>=3000&emp$JOB_ID=='ST_CLERK',]

merge(emp, dept, by='DEPARTMENT_ID')[merge(emp, dept, by='DEPARTMENT_ID')$SALARY>=3000 & merge(emp, dept, by='DEPARTMENT_ID')$JOB_ID=='ST_CLERK', c('EMPLOYEE_ID', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]

merge(emp[emp$SALARY>=3000 & emp$JOB_ID=='ST_CLERK',c('EMPLOYEE_ID', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID')], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.employee_id, e.salary, e.job_id, e.department_id, d.department_name from emp e, dept d where e.department_id = d.department_id and e.salary >= 3000 and e.job_id = 'ST_CLERK';


# [문제116]  커미션이 NA 인 사원들의 last_name, commission_pct, department_id, department_name을 출력하세요.
x <- merge(emp,dept, by='DEPARTMENT_ID')[, c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[is.na(x$COMMISSION_PCT),]

merge(emp,dept, by='DEPARTMENT_ID')[is.na(merge(emp,dept, by='DEPARTMENT_ID')$COMMISSION_PCT), c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]

merge(emp[is.na(emp$COMMISSION_PCT), c("LAST_NAME", "COMMISSION_PCT", "DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.last_name, e.commission_pct, e.department_id, d.department_name from emp e, dept d where e.department_id = d.department_id and e.commission_pct is null;

# [문제117]  커미션이 NA가 아닌 사원들의 last_name, commission_pct,department_id, department_name을 출력하세요.
x <- merge(emp,dept, by='DEPARTMENT_ID')[, c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[!is.na(x$COMMISSION_PCT),]

merge(emp,dept, by='DEPARTMENT_ID')[!is.na(merge(emp,dept, by='DEPARTMENT_ID')$COMMISSION_PCT), c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
merge(emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "COMMISSION_PCT", "DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.last_name, e.commission_pct, e.department_id, d.department_name from emp e, dept d where e.department_id = d.department_id and e.commission_pct is not null;

# [문제118]커미션이 NA가 아닌 사원들의 last_name, commission_pct, department_id, department_name을 출력하세요.
# 단 department_id가 NA인 사원도 출력해주세요.
x <- merge(emp,dept, by='DEPARTMENT_ID', all.x = T)[, c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[!is.na(x$COMMISSION_PCT),]

merge(emp,dept, by='DEPARTMENT_ID', all.x = T)[!is.na(merge(emp,dept, by='DEPARTMENT_ID', all.x = T)$COMMISSION_PCT), c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]

merge(emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "COMMISSION_PCT", "DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID', all.x = T)
# select e.last_name, e.commission_pct, department_id, d.department_name from emp e left join dept d using(department_id) where e.commission_pct is not null;

# [문제119] 사원의 last_name, 관리자 last_name을 출력해주세요. 관리자가 없는 사원도 출력해주세요.
merge(data.frame(last_name=emp$LAST_NAME, mgr_id=emp$MANAGER_ID), data.frame(mgr_id = emp$EMPLOYEE_ID, mgr_name = emp$LAST_NAME), by='mgr_id', all.x = T)[, c('last_name', 'mgr_name')]
# select last_name, (select last_name from emp where employee_id = e.manager_id) as mgrname from emp e;

# [문제120] 부서이름별 총액 급여를 출력하세요.
#tapply
x <- merge(emp, dept, by='DEPARTMENT_ID')[,c('DEPARTMENT_NAME', 'SALARY')]
tapply(x$SALARY, x$DEPARTMENT_NAME, sum, default=0)
#aggregate
aggregate(SALARY~DEPARTMENT_NAME, merge(emp, dept, by='DEPARTMENT_ID')[,c('DEPARTMENT_NAME', 'SALARY')], sum)
# select d.department_name, sum(e.salary) from emp e, dept d where e.department_id = d.department_id group by d.department_name;

# [문제121] 부서이름별 소속사원들의 인원수를 출력하세요.
setwd('c:/data')
emp <- read.csv('emp_new.csv')
dept <- read.csv('dept.csv')
#aggregate
aggregate(EMPLOYEE_ID~DEPARTMENT_NAME, merge(emp,dept,by='DEPARTMENT_ID'),NROW)
#tapply
x <- merge(emp,dept,by='DEPARTMENT_ID')
tapply(x$EMPLOYEE_ID, x$DEPARTMENT_NAME, NROW)
#select d.department_name, count(e.employee_id) from employees e, departments d where e.department_id = d.department_id group by d.department_name;

# [문제122] 최고 급여를 받는 사원의 이름, 급여, 부서코드, 부서이름를 출력하세요.

x[merge(emp, dept, by='DEPARTMENT_ID')$SALARY==max(x$SALARY), c("LAST_NAME", "SALARY", "DEPARTMENT_ID", "DEPARTMENT_NAME")]
# select e.last_name, e.salary, e.department_id, d.department_name from employees e, departments d where e.department_id = d.department_id and e.salary = (select max(salary) from employees);

# [문제123] 부서이름,직업별 급여의 총액을 구하세요.
#aggregate
aggregate(SALARY~DEPARTMENT_NAME+JOB_ID, merge(emp,dept,by='DEPARTMENT_ID'),sum)
#tapply
x <- merge(emp,dept,by='DEPARTMENT_ID')
tapply(x$SALARY, data.frame(x$DEPARTMENT_NAME, x$JOB_ID), sum, default = 0)
# select d.department_name, e.job_id, sum(e.salary) from employees e, departments d where e.department_id = d.department_id group by d.department_name, e.job_id order by 1,2;

# [문제124] loc.csv 파일을 loc 변수로 로드하세요. Toronto 지역에 근무하는 사원들의 LAST_NAME,SALARY,DEPARTMENT_ID,DEPARTMENT_NAME,STREET_ADDRESS 정보를 출력하세요.
loc <- read.csv('loc.csv')
x <- merge(emp[,c("DEPARTMENT_ID","LAST_NAME", "SALARY")], dept[, c("DEPARTMENT_ID","DEPARTMENT_NAME","LOCATION_ID")], by='DEPARTMENT_ID')
y <- merge(x, loc[,c("LOCATION_ID", "STREET_ADDRESS", "CITY")], by='LOCATION_ID')
y[y$CITY=='Toronto', c("LAST_NAME", "SALARY", "DEPARTMENT_ID", "DEPARTMENT_NAME", "STREET_ADDRESS")]
# select e.last_name, e.salary, e.department_id, d.department_name, l.street_address from employees e, departments d, locations l where e.department_id = d.department_id and d.location_id = l.location_id and l.city = 'Toronto';
#효율적인 merge의 순서를 고려한 방법
x <- merge(dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME","LOCATION_ID")], loc[loc$CITY=='Toronto',c("LOCATION_ID","STREET_ADDRESS","CITY")],by='LOCATION_ID')
y <- merge(x[,c("DEPARTMENT_ID","DEPARTMENT_NAME","STREET_ADDRESS")], emp[,c("LAST_NAME", "SALARY","DEPARTMENT_ID")], by='DEPARTMENT_ID')

# [문제125] 아래 화면의 결과처럼 출력해주세요.
# 부서이름 부서별급여
# Administration       4400
# Marketing      19000
# Purchasing      24900
# Human Resources       6500
# Shipping     156400
# IT      28800
# Public Relations      10000
# Sales     304500
# Executive      63040
# Finance      51608
# Accounting      20308
# 소속부서X       7000
# 사원총급여     696456
#dataframe의 값을 수정하여 NA값 처리
dept <- read.csv('dept.csv', stringsAsFactors = F)
x <- merge(dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], emp[,c("DEPARTMENT_ID","SALARY")], by='DEPARTMENT_ID', all.y = T)
x[is.na(x$DEPARTMENT_NAME), "DEPARTMENT_NAME"] <- '소속부서x'
x[,"DEPARTMENT_ID"] <- NULL
total <- data.frame(DEPARTMENT_NAME='사원총급여', SALARY=sum(x[,1]))
rbind(x, total)
#NA제외/NA값 각각의 dataframe을 만들어서 rbind
x <- aggregate(SALARY~DEPARTMENT_NAME, merge(emp,dept,by='DEPARTMENT_ID'),sum)
colnames(x) <- c('부서이름', '부서별급여')
y <- data.frame(부서이름='소속부서X',부서별급여=emp[is.na(emp$DEPARTMENT_ID),'SALARY'])
total <- data.frame(부서이름='사원총급여',부서별급여=sum(z[,2]))
result <- rbind(x,y,total)
result
# select nvl(d.department_name,'소속부서X'), sum(e.salary) from departments d, employees e where e.department_id = d.department_id(+) group by d.department_name
# union all
# select '사원총급여', sum(salary) from employees order by 1,2;

# [문제126] 30번 부서 사원이면서 급여는 3000이상 받는 사원들의 last_name, hire_date, salary, job_id, department_id 출력해주세요.
# 단 subset 함수를 이용하세요.
subset(emp, DEPARTMENT_ID == 30 & SALARY >= 3000, select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
# select last_name, hire_date, salary, job_id, department_id from emp where department_id = 30 and salary >= 3000;

# [문제127] 입사한 날짜가 2002,2003년도에 입사한 사원들의 last_name, hire_date, salary, job_id, department_id 출력해주세요.
# 단 subset 함수를 이용하세요.
subset(emp, substr(HIRE_DATE,1,4)%in%c('2002','2003'),select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
# select last_name, hire_date, salary, job_id, department_id from emp where substr(hire_date, 1, 4) in (2002, 2003);

# [문제128] 문제126번 결과하고 문제127결과를 하나로 합쳐 주세요.
x <- subset(emp, DEPARTMENT_ID == 30 & SALARY >= 3000, select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
y <- subset(emp, substr(HIRE_DATE,1,4)%in%c('2002','2003'),select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
rbind(x,y)
merge(x,y,all=T)
# select last_name, hire_date, salary, job_id, department_id from emp where department_id = 30 and salary >= 3000
# union all
# select last_name, hire_date, salary, job_id, department_id from emp where substr(hire_date, 1, 4) in (2002, 2003);

# [문제129] 문제126번 결과하고 문제127결과 하나로 합치되 중복되는 데이터는 제거해주세요.
z <- rbind(x,y)
unique(z)

library(doBy)
orderBy(~LAST_NAME, unique(z))
# select last_name, hire_date, salary, job_id, department_id from emp where substr(hire_date, 1, 4) in (2002, 2003)
# union all
# select last_name, hire_date, salary, job_id, department_id from emp where department_id = 30 and salary >= 3000 and not exists(select * from emp where substr(hire_date, 1, 4) in (2002, 2003));

# [문제130] 150번 사원의 급여보다 더 많은 급여를 받는 사원들의 last_name, salary 를 출력하세요.
subset(emp, SALARY > emp[emp$EMPLOYEE_ID==150, "SALARY"], select=c(LAST_NAME, SALARY))
# select last_name, salary from emp where salary > (select salary from emp where employee_id = 150);

# [문제131] 사원 테이블에서 가장 많은 급여를 받는 사원의 이름과 월급을 출력하세요.
subset(emp, SALARY == max(SALARY), select=c(LAST_NAME, SALARY))
# select last_name, salary from emp where salary = (select max(salary) from emp);

# [문제132] job_id가  SA_REP인 사원의 최대급여 이상 받는 사원들의 last_name,salary,job_id를 출력하세요.
subset(emp, SALARY >= max(emp[emp$JOB_ID=='SA_REP', "SALARY"]), select=c(LAST_NAME, SALARY, JOB_ID))
# select last_name, salary, job_id from emp where salary >= (select max(salary) from emp where job_id = 'SA_REP');

# [문제133]  KING 에게 보고하는 사원들의 last_name, salary를 출력하세요.
subset(emp, MANAGER_ID %in% emp[emp$LAST_NAME=='King',"EMPLOYEE_ID"], select=c(LAST_NAME, SALARY))
# select last_name, salary from emp where manager_id in (select employee_id from emp where last_name = 'King');

# [문제134] 자신의 관리자 보다 더 많은 급여를 받는 사원이름, 사원급여, 관리자이름, 관리자급여를 출력하세요.
rm(list=ls())
setwd('c:/data')
emp <- read.csv('emp_new.csv', stringsAsFactors = F)
#sqldf
library(sqldf)
sqldf('select e.last_name, e.salary, m.last_name as mgrname, m.salary as mgrsal from emp e, (select employee_id, last_name, salary from emp) m  where m.employee_id = e.manager_id and e.salary > m.salary')

# [문제135] 자신의 부서 평균 급여보다 많이 받는 사원들의 정보를 출력하세요.
#sqldf
sqldf('select e.* from emp e, (select department_id, round(avg(salary)) as avgsal from emp group by department_id) d where e.department_id = d.department_id and e.salary > d.avgsal')
sqldf('select e.* from emp e where e.salary > (select round(avg(salary)) as avgsal from emp where department_id = e.department_id)')

# [문제136] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(tapply를 이용하세요)
# qty price
# apple   44 66000
# banana  31 70000
# berry   52 95100
# orange  21 83000
fs <- read.csv('fruits_sales.csv')
fs
#개별결과 생성
x <- tapply(fs$qty, fs$name, sum)
y <- tapply(fs$price, fs$name, sum)
#결과셋 만들기
#rbind
z <- rbind(x, y)
t(z)
#cbind
z <- cbind(qty=x,price=y)
z
#data.frame
z <- rbind(x, y)
data.frame(qty=z[1,], price=z[2,], row.names = colnames(z))

# [문제137] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(aggregate를 이용하세요)
# qty price
# apple   44 66000
# banana  31 70000
# berry   52 95100
# orange  21 83000
#개별결과생성
x <- aggregate(qty~name, fs, sum)
y <- aggregate(price~name, fs, sum)
#cbind
x <- cbind(x,y[2])
colnames(x)[1] <- ''

#merge
x <- merge(x,y)
colnames(x)[1] <- ''
x

# [문제138] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(sqldf를 이용하세요)
# qty price
# apple   44 66000
# banana  31 70000
# berry   52 95100
# orange  21 83000
sqldf('select name as " ", sum(qty) as qty, sum(price) as price from fs group by name')

# [문제139] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(tapply를 이용하세요)
x <- tapply(fs$qty, fs$year,sum)
names(x[x==max(x)])
rownames(x)[x==max(x)]

# [문제140] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(aggregate를 이용하세요)
x <- aggregate(qty~year, fs, sum)
x[x[2]==max(x[2]),'year']

# [문제141] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(sqldf를 이용하세요)
sqldf('with fr as (select year, sum(qty) as qsum from fs group by year) select year as bestYear from fr where qsum = ((select max(qsum) as sumax from fr))')

# [문제142] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.
# ddply함수를 이용하세요.
ddply(fs, 'name', summarise, netQty=sum(qty), netSales=sum(qty))

# [문제143] emp 데이터 프레임을 새로운 df 이름으로 복제하세요.
# df 데이터 프레임에  새로운 comm 컬럼을 생성하는데 COMMISSION_PCT 값을 기반으로 값을 입력하시고
# 결측값은 기존 COMMISSION_PCT의 평균 값으로 입력해주세요.(단 mutate함수를 이용하세요)
df <- emp
df <- mutate(df, comm=ifelse(is.na(COMMISSION_PCT), round(mean(COMMISSION_PCT, na.rm=T),2), COMMISSION_PCT))
head(df)

# [문제144] 부서별 급여의 총액을 pie chart를 생성하세요.
#tapply
x <- tapply(emp$SALARY, emp$DEPARTMENT_ID, sum)
pie(x, label=names(x), main='부서별 급여 총액')
pie(x, label=paste0(names(x),'번 부서 급여 총액 ', x), main='부서별 급여 총액')

#aggregate
x <- aggregate(SALARY~DEPARTMENT_ID, emp, sum)
pie(x[[2]], label=paste0(x[[1]], '번 부서', x[[2]], '만원'), main='부서별 급여 총액')

df <- aggregate(SALARY~DEPARTMENT_ID, emp, sum)
label1 <- paste(df$DEPARTMENT_ID, '부서', sep="")
label2 <- paste(df$SALARY, '만원', sep="")
pie(df$SALARY, labels=label2, main= '부서별 총액 급여', col=rainbow(length(df$SALARY)), radius=0.5)
legend(1,1,label1,fill=rainbow(length(df$SALARY)))

# [문제145] 성별 현황을 조사 자료를 이용하여 성별 인구 비율을 원형 차트로 만드세요.
# 성별 현황
# 구분	조사수
# ----	------
# 남자	226965
# 여자	241319
data <- c(226965, 241319)
name <- c('남자', '여자')
ratio <- paste0(round(data/sum(data)*100), '%')
clr <- c('blue', 'red')
#pie
pie(data, labels=ratio, main='성별 인구 현황', col=clr, radius=0.7)
legend(0.5,1.2,name,fill=clr, cex=0.8)

#pie3D
library(plotrix)
pie3D(data, labels=ratio, explode=0.1, labelcex=1.2, col=clr, main='성별 인구 현황', start=90, theta=1.1)
legend(0.4,1,name,fill=clr, cex=0.8)

legend('topright',name,fill=clr, cex=0.8)

p <- pie3D(data, labels=ratio, explode=0.1, labelcex=1.2, col=clr, main='성별 인구 현황', start=90, theta=1.1)
pie3D.labels(p, labels=name, labelrad=0.5, labelcex=1, labelcol='whitesmoke')

# [문제146] 성별 현황을 조사 자료를 이용하여 성별 인구수를 막대그래프로 만드세요.
# 성별 현황
# 구분	조사수
# ----	------
# 남자	226965
# 여자	241319
#barplot
bar <- barplot(height=data, width=0.5, names.arg=name, horiz=F, col=clr, xlab='성별', ylab='인구수(명)', ylim=c(0, 300000))
text(x=bar,y=data, labels=ratio, pos=3)

bar <- barplot(height=data, width=1, names.arg=name, horiz=F, col=clr, main='성별 인구 현황', xlab='성별', axes=F, ylim=c(0, 290000))
text(x=bar, y=data, labels=paste0(data, '명'), pos=3)

# [문제147] 부서별 인원수 막대그래프를 생성하세요. 단 부서없는 사원들의 인원수도 포함하세요.
setwd('c:/data')
emp <- read.csv('emp_new.csv')
#tapply
data <- tapply(emp$EMPLOYEE_ID,ifelse(is.na(emp$DEPARTMENT_ID), 'NA', emp$DEPARTMENT_ID), NROW)
name <- names(data)
bp <- barplot(height=data, width=0.5, names.arg=name, horiz=F, col=terrain.colors(length(data)), main='부서별 인원수', xlab='부서ID', ylab='인원수(명)', ylim=c(0, 50))
text(x=bp, y=data, labels=paste0(data, '명'), pos=3)

#aggregate
dept_cn <- aggregate(EMPLOYEE_ID~ifelse(is.na(DEPARTMENT_ID), '부서없음', DEPARTMENT_ID), emp, length)
names(dept_cn) <- c('dept_id', 'cn')
bp <- barplot(dept_cn$cn, names.arg=dept_cn$dept_id, main='부서별 인원수', xlab='부서', col=rainbow(length(dept_cn$dept_id)), cex.name=0.7, axes=F)
text(x=bp, y=dept_cn$cn, labels=paste0(dept_cn$cn, '명'),cex=0.9, pos=3)

#ddply
library(plyr)
x <- ddply(emp, 'DEPARTMENT_ID', summarise, cn=NROW(EMPLOYEE_ID))
data <- x$cn
name <- ifelse(is.na(x$DEPARTMENT_ID), 'NA', x$DEPARTMENT_ID)
bp <- barplot(height=data, width=0.5, names.arg=name, horiz=F, col=terrain.colors(length(data)), main='부서별 인원수', xlab='부서ID', ylab='인원수(명)', ylim=c(0, 50))
text(x=bp, y=data, labels=paste0(data, '명'), pos=3)

# [문제148] 부서 이름별 급여 총액에 대해서 막대그래프를 생성하세요.단 부서없는 사원들의 인원수도 포함하세요.
dept <- read.csv('dept.csv', stringsAsFactors=F)
# sqldf
library(sqldf)
raw <- sqldf('select d.department_name, sum(e.salary) as sumSal from emp e left join dept d on e.department_id=d.department_id group by d.department_name')
data <- raw$sumSal
name <- ifelse(is.na(raw$DEPARTMENT_NAME), 'NA', raw$DEPARTMENT_NAME)

# 그래프그리기
bp <- barplot(height=data, width=0.1, names.arg=name, cex.names=0.7, horiz=F, col=rainbow(length(data)), main='부서별 총액 급여', xlab='부서이름', ylab='총 급여($)', ylim=c(0,350000), las=2)
text(x=bp, y=data, labels=paste0(data, '$'), cex=0.7, pos=1, offset=0.1)

# 최고급여, 최저급여, 부서없음을 하나로 달기/서로 중첩되지 않는다면...
x <- c(rep('', length(name)))
x[which(data==max(data))] <- '최고급여'
x[which(data==min(data))] <- '최저급여'
x[which(is.na(raw$DEPARTMENT_NAME))] <- '부서없음'
text(x=bp, y=data, labels=x, cex=0.7, pos=3, col='red')

#최고급여 label을 별개로 달기
text(x=bp[data==max(data)], y=data[data==max(data)], labels='최고급여', cex=0.7, pos=3, col='red')

#최저급여 label을 별개로 달기
text(x=bp[data==min(data)], y=data[data==min(data)], labels='최저급여', cex=0.7, pos=3, col='red')

#부서없음 label을 별개로 달기
text(x=bp[is.na(raw$DEPARTMENT_NAME)], y=raw[is.na(raw$DEPARTMENT_NAME), 2], labels='부서없음', cex=0.7, pos=3, col='red')

# [문제149] fruits_sales.csv을 읽어 들인 후 년도별, 과일이름별 판매량을  그룹형 막대 그래프로 만드세요.
sales <- read.csv('fruits_sales.csv')

#orderBy
raw <- orderBy(~year+name, sales)[,1:3]

## 연도별 > 과일이름별
data <- matrix(raw$qty, ncol=4, byrow=T)
name <- unique(raw$year)
label <- unique(raw$name)
bp <- barplot(data, names.arg=name, main='연도별 과일 판매량', xlab='연도', ylab='판매량', legend.text=label, col=c('red', 'yellow', 'purple', 'orange'), ylim=c(0, 25),beside=T)
text(x=bp, y=data, labels=data, pos=3)

## 과일이름별 > 연도별
data <- matrix(raw$qty, ncol=4, byrow=F)
name <- unique(raw$name)
label <- unique(raw$year)
bp <- barplot(data, names.arg=name, main='과일별 연간 판매량', xlab='과일명', ylab='판매량', legend.text=label, col=topo.colors(length(name)), ylim=c(0, 25), beside=T)
text(x=bp, y=data, labels=data, pos=3)

# tapply
## 연도별 > 과일이름별
data <- tapply(sales$qty, list(sales$year, sales$name), sum)
name <- rownames(data)
label <- colnames(data)
bp <- barplot(data, names.arg=name, main='연도별 과일 판매량', xlab='연도', ylab='판매량', legend.text=label, col=c('red', 'yellow', 'purple', 'orange'), ylim=c(0, 25),beside=T)
text(x=bp, y=data, labels=data, pos=3)

## 과일이름별 > 연도별
data <- tapply(sales$qty, list(sales$name, sales$year), sum)
name <- rownames(data)
label <- colnames(data)
bp <- barplot(data, names.arg=name, main='과일별 연간 판매량', xlab='과일명', ylab='판매량', legend.text=label, col=topo.colors(length(name)), ylim=c(0, 25), beside=T)
text(x=bp, y=data, labels=data, pos=3)

bp <- barplot(data, names.arg=name, main='과일별 연간 판매량', xlab='과일명', ylab='판매량', col=topo.colors(length(name)), ylim=c(0, 25), beside=T)
legend('topright', title='과일', legend=label, pch=15, col=c('red', 'yellow', 'purple', 'orange'), cex=0.7)

library(plotrix)
#barlabels(x축, y축, 라벨값, cex=텍스트크기, prop=라벨위치)
barlabels(bp, data, data, cex=0.8, prop=1.04)
# boxed.labels(x축, y축, 라벨값, cex=텍스트크기, border=F(테두리 없앨시), srt=회전각도, bg=배경색)
boxed.labels(bp, data, data, cex=0.8, border=F, srt=0, bg=c('red','yellow','purple', 'orange'))