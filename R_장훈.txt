# [문제1] x변수에 1,3,5,7,9 값을 입력, y 변수에 1,2,3,4,5 값을 입력하세요.
x <- c(1,3,5,7,9)
y <- c(1,2,3,4,5)

# [문제2] x 변수와 y 변수를 중복성 없이 하나로 합친후에 u 변수에 넣어 주세요.
u <- sort(union(x,y), decreasing = FALSE)
u
# [문제3] x 변수와 y 변수의 값들중에 중복성만 추출해서 i 변수에 넣어주세요.
i <- intersect(x,y)

# [문제4] x 변수의 값과 y 변수의 값중에 순수하게 x 변수에 들어 있는 값만 추출해서 m 변수에 넣어 주세요.
m <- setdiff(x, y)
m
# [문제5] x 변수의 값과 y 변수의 값이 일치가 되면 TRUE 아니면 FALSE를 출력해주세요.
identical(x, y)

# [문제6] x 변수에 값들을 10을 곱한 결과를 x 변수에 적용하세요.
x <- x * 10

# [문제7] x 변수에 있는 50을 5로 수정하세요.
x
x[3] <- 5

# [문제8]  x 변수에 있는 10 30  5 70 90을  원래의 값으로 1,3,5,7,9로 되돌려 주세요.단 union, 정수 나누기, sort 만 사용하세요
x <- c(10, 30, 5, 70, 90)
x <- sort(union((x[-3]%/%10), x[3]))

x[which(5 == x)] <- 50
x <- x%/%10
x
# [문제9] x변수에 11숫자를 제일 뒤에 입력하세요. 단 append와 length를 이용하세요.
append(x, 11, after=length(x))

# [문제10] x 변수에 제일 뒤에 있는 값을 NA로 수정하세요. 단 length를 이용하세요.
x[length(x)] <- NA

# [문제11] lst 변수에 name = 'king' , height = 180, weight = 70 값을 넣어 주세요.
lst <- list(name = 'king', height = 180, weight = 70)
lst

# [문제12] lst 변수에  blood = 'A' 추가하세요.
lst$blood <- 'A'
lst

# [문제13] lst 변수에 name의 값을 'scott'로 수정하세요.
lst$name <- 'scott'

# [문제14] lst변수에 2번인덱스 값만 출력해주세요.
lst[[2]]

# [문제15] lst변수에 blood 이름을 blood type 이름으로 수정하세요.
names(lst) <- c('name', 'height', 'weight', 'blood type')
names(lst)[4] <- 'blood type'
lst

# [문제16] x 변수에 벡터값 1,2,3,5,6 을 입력한 후 3번째 요소 뒤에 4를 입력하세요.
x <- c(1,2,3,5,6)
x <- append(x, 4, after = 3)

# [문제17] 1부터  3씩 증가하는 10 이하의 정수값을 출력하세요.
seq(1, 10, 3)
seq(1, 10, length.out=100) #length.out = x : x개만큼 등분

# [문제18] 10 부터 20 까지의 값을 x 변수에 생성한 후 원소의 값이 15 이상이고 18 이하인 값들만 출력하세요.
x <- c(10:20)
x[which(15 <= x & 18 >= x)]

# [문제19] 10 부터 20 까지의 값을 x 변수에 생성한 후 원소의 값이 15 이상이고 18 이하인 값들만 2곱한 값으로 수정하세요.
x <- c(10:20)
x[which(15 <= x & 18 >= x)] <- x[which(15 <= x & 18 >= x)]*2

# [문제20] x 변수에 행렬을 구성하세요. 값은 1부터 10까지 입력하시고 5행 2열으로 만들면서 값은 열을 기준으로 생성하세요.
x <- matrix(c(1:10), nrow=5, byrow=FALSE)

#[문제21] x 변수에 열을 기준으로 11,12,13,14,15 값을 추가하세요.
x <- cbind(x, c(11:15))
x
# [문제22] x 변수에 행을 기준으로 16,17,18 값을 추가하세요.
x <- rbind(x, c(16:18))
x

# [문제23] x변수에 6행의 값을 20,21,22 로 수정하세요.
x[6,] <- c(20:22)
x

# [문제24] x 변수에 6행을 제거해주세요.
x <- x[-6,]
x

# [문제25] x 배열을 생성하세요. 1부터 12까지 값을 가지고있는 배열을 생성하세요. 면은 3개가 만들어지도록하세요.
x <- array(c(1:12), dim=c(2,2,3))
x <- array(1:12, dim=c(2,2,3))

#[문제26] x 배열 변수에 컬럼이름은 'a','b'로 설정하세요.
colnames(x) <- c('a','b')

#[문제27] x 배열 변수에 행이름은 'row1','row2'로 설정하세요.
rownames(x) <- c('row1','row2')

#[문제28] x 배열 변수에 면을 2로 수정하세요.
dim(x) <- c(3,2,2)
x

# [문제29] 벡터에 있는 값 "large", "medium", "small", "small", "large", "medium" 을 factor 변수로 구성하세요. 
# 변수이름은x로 생성하시고 levels samall, medium, large 순으로 지정하세요.
x <- factor(c('large','medium','small','small','large','medium'), levels=c('small', 'medium','large'),ordered=TRUE)
x

#[문제30] x factor형 목록이름중에 small 을 s로 수정하세요.
levels(x)[1] <- 's'
levels(x)[levels(x) == 'small'] <- 's'
x

# [문제31] 아래와 같은 모양의 변수를 생성하세요. 변수 이름은 df로 하세요.
# <화면출력>
# df
# name sql  plsql
# 1  king  96     75
# 2 smith  82     91
# 3  jane  78     86
df <- data.frame(name=c('king','smith','jane'), sql=c(96, 82, 78), plsql=c(75, 91, 86), stringsAsFactors=FALSE)
df

# [문제32] df변수에 james, 90, 80 추가 해주세요.
# <화면출력>
# > df
# name sql plsql
# 1  king  96    75
# 2 smith  82    91
# 3  jane  78    86
# 4 james  90    80
df[4,] <- c('james', 90, 80)
df
df <- rbind(df, c('james',90,80))
df <- rbind(df, data.frame(name='james',sql=90,plsql=80))

# [문제33] james에 대한 row 정보만 출력하세요.
# <화면출력>
# name sql plsql  r
# 4 james  90    80 60
df[df$name=='james',]

# [문제34]. emp 변수에 있는 데이터 중에 급여가 3000 인 사원들의 last_name, salary를 출력하세요. 단 emp 변수에 컬럼정보를 확인하시고 수행하세요.
names(emp)
emp[emp$SALARY==3000, c('LAST_NAME', 'SALARY')]
# desc emp
# select last_name, salary from emp where salary = 3000;

# [문제35] 급여가 2000 이상인 사원들의 last_name, salary를 출력하세요.
emp[emp$SALARY>=2000, c('LAST_NAME', 'SALARY')]
# select last_name, salary from emp where salary >= 2000;

# [문제36] job이 ST_CLERK인 사원들의 이름과 월급과 직업을  출력하세요.
emp[emp$JOB_ID=='ST_CLERK', c('LAST_NAME', 'SALARY', 'JOB_ID')]
# select last_name, salary, job_id from emp where job_id = 'ST_CLERK';

# [문제37] job이 ST_CLERK이 아닌 사원들의 이름과 월급과 직업을  출력하세요.
emp[emp$JOB_ID!='ST_CLERK', c('LAST_NAME', 'SALARY', 'JOB_ID')]
# select last_name, salary, job_id from emp where job_id != 'ST_CLERK';

# [문제38] 오라클의 in 연산자와 비슷한 R연산자는?
%in%

# [문제39] job이 AD_ASST, MK_MAN 인 사원들의 employee_id,last_name,job_id를 출력하세요.
emp[emp$JOB_ID%in%c('AD_ASST', 'MK_MAN'), c('EMPLOYEE_ID', 'LAST_NAME', 'JOB_ID')]
#select employee_id, last_name, job_id from emp where job_id in ('AD_ASST', 'MK_MAN');

# [문제40] job이 ST_CLERK, SH_CLERK, SA_REP 아닌 사원들의 employee_id,last_name,job_id를 출력하세요.
emp[!emp$JOB_ID%in%c('ST_CLERK','SH_CLERK', 'SA_REP'), c('EMPLOYEE_ID', 'LAST_NAME', "JOB_ID")]
#select employee_id, last_name, job_id from emp where job_id not in ('ST_CLERK', 'SH_CLERK', 'SA_REP');

# [문제41] 부서번호가 10번,20번인 사원들의 last_name, salary, department_id를 출력하세요.
emp[emp$DEPARTMENT_ID%in%c(10, 20), c("LAST_NAME", "SALARY", "DEPARTMENT_ID")]
#select last_name, salary, department_id from emp where department_id in (10, 20);

# [문제42] 오라클의 연결 연산자 와 비슷한 R 연산자는?
# 오라클		       R
# || concat   		paste(,,,,)

# [문제43] 아래결과와 같이 출력되도록하세요. 
# Grant 의 직업은  SH_CLERK  입니다.
help(paste)
paste(emp[,'LAST_NAME'],'의 직업은',emp[,'JOB_ID'],'입니다.')
paste0(emp$LAST_NAME,'의 직업은',emp$JOB_ID,'입니다.')

# [문제44] R에서 NA(결측치)를 체크하는 함수는?
is.na()

# [문제45] commission_pct에  NA 인 사원들의 last_name, salary, commission_pct를 출력하세요.
emp[is.na(emp$COMMISSION_PCT), c("LAST_NAME", "SALARY", "COMMISSION_PCT")]
# select last_name, salary, commission_pct from emp where commission_pct is null;

# [문제46] department_id에 NA 인 사원들의 last_name, salary, department_id를 출력하세요.
emp[is.na(emp$DEPARTMENT_ID), c("LAST_NAME", "SALARY", "DEPARTMENT_ID")]
# select last_name, salary, department_id from emp where department_id is null;

# [문제47] commission_pct에  NA가 아닌 사원들의 last_name, salary, commission_pct를 출력하세요.
emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "SALARY", "COMMISSION_PCT")]
# select last_name, salary, commission_pct from emp where commission_pct is not null;

# [문제48] 30번 부서 사원들이면서 급여는 3000이상인 사원들의 employee_id, salary, department_id를 출력하세요.
emp[emp$DEPARTMENT_ID==30 & emp$SALARY >= 3000 , c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
# select employee_id, salary, department_id from emp where department_id = 30 and salary >= 3000;
#조건이 걸린 키값에 NA값이 있다면 해당열은 모두 NA가 되어 출력됨
#na.omit(): na가 있는 행을 모두 제거
na.omit(emp[emp$DEPARTMENT_ID==30 & emp$SALARY >= 3000 , c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]) 

# [문제49] 20번부서 사원이면서 급여는 10000를 초과한 사원 또는 급여가 2500 미만의 사원들의 employee_id, salary, department_id를 출력하세요.
emp[(emp$DEPARTMENT_ID==20 & emp$SALARY > 10000)|emp$SALARY<2500, c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
emp[emp$DEPARTMENT_ID==20 & emp$SALARY > 10000|emp$SALARY<2500, c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
emp[emp$SALARY<2500, c("EMPLOYEE_ID", "SALARY", "DEPARTMENT_ID")]
# select employee_id, salary, department_id from emp where (department_id = 20 and salary > 10000) or salary < 2500;

# [문제50]last_name의 첫번째 글자가 A 로 시작하는 사원들의 last_name, salary를 출력하세요.
emp[grep('^A', emp$LAST_NAME,ignore.case=FALSE), c("LAST_NAME", "SALARY")]
emp[grep('^A.*', emp$LAST_NAME,ignore.case=FALSE), c("LAST_NAME", "SALARY")]

# [문제51]last_name의 끝글자가 g 로 끝나는 사원들의 last_name, salary를 출력하세요.
emp[grep('g$', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]
emp[grep('*g$', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]
emp[grep('*.g$', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]
 
# [문제52]last_name의 z 를 포함하고 있는 사원들의 last_name, salary를 출력하세요.
emp[grep('z', emp$LAST_NAME, ignore.case=TRUE), c("LAST_NAME","SALARY")]
emp[grep('z', emp$LAST_NAME, ignore.case=TRUE), c("LAST_NAME","SALARY")]
emp[grep('^.*z.*$', emp$LAST_NAME, ignore.case=TRUE), c("LAST_NAME","SALARY")]
 
# [문제53]last_name의 두번째 철자가 u 인 사원들의 last_name, salary를 출력하세요.
emp[grep('^.u', emp$LAST_NAME, ignore.case=FALSE), c("LAST_NAME", "SALARY")]

# [문제54] developer글자를 첫글자 대문자, 뒤글자는 소문자로 변환하세요.
word <- 'developer'
last <- nchar(word)
paste0(toupper(substr(word, 1, 1)),tolower(substr(word,2,last)))

library(tools)
toTitleCase(word)

install.packages('stringr')
library(stringr)
str_to_title(word)

#[문제55] last_name의 글자의 수가 10이상인 사원의 employee_id, last_name 출력하세요.
setwd('c:/data')
getwd()
emp <- read.csv('emp_new.csv', header=TRUE, stringsAsFactors=FALSE)
emp[ nchar(emp$LAST_NAME)>= 10, c("EMPLOYEE_ID", "LAST_NAME")]
#select employee_id, last_name from emp where len(last_name ) >= 10;

# [문제56] last_name, last_name의 첫번째 철자부터 세번째 철자까지 함께 출력하세요.
paste0(emp[, "LAST_NAME"], substr(emp[,"LAST_NAME"], 1, 3))
#select last_name||substr(last_name, 1, 3) from emp;

# [문제57] last_name의 두번째 철자가 m  인 사원들의 last_name, salary를 출력하세요.
emp[substr(emp[,"LAST_NAME"],2,2)=='m', c("LAST_NAME", "SALARY")]
# select last_name, salary from emp where substr(last_name, 2, 1) = 'm';
emp[grep('^.m', emp$LAST_NAME), c("LAST_NAME", "SALARY")]

# [문제58] last_name의 두번째 철자가 m 또는 g 인 사원들의 last_name, salary를 출력하세요.
emp[substr(emp[,"LAST_NAME"],2,2)=='m'|substr(emp[,"LAST_NAME"],2,2)=='g', c("LAST_NAME","SALARY")]
#select last_name, salary from emp where substr(last_name,2,1)='m' or substr(last_name,2,1)='g';
emp[substr(emp$LAST_NAME, 2, 2)%in%c('m','g'), c("LAST_NAME", "SALARY")]
emp[c(grep('^.m', emp$LAST_NAME), grep('^.g', emp$LAST_NAME)), c("LAST_NAME", "SALARY")]
emp[grep('^.m|^.g', emp$LAST_NAME), c("LAST_NAME", "SALARY")]
emp[grepl('^.m', emp$LAST_NAME)|grepl('^.g', emp$LAST_NAME), c("LAST_NAME", "SALARY")]

# [문제59] last_name, salary값을 화면에 출력할때 0은 * 로 출력하세요.
gsub(0, '*',emp[,c("LAST_NAME","SALARY")])
data.frame('last_name'=emp[, "LAST_NAME"], 'salary'=gsub(0, '*', emp[, "SALARY"]), stringsAsFactors = FALSE)
#select last_name, replace(salary, 0, '*') from emp;
paste(emp$LAST_NAME, gsub(0, '*', emp$SALARY))

# [문제60] last_name의 제일 뒷글자만 대문자 앞글자들은 소문자로 출력하세요.
lname <- emp[,"LAST_NAME"]
paste0(tolower(substr(lname,1, nchar(lname)-1)),toupper(substr(lname,nchar(lname), nchar(lname))))
# select lower(substr(last_name,1,length(last_name)-1))||upper(substr(last_name,length(last_name))) from emp;

# [문제61] s 백터 변수를 생성해서 "BIG DATA MARKETING" 입력한 후 단어로 분리해주세요.
s <- c('BIG DATA MARKETING')
strsplit(s, split=' ')
# declare
# v_sentence varchar2(100) := 'BIG DATA MARKETING';
# v_blank number;
# v_start number := 1;
# v_word varchar2(20);
# v_ind number := 1;
# begin
# loop
# select instr(v_sentence, ' ', 1, v_ind) into v_blank from dual;
# if v_blank = 0 then
# select substr(v_sentence, v_start) into v_word from dual;
# else
#   select substr(v_sentence, v_start, v_blank-v_start) into v_word from dual;
# end if;
# v_start := v_blank+1;
# v_ind := v_ind + 1;
# dbms_output.put_line(v_word);
# exit when v_blank = 0;
# end loop;
# end;
# /

#[문제62] 2002-06-07에 입사한 사원들의 last_name, hire_date를  출력하세요.
emp[emp$HIRE_DATE == 20020607, c("LAST_NAME", "HIRE_DATE")]
# select last_name, hire_date from emp where hire_date = '20020607';

#[문제63] 사원의 last_name, 근무일수를 출력하세요.
data.frame('last_name' = emp$LAST_NAME, '근무일수' = difftime(Sys.Date(), as.Date(as.character(emp$HIRE_DATE), '%Y%m%d')))
# select last_name, trunc(months_between(sysdate, hire_date)*30) as Work_day from emp;

# [문제64] 사원의 last_name, 입사한 요일을 출력하세요.
data.frame('last_name' = emp$LAST_NAME, '입사요일' = weekdays(as.Date(as.character(emp$HIRE_DATE), '%Y%m%d')))
# select last_name, to_char(hire_date, 'day') from emp;

# [문제65] 오늘 날짜를 기준으로  100개월 되는 날짜의 요일을 출력하세요.
weekdays(Sys.Date() + months(100))
# select to_char(add_months(sysdate, 100), 'day') from dual;
format(Sys.Date() + months(100), '%A')
wday(Sys.Date() + months(100), label=T)
#일일이 형변환을 하기보다 데이터셋의 형을 바꿔주면 편함
emp$HIRE_DATE <- as.Date(as.character(emp$HIRE_DATE), format='%Y%m%d')

# [문제 66] 부서번호를 중복제거해주세요.
as.integer(na.omit(unique(emp$DEPARTMENT_ID)))
sort(unique(emp$DEPARTMENT_ID))
# select distinct(department_id) from emp;

# [문제67] last_name, hire_date를  출력하는데 먼저 입사한 사원부터 출력하세요.
getwd()
setwd('c:/data')
emp <- read.csv('emp_new.csv', stringsAsFactors = F, header = T)
library(doBy)
orderBy(~HIRE_DATE, emp[, c("LAST_NAME", "HIRE_DATE")])

# [문제68] df이름의 data frame 변수를 선언합니다.
# id 컬럼의 값은 100,101,102,103,104,  
# weight 컬럼의 값은 60,90,75,95,65, 
# size 컬럼의 값은 small, large, medium,large,small 값으로 생성하세요.
df <- data.frame(id = c(100:104), weight = c(60, 90, 75, 95, 65), size = c('small', 'large', 'medium', 'large', 'small'))

# [문제69] df변수에 weight 컬럼을 기준으로 오름차순 정렬해서 df 변수에 값을 출력하세요.(order 함수를 이용하세요)
df[order(df$weight),]
# select weight from df order by weight;

# [문제70] df변수에 size, weight 컬럼을 기준으로 오름차순 정렬하세요.(order 함수를 이용하세요)
df[order(df$weight, df$size), ] #선행컬럼을 먼저 정렬 후 후행 컬럼 정렬
# select size, weight from df order by size, weight;

# [문제71] df 변수에 있는 weight 컬럼을 기준으로 내림차순 정렬하세요.(order 함수를 이용하세요)
df[order(df$weight, decreasing = T), ]
df[order(-df$weight), ]
# select weight from df order by weight desc;

# [문제72] 30번 부서 사원들의 last_name, salary를  출력하세요.
# 단 salary를 기준으로 내림차순정렬하세요.
na.omit(orderBy(~-SALARY, emp[emp$DEPARTMENT_ID==30, c("LAST_NAME", "SALARY")]))
# select last_name, salary from emp where department_id = 30 order by salary desc;

# [문제73] job_id가  ST_CLERK 가 아닌 사원들의 last_name, salary, job_id를 출력하는데 급여가 높은 사원부터 출력되게하세요.(orderBy 함수를 이용하세요)
orderBy(~-SALARY, emp[emp$JOB_ID!='ST_CLERK', c("LAST_NAME", "SALARY", "JOB_ID")])
# select last_name, salary, job_id from emp where job_id != 'ST_CLERK' order by salary desc;

# [문제74] 사원 last_name, salary, commission_pct를 출력하는데 commission_pct를 기준으로 오름차순정렬하세요.(orderBy를 이용하세요)
orderBy(~COMMISSION_PCT, emp[, c("LAST_NAME", "SALARY", "COMMISSION_PCT")])
# select last_name, salary, commission_pct from emp order by commission_pct;

# [문제75] commission_pct를 받고 있는 사원들의 last_name, salary, commission_pct를 출력하는데 commission_pct를 기준으로 오름차순정렬하세요.(orderBy를 이용하세요)
na.omit(orderBy(~COMMISSION_PCT, emp[, c("LAST_NAME", "SALARY", "COMMISSION_PCT")]))
orderBy(~COMMISSION_PCT, emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "SALARY", "COMMISSION_PCT")])
# select last_name, salary, commission_pct from emp where commission_pct is not null order by commission_pct;

# [문제76] 6의 9승을 출력하세요 
6^9
# select power(6, 9) from dual;

# [문제77] 10을 3으로 나눈 나머지값을 출력하세요 
10%%3
# select mod(10, 3) from dual;

# [문제78] last_name, salary에 12를  곱해서 출력하고 컬럼명이 한글로 연봉으로  데이터 프레임으로 출력하세요 
x <- data.frame(last_name = emp$LAST_NAME, '연봉' = emp$SALARY*12, stringsAsFactors = F)
# select last_name, salary * 12 as 연봉 from emp;

# [문제79] last_name과 연봉을 출력하는데 연봉이 높은것부터 출력하세요 
orderBy(~-연봉, x[, c("last_name", "연봉")])
# select last_name, 연봉 from x order by 연봉 desc;
orderBy(~-연봉, data.frame(emp$LAST_NAME, 연봉=emp$SALARY*12))

# [문제80] 문제79를 round 함수를 이용해서 아래와 같이 백단위에서 반올림되게 하세요. 
# 4:  JONES 35700  ----->  36000
x$연봉 <- round(x$연봉, -3)
orderBy(~-연봉, data.frame(emp$LAST_NAME, 연봉=round(emp$SALARY*12, -3)))
# select last_name, round(연봉, -3) from x;

# [문제81] 최대월급을 출력하세요
max(emp$SALARY)
# select max(salary) from emp;
 
# [문제82] 직업이 ST_CLERK 인 사원들중에 최대월급을 출력하세요
max(emp[emp$JOB_ID=='ST_CLERK', "SALARY"])
# select max(salary) from emp where job_id = 'ST_CLERK';

# [문제83] 부서번호별로 급여에 총액을 출력하세요.
aggregate(SALARY~DEPARTMENT_ID,emp,sum)
# select department_id, sum(salary) from emp group by department_id;

# [문제84] 부서번호, 직업별로 급여에 총액을 출력하세요.
aggregate(SALARY~DEPARTMENT_ID+JOB_ID,emp,sum)
# select department_id, job_id, sum(salary) from emp group by department_id, job_id;

# [문제85] 부서번호별 최대월급을 출력하는데 최대월급이 높은것부터 출력하세요.
orderBy(~-SALARY, aggregate(SALARY~DEPARTMENT_ID,emp,max))
# select department_id, max(salary) as maxsal from emp group by department_id order by maxsal desc;

# [문제86] 직업별 인원수를 출력하세요.
aggregate(EMPLOYEE_ID~JOB_ID,emp,NROW)
# select job_id, count(*) from emp group by job_id;

# [문제87] 아래화면의 결과 처럼 데이터 프레임을 생성한 후 
# total 컬럼을 생성해서 sql과 python 의 합을 구하세요.(단 apply함수를 이용하세요)
# name 	sql 	python
# king	96	75
# smith	NA	91
# jane	78	86
# scott	90	NA

score <- data.frame(name=c('king', 'smith', 'jane','scott'), sql=c(96, NA, 78, 90), python=c(75, 91, 86, NA), stringsAsFactors = F)
score$total <- apply(score[,2:3], 1, sum, na.rm=T)
score

score <- cbind(score, total=apply(score[,c(2,3)], 1, sum, na.rm=T))
# create table score(name varchar2(10), sql number(10), python number(10)) tablespace users;
# insert into score values('king', 96, 75);
# insert into score values('smith', null, 91);
# insert into score values('jane', 78, 86);
# insert into score values('scott', 90, null);

# alter table score add total number(20);

# declare 
#   type sum_type is record(lname varchar2(20), sums number);
#   type tab_type is table of sum_type;
#   ssum tab_type;
# begin
#   select name, nvl(sql,0) + nvl(python,0) bulk collect into ssum from score;
#   forall i in 1..ssum.last
#     update score set total = ssum(i).sums where name = ssum(i).lname;
# end;
# /

#[문제88] 입사한 년도별 평균월급을 세로(aggregate), 가로(tapply)로 출력하세요.
getwd()
setwd('c:/data')
emp <- read.csv('emp_new.csv', stringsAsFactors = F)
#세로
class(emp$HIRE_DATE)
x <- aggregate(SALARY~format(as.Date(as.character(HIRE_DATE), format='%Y%m%d'), '%Y'), emp, mean)
colnames(x) <- c('hiredate','avgsal')
x

aggregate(list(AvgSal = emp$SALARY), list(HireYear = substr(emp$HIRE_DATE, 1, 4)), mean)
# select substr(hire_date,1,4) as HireYear, round(avg(salary)) as AvgSal from emp group by substr(hire_date,1,4) order by 1;

#가로
tapply(emp$SALARY, substr(emp$HIRE_DATE, 1, 4), mean)

# [문제89] 부서별 인원수를 세로(aggregate), 가로(tapply)로 출력하세요.
#세로
x <- aggregate(EMPLOYEE_ID~DEPARTMENT_ID, emp, NROW)
colnames(x) <- c('DEPARTMENT_ID', 'NET_PEOPLE')
x

aggregate(list(EmpId=emp$EMPLOYEE_ID), list(DepId=emp$DEPARTMENT_ID), NROW)
# select department_id, count(*) from emp group by department_id order by 1;

#가로
tapply(emp$EMPLOYEE_ID, emp$DEPARTMENT_ID, NROW)

# [문제90]job_id, hire_date(년도4자리) 총액 급여를 aggregate함수를 이용해서 생성하세요.
aggregate(list(SumSal=emp$SALARY), list(JobId=emp$JOB_ID, HireYear=substr(emp$HIRE_DATE, 1, 4)), sum)
# select job_id, substr(hire_date, 1, 4) as hireyear, sum(salary) from emp group by job_id,substr(hire_date, 1, 4) order by 2, 1;

# [문제91] job_id, hire_date(년도4자리) 총액 급여를 tapply함수를 이용해서 생성하세요.
# 단 NA 대신에 0 으로 출력하세요.
tapply(emp$SALARY, data.frame(JobId=emp$JOB_ID, HireYear=substr(emp$HIRE_DATE, 1, 4)), sum, default=0)

# [문제 92] 변수에 2를 입력한 후 그 변수의 값이 2의 배수면 '2의 배수'를 출력, 아니면 '2의 배수가 아니다' 출력해주세요
x <- 2
yes <- '2의 배수'
no <- '2의 배수가 아닙니다'
if(x%%2==0){yes}else{no}
ifelse(x%%2==0,yes, no)
# declare
# x number := 2;
# begin
# if mod(x,2)=0 then
# dbms_output.put_line('2의 배수');
# else
#   dbms_output.put_line('2의 배수가 아닙니다');
# end if;
# end;
# /


# [문제93] emp 변수에 있는 데이터를 가지고 새로운 df변수를 생성하세요.
# last_name, salary, 급여가 10000  이상이면 A, 5000이상 10000보다 작으면 B 나머지는 C가 입력되어 있는 새로운 컬럼을 생성하세요.  
# 컬럼이름은 name, sal, level 로 설정하세요.
df <- data.frame(name=emp$LAST_NAME, sal=emp$SALARY, level=ifelse(emp$SALARY>=10000, 'A', ifelse(emp$SALARY>=5000, 'B', 'C')))
df
# declare
#   type rec_type is record(name emp.last_name%type, sal emp.salary%type, level varchar2(10));
#   type tab_type is table of rec_type;
#   df tab_type;
# begin
#   select last_name, salary, null bulk collect into df from emp;
#   for i in df.first..df.last loop
#     if df(i).sal >= 10000 then
#       df(i).level := 'A';
#     elsif df(i).sal between 5000 and 9999 then
#       df(i).level := 'B';
#     else
#       df(i).level := 'C';
#     end if;
#     dbms_output.put_line(df(i).name||' '||df(i).sal||' '||df(i).level);
#   end loop;
# end;
# /


# [문제94] x 변수에 1부터 100까지 입력한 후 짝수값은 자신의 값에 10을 곱한 값으로 수정하세요.
x <- 1:100
x <- ifelse(x%%2==0,x*10,x)
x

x[x%%2==0] <- x[x%%2==0] * 10
# declare
#   type tab_type is table of number index by pls_integer;
#   x tab_type;
# begin
#   for i in 1..100 loop
#     x(i) := i;
#   end loop;
#   for i in 1..x.last loop
#     if mod(x(i), 2)=0 then
#       x(i) := i*10;
#     end if;
#     dbms_output.put_line(x(i));
#   end loop;
# end;
# /

# [문제95]  x <- c(2,10,6,4,3,NA,7,9,1)  x변수에 NA가 있는지를 검사하세요.
x <- c(2,10,6,4,3,NA,7,9,1)
is.na(x)

# [문제96] x 변수에 NA가 있는 인덱스 번호를 찾아 주세요.
which(is.na(x))
# declare
#   type tab_type is table of number;
#   x tab_type := tab_type(2, 10, 6, 4, 3, null, 7, 8, 1);
# begin
#   for i in x.first..x.last loop
#     if x(i) is null then
#       dbms_output.put_line(i);
#     end if;
#   end loop;
# end;
# /

# [문제97] x 변수에 NA가 있으면 0으로 설정하세요
x <- ifelse(is.na(x), 0,x)
# declare
#   type tab_type is table of number;
#   x tab_type := tab_type(2, 10, 6, 4, 3, null, 7, 8, 1);
# begin
#   for i in x.first..x.last loop
#     if x(i) is null then
#       x(i) := 0;
#     end if;
#   end loop;
# end;
# /

x[which(is.na(x))] <- 0

# [문제98] last_name, salary, commission_pct, 
# commission_pct NA 면 salary * 12,
# 아니면 (salary * 12) + (salary * 12 * commission_pct)을 수행하세요.
# > head(df)
# name   sal comm ann_sal
# 1  OConnell  2600   NA   31200
# 2     Grant  2600   NA   31200
# 3    Whalen  4400   NA   52800
# 4 Hartstein 13000   NA  156000
# 5       Fay  6000   NA   72000
# 6    Mavris  6500   NA   78000
df <- data.frame(name=emp$LAST_NAME, sal=emp$SALARY, comm=emp$COMMISSION_PCT, ann_sal=ifelse(is.na(emp$COMMISSION_PCT), emp$SALARY*12, (emp$SALARY*12)+(emp$SALARY*12*emp$COMMISSION_PCT)))
df
# declare
#   type rec_type is record(name emp.last_name%type, sal emp.salary%type, comm emp.commission_pct%type, ann_sal number);
#   type tab_type is table of rec_type;
#   df tab_type;
# begin
#   select last_name, salary, commission_pct, null bulk collect into df from emp;
#   for i in df.first..df.last loop
#     if df(i).comm is not null then
#       df(i).ann_sal := (df(i).sal * 12) * (1+df(i).comm);
#     else
#       df(i).ann_sal := df(i).sal * 12;
#     end if;
#     dbms_output.put_line(df(i).name||' '||df(i).sal||' '||df(i).comm||' '||df(i).ann_sal);
#   end loop;
# end;
# /

# [문제99] x변수에 1부터 100까지 입력한 후
# 1은 합을, 2는 평균, 3은 분산, 4는 표준편차를
# 구하는 switch문을 생성하세요.
x <- 1:100
y <- 4
switch(y, sum(x), mean(x), var(x), sd(x))
# create or replace procedure calc(p_num in number)
# is
#   rst number;
# begin
#   if p_num = 1 then
#     select sum(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   elsif p_num = 2 then
#     select avg(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   elsif p_num = 3 then
#     select variance(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   elsif p_num = 4 then
#     select stddev(n) into rst from (select level n from dual connect by level <= 100);
#     dbms_output.put_line(rst);
#   end if;
# end;
# /

# [문제 100] 1부터 10까지 합을 for문을 이용해서 구하세요
x <- 0
for(i in 1:10){x <- x+i}
# declare
#   rst number := 0;
# begin
#   for i in 1..100 loop
#     rst := rst+i;
#   end loop;
#   dbms_output.put_line(rst);
# end;
# /

# [문제 101] 1부터 100까지 전체합, 짝수합, 홀수합을 출력하세요
t_sum <- 0
o_sum <- 0
e_sum <- 0
#if
for(i in 1:100){
  if(i%%2 == 0){e_sum <- e_sum + i
  }else{o_sum <- o_sum + i
  }
  t_sum <- t_sum + i
}
#switch
for(i in 1:100){
  x <- (i%%2)+1 
  switch(x, e_sum <- e_sum+i, o_sum <- o_sum+i)
  t_sum <- t_sum + i
}
o_sum
e_sum
t_sum
# declare
#   rst number := 0;
#   o_sum number := 0;
#   e_sum number := 0;
# begin
#   for i in 1..100 loop
#     rst := rst + i;
#     if mod(i, 2) = 0 then
#       e_sum := e_sum + i;
#     else
#       o_sum := o_sum + i;
#     end if;
#   end loop;
#   dbms_output.put_line('전체합:'||rst||' 짝수합: '||e_sum||' 홀수합: '||o_sum);
# end;
# /

# [문제 102] 1부터 100까지 짝수합, 홀수합을 tapply를 이용해서 구하세요
x <- 1:100
a <- tapply(x, x%%2==0, sum)
names(a) <- c('Odd Sum', 'Even Sum')
a

# [문제103] 1부터100까지 홀수만 x 변수에 입력해주세요.(for문을 이용하세요)
#list사용
x <- list()
#append(list, element)를 하면 순서대로 저장
for(i in 1:100){
  if(i%%2==1){x <- append(x, i)}
}
#append(element, list)를 하면 stack처럼 역순으로 저장
for(i in 1:100){
  if(i%%2==1){x <- append(i, x)}
}
x
#벡터 사용
z <- NULL
for(i in 1:100){
  if(i%%2==1){z <- c(z, i)}
}

#cbind
for(i in 1:100){
  if(i%%2==1){z <- cbind(z, i)}
}

#rbind
for(i in 1:100){
  if(i%%2==1){z <- rbind(z, i)}
}
z
# create table test_table(x number);
# begin
#   for i in 1..100 loop
#     if mod(i,2)=1 then
#       insert into test_table(x) values(i);
#     end if;
#   end loop;
# end;
# /


# [문제104] while문을 이용해서 2단을 출력하세요.
# [1] "2 x 1 = 2"
# [1] "2 x 2 = 4"
# [1] "2 x 3 = 6"
# [1] "2 x 4 = 8"
# [1] "2 x 5 = 10"
# [1] "2 x 6 = 12"
# [1] "2 x 7 = 14"
# [1] "2 x 8 = 16"
# [1] "2 x 9 = 18"
i <- 1
while(i <= 9){
  print(paste0('2 x ',i,' = ',2*i))
  i <- i + 1
}
# declare
#   i number := 1;
# begin
#   while i < 10 loop
#     dbms_output.put_line('2 x '||i||' = '||i*2);
#     i := i + 1;
#   end loop;
# end;
# /

# [문제105] repeat문을 이용해서 2단을 출력하세요.
# [1] "2 x 1 = 2"
# [1] "2 x 2 = 4"
# [1] "2 x 3 = 6"
# [1] "2 x 4 = 8"
# [1] "2 x 5 = 10"
# [1] "2 x 6 = 12"
# [1] "2 x 7 = 14"
# [1] "2 x 8 = 16"
# [1] "2 x 9 = 18"
i <- 1
repeat{
  if(i == 10){break
  }else{
      print(paste0('2 x ',i,' = ',2*i))
      i <- i +1}
}
# declare
#   i number := 1;
# begin
#   loop
#     dbms_output.put_line('2 x '||i||' = '||i*2);
#     i := i + 1;
#     exit when i = 10;
#   end loop;
# end;
# /

# [문제106] x변수에 1부터 10까지 입력한 후 홀수인지 짝수인지를 출력하세요.
# 1  2  3  4  5  6  7  8  9 10
# "홀수" "짝수" "홀수" "짝수" "홀수" "짝수" "홀수" "짝수" "홀수" "짝수"
x <- 1:10
#ifelse
ifelse(x%%2==0,'짝수','홀수')

#if
for(i in x){if(i%%2==0){print('짝수')}else{print('홀수')}}

#switch
for(i in x){switch(i%%2+1,print('짝수'), print('홀수'))}

#sql
# declare
#   type tab_type is table of number index by pls_integer;
#   x tab_type;
# begin
#   for i in 1..10 loop
#     x(i) := i;
#   end loop;
#   for i in x.first..x.last loop
#     if mod(x(i),2)=0 then
#     dbms_output.put_line('짝수');
#   else
#     dbms_output.put_line('홀수');
#   end if;
#   end loop;
# end;
# /

# [문제107] mysentence 이름의 벡터 변수에 'Well begun is half done' 이 값을 입력한 후 공백문자를 기준으로 분리해서 word 변수에 입력하세요. 
# word 변수에 타입을 체크한 후 word 변수에 입력된 값의 수를 출력하세요.
mysentence <- 'Well begun is half done'
word <- strsplit(mysentence,' ')
class(word)
mode(word)       
str(word)

class(word[1])
mode(word[1])       
str(word[1])

class(word[[1]])
mode(word[[1]])       
str(word[[1]])

#length
length(word[[1]])

#NROW
NROW(word[[1]])

#sapply
sapply(word, length)

# [문제108] 문제107에서 만든 word변수에 있는 값을  리스트 변수 letters에 하나씩 저장하세요.
letters <- list()
for(i in word[[1]]){letters <- append(letters, i)}
letters

letters <- list(rep(NA, 5))
for(i in 1:length(word[[1]])){letters[i] <- word[[1]][i]}
letters

# [문제109] 문제108에서 생성한 letters 변수에 있는 값을 myword변수에 하나의 문장으로 넣어 주세요.
# > myword
# [1] "Well begun is half done"
myword <- NULL
#for
for(i in letters){myword <- paste0(myword, i,' ')}

#뒷공백 제거
for(i in 1:length(letters)){if(i < length(letters)){myword <- paste0(myword,letters[i],' ')}else{myword <- paste0(myword,letters[i])}}

#while
i <- 0
while(i<=length(letters)){
  i <- i + 1
  if(i < length(letters)){paste0(myword,letters[i],' ')}else{paste0(myword,letters[i])}
  }

#for / paste & collapse
for(i in letters){myword <- paste(c(myword, i), collapse = ' ')}
myword
# [문제 110] hap함수에 인자값을 입력하게 되면 1부터 입력한 숫자까지누적합을 구하세요
hap <- function(x){
  res <- 0
  for(i in 1:x){res <- res + i}
  return(res)
}

# [문제 111] 인수값에 따라 합을 구하세요.
hap <- function(...){
  x <- list(...)
  res <- 0
  for(i in x){res <- res + i}
  return(res)
}
hap(1,2)
hap(1,2,3)
hap(10,20,30,40)
hap(1,3,5,1:100)

# [문제112] x변수에 1:5 까지 입력되어 있다 아래 화면 처럼 출력하세요.
x <- 1:5
result <- list()
#if
for(i in x){
  if(i%%2==0){result[i] <- '짝수'}else{result[i] <- '홀수'}
}

#ifelse
as.list(ifelse(x%%2==0, '짝수', '홀수'))


#lapply
checker <- function(x){
  if(x%%2==0){return('짝수')}else{return('홀수')}
}
result <- lapply(x, checker)

lapply(x, function(x){ifelse(x%%2==0, '짝수', '홀수')})

# [문제113] 사원 번호를 입력 값으로 받아서 사원의 LAST_NAME, SALARY를 출력하는 함수를 생성하세요.
# > find(100)
# LAST_NAME SALARY
# 10      King  24000
setwd('c:/data')
emp <- read.csv('emp_new.csv')
find <- function(id){emp[emp$EMPLOYEE_ID==id,c("LAST_NAME", "SALARY")]}
find(100)

# [문제114] 20번 부서에 소속되어 있는 사원들의 LAST_NAME, SALARY, JOB_ID, DEPARTMENT_NAME을 출력하세요
x <- merge(emp, dept, by='DEPARTMENT_ID')[, c('LAST_NAME', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID')]
x[x$DEPARTMENT_ID==20,]

merge(emp, dept, by='DEPARTMENT_ID')[merge(emp, dept, by='DEPARTMENT_ID')$DEPARTMENT_ID == 20, c('LAST_NAME', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID')]

merge(emp[emp$DEPARTMENT_ID==20,c("LAST_NAME","SALARY","JOB_ID","DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.last_name, e.salary, e.job_id, d.department_name from emp e, dept d where d.department_id = 20 and e.department_id = 20;

# [문제115] salary가 3000 이상이고 job_id는 ST_CLERK인 사원들의 employee_id, salary, job_id, department_id,department_name을 출력하세요.
x <- merge(emp, dept, by='DEPARTMENT_ID')[, c('EMPLOYEE_ID', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[emp$SALARY>=3000&emp$JOB_ID=='ST_CLERK',]

merge(emp, dept, by='DEPARTMENT_ID')[merge(emp, dept, by='DEPARTMENT_ID')$SALARY>=3000 & merge(emp, dept, by='DEPARTMENT_ID')$JOB_ID=='ST_CLERK', c('EMPLOYEE_ID', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]

merge(emp[emp$SALARY>=3000 & emp$JOB_ID=='ST_CLERK',c('EMPLOYEE_ID', 'SALARY', 'JOB_ID', 'DEPARTMENT_ID')], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.employee_id, e.salary, e.job_id, e.department_id, d.department_name from emp e, dept d where e.department_id = d.department_id and e.salary >= 3000 and e.job_id = 'ST_CLERK';


# [문제116]  커미션이 NA 인 사원들의 last_name, commission_pct, department_id, department_name을 출력하세요.
x <- merge(emp,dept, by='DEPARTMENT_ID')[, c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[is.na(x$COMMISSION_PCT),]

merge(emp,dept, by='DEPARTMENT_ID')[is.na(merge(emp,dept, by='DEPARTMENT_ID')$COMMISSION_PCT), c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]

merge(emp[is.na(emp$COMMISSION_PCT), c("LAST_NAME", "COMMISSION_PCT", "DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.last_name, e.commission_pct, e.department_id, d.department_name from emp e, dept d where e.department_id = d.department_id and e.commission_pct is null;

# [문제117]  커미션이 NA가 아닌 사원들의 last_name, commission_pct,department_id, department_name을 출력하세요.
x <- merge(emp,dept, by='DEPARTMENT_ID')[, c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[!is.na(x$COMMISSION_PCT),]

merge(emp,dept, by='DEPARTMENT_ID')[!is.na(merge(emp,dept, by='DEPARTMENT_ID')$COMMISSION_PCT), c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
merge(emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "COMMISSION_PCT", "DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID')
# select e.last_name, e.commission_pct, e.department_id, d.department_name from emp e, dept d where e.department_id = d.department_id and e.commission_pct is not null;

# [문제118]커미션이 NA가 아닌 사원들의 last_name, commission_pct, department_id, department_name을 출력하세요.
# 단 department_id가 NA인 사원도 출력해주세요.
x <- merge(emp,dept, by='DEPARTMENT_ID', all.x = T)[, c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]
x[!is.na(x$COMMISSION_PCT),]

merge(emp,dept, by='DEPARTMENT_ID', all.x = T)[!is.na(merge(emp,dept, by='DEPARTMENT_ID', all.x = T)$COMMISSION_PCT), c('LAST_NAME', 'COMMISSION_PCT', 'DEPARTMENT_ID', 'DEPARTMENT_NAME')]

merge(emp[!is.na(emp$COMMISSION_PCT), c("LAST_NAME", "COMMISSION_PCT", "DEPARTMENT_ID")], dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], by='DEPARTMENT_ID', all.x = T)
# select e.last_name, e.commission_pct, department_id, d.department_name from emp e left join dept d using(department_id) where e.commission_pct is not null;

# [문제119] 사원의 last_name, 관리자 last_name을 출력해주세요. 관리자가 없는 사원도 출력해주세요.
merge(data.frame(last_name=emp$LAST_NAME, mgr_id=emp$MANAGER_ID), data.frame(mgr_id = emp$EMPLOYEE_ID, mgr_name = emp$LAST_NAME), by='mgr_id', all.x = T)[, c('last_name', 'mgr_name')]
# select last_name, (select last_name from emp where employee_id = e.manager_id) as mgrname from emp e;

# [문제120] 부서이름별 총액 급여를 출력하세요.
#tapply
x <- merge(emp, dept, by='DEPARTMENT_ID')[,c('DEPARTMENT_NAME', 'SALARY')]
tapply(x$SALARY, x$DEPARTMENT_NAME, sum, default=0)
#aggregate
aggregate(SALARY~DEPARTMENT_NAME, merge(emp, dept, by='DEPARTMENT_ID')[,c('DEPARTMENT_NAME', 'SALARY')], sum)
# select d.department_name, sum(e.salary) from emp e, dept d where e.department_id = d.department_id group by d.department_name;

# [문제121] 부서이름별 소속사원들의 인원수를 출력하세요.
setwd('c:/data')
emp <- read.csv('emp_new.csv')
dept <- read.csv('dept.csv')
#aggregate
aggregate(EMPLOYEE_ID~DEPARTMENT_NAME, merge(emp,dept,by='DEPARTMENT_ID'),NROW)
#tapply
x <- merge(emp,dept,by='DEPARTMENT_ID')
tapply(x$EMPLOYEE_ID, x$DEPARTMENT_NAME, NROW)
#select d.department_name, count(e.employee_id) from employees e, departments d where e.department_id = d.department_id group by d.department_name;

# [문제122] 최고 급여를 받는 사원의 이름, 급여, 부서코드, 부서이름를 출력하세요.

x[merge(emp, dept, by='DEPARTMENT_ID')$SALARY==max(x$SALARY), c("LAST_NAME", "SALARY", "DEPARTMENT_ID", "DEPARTMENT_NAME")]
# select e.last_name, e.salary, e.department_id, d.department_name from employees e, departments d where e.department_id = d.department_id and e.salary = (select max(salary) from employees);

# [문제123] 부서이름,직업별 급여의 총액을 구하세요.
#aggregate
aggregate(SALARY~DEPARTMENT_NAME+JOB_ID, merge(emp,dept,by='DEPARTMENT_ID'),sum)
#tapply
x <- merge(emp,dept,by='DEPARTMENT_ID')
tapply(x$SALARY, data.frame(x$DEPARTMENT_NAME, x$JOB_ID), sum, default = 0)
# select d.department_name, e.job_id, sum(e.salary) from employees e, departments d where e.department_id = d.department_id group by d.department_name, e.job_id order by 1,2;

# [문제124] loc.csv 파일을 loc 변수로 로드하세요. Toronto 지역에 근무하는 사원들의 LAST_NAME,SALARY,DEPARTMENT_ID,DEPARTMENT_NAME,STREET_ADDRESS 정보를 출력하세요.
loc <- read.csv('loc.csv')
x <- merge(emp[,c("DEPARTMENT_ID","LAST_NAME", "SALARY")], dept[, c("DEPARTMENT_ID","DEPARTMENT_NAME","LOCATION_ID")], by='DEPARTMENT_ID')
y <- merge(x, loc[,c("LOCATION_ID", "STREET_ADDRESS", "CITY")], by='LOCATION_ID')
y[y$CITY=='Toronto', c("LAST_NAME", "SALARY", "DEPARTMENT_ID", "DEPARTMENT_NAME", "STREET_ADDRESS")]
# select e.last_name, e.salary, e.department_id, d.department_name, l.street_address from employees e, departments d, locations l where e.department_id = d.department_id and d.location_id = l.location_id and l.city = 'Toronto';
#효율적인 merge의 순서를 고려한 방법
x <- merge(dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME","LOCATION_ID")], loc[loc$CITY=='Toronto',c("LOCATION_ID","STREET_ADDRESS","CITY")],by='LOCATION_ID')
y <- merge(x[,c("DEPARTMENT_ID","DEPARTMENT_NAME","STREET_ADDRESS")], emp[,c("LAST_NAME", "SALARY","DEPARTMENT_ID")], by='DEPARTMENT_ID')

# [문제125] 아래 화면의 결과처럼 출력해주세요.
# 부서이름 부서별급여
# Administration       4400
# Marketing      19000
# Purchasing      24900
# Human Resources       6500
# Shipping     156400
# IT      28800
# Public Relations      10000
# Sales     304500
# Executive      63040
# Finance      51608
# Accounting      20308
# 소속부서X       7000
# 사원총급여     696456
#dataframe의 값을 수정하여 NA값 처리
dept <- read.csv('dept.csv', stringsAsFactors = F)
x <- merge(dept[,c("DEPARTMENT_ID","DEPARTMENT_NAME")], emp[,c("DEPARTMENT_ID","SALARY")], by='DEPARTMENT_ID', all.y = T)
x[is.na(x$DEPARTMENT_NAME), "DEPARTMENT_NAME"] <- '소속부서x'
x[,"DEPARTMENT_ID"] <- NULL
total <- data.frame(DEPARTMENT_NAME='사원총급여', SALARY=sum(x[,1]))
rbind(x, total)
#NA제외/NA값 각각의 dataframe을 만들어서 rbind
x <- aggregate(SALARY~DEPARTMENT_NAME, merge(emp,dept,by='DEPARTMENT_ID'),sum)
colnames(x) <- c('부서이름', '부서별급여')
y <- data.frame(부서이름='소속부서X',부서별급여=emp[is.na(emp$DEPARTMENT_ID),'SALARY'])
total <- data.frame(부서이름='사원총급여',부서별급여=sum(z[,2]))
result <- rbind(x,y,total)
result
# select nvl(d.department_name,'소속부서X'), sum(e.salary) from departments d, employees e where e.department_id = d.department_id(+) group by d.department_name
# union all
# select '사원총급여', sum(salary) from employees order by 1,2;

# [문제126] 30번 부서 사원이면서 급여는 3000이상 받는 사원들의 last_name, hire_date, salary, job_id, department_id 출력해주세요.
# 단 subset 함수를 이용하세요.
subset(emp, DEPARTMENT_ID == 30 & SALARY >= 3000, select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
# select last_name, hire_date, salary, job_id, department_id from emp where department_id = 30 and salary >= 3000;

# [문제127] 입사한 날짜가 2002,2003년도에 입사한 사원들의 last_name, hire_date, salary, job_id, department_id 출력해주세요.
# 단 subset 함수를 이용하세요.
subset(emp, substr(HIRE_DATE,1,4)%in%c('2002','2003'),select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
# select last_name, hire_date, salary, job_id, department_id from emp where substr(hire_date, 1, 4) in (2002, 2003);

# [문제128] 문제126번 결과하고 문제127결과를 하나로 합쳐 주세요.
x <- subset(emp, DEPARTMENT_ID == 30 & SALARY >= 3000, select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
y <- subset(emp, substr(HIRE_DATE,1,4)%in%c('2002','2003'),select=c(LAST_NAME, HIRE_DATE, SALARY, JOB_ID, DEPARTMENT_ID))
rbind(x,y)
merge(x,y,all=T)
# select last_name, hire_date, salary, job_id, department_id from emp where department_id = 30 and salary >= 3000
# union all
# select last_name, hire_date, salary, job_id, department_id from emp where substr(hire_date, 1, 4) in (2002, 2003);

# [문제129] 문제126번 결과하고 문제127결과 하나로 합치되 중복되는 데이터는 제거해주세요.
z <- rbind(x,y)
unique(z)

library(doBy)
orderBy(~LAST_NAME, unique(z))
# select last_name, hire_date, salary, job_id, department_id from emp where substr(hire_date, 1, 4) in (2002, 2003)
# union all
# select last_name, hire_date, salary, job_id, department_id from emp where department_id = 30 and salary >= 3000 and not exists(select * from emp where substr(hire_date, 1, 4) in (2002, 2003));

# [문제130] 150번 사원의 급여보다 더 많은 급여를 받는 사원들의 last_name, salary 를 출력하세요.
subset(emp, SALARY > emp[emp$EMPLOYEE_ID==150, "SALARY"], select=c(LAST_NAME, SALARY))
# select last_name, salary from emp where salary > (select salary from emp where employee_id = 150);

# [문제131] 사원 테이블에서 가장 많은 급여를 받는 사원의 이름과 월급을 출력하세요.
subset(emp, SALARY == max(SALARY), select=c(LAST_NAME, SALARY))
# select last_name, salary from emp where salary = (select max(salary) from emp);

# [문제132] job_id가  SA_REP인 사원의 최대급여 이상 받는 사원들의 last_name,salary,job_id를 출력하세요.
subset(emp, SALARY >= max(emp[emp$JOB_ID=='SA_REP', "SALARY"]), select=c(LAST_NAME, SALARY, JOB_ID))
# select last_name, salary, job_id from emp where salary >= (select max(salary) from emp where job_id = 'SA_REP');

# [문제133]  KING 에게 보고하는 사원들의 last_name, salary를 출력하세요.
subset(emp, MANAGER_ID %in% emp[emp$LAST_NAME=='King',"EMPLOYEE_ID"], select=c(LAST_NAME, SALARY))
# select last_name, salary from emp where manager_id in (select employee_id from emp where last_name = 'King');

# [문제134] 자신의 관리자 보다 더 많은 급여를 받는 사원이름, 사원급여, 관리자이름, 관리자급여를 출력하세요.
rm(list=ls())
setwd('c:/data')
emp <- read.csv('emp_new.csv', stringsAsFactors = F)
#sqldf
library(sqldf)
sqldf('select e.last_name, e.salary, m.last_name as mgrname, m.salary as mgrsal from emp e, (select employee_id, last_name, salary from emp) m  where m.employee_id = e.manager_id and e.salary > m.salary')

# [문제135] 자신의 부서 평균 급여보다 많이 받는 사원들의 정보를 출력하세요.
#sqldf
sqldf('select e.* from emp e, (select department_id, round(avg(salary)) as avgsal from emp group by department_id) d where e.department_id = d.department_id and e.salary > d.avgsal')
sqldf('select e.* from emp e where e.salary > (select round(avg(salary)) as avgsal from emp where department_id = e.department_id)')

# [문제136] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(tapply를 이용하세요)
# qty price
# apple   44 66000
# banana  31 70000
# berry   52 95100
# orange  21 83000
fs <- read.csv('fruits_sales.csv')
fs
#개별결과 생성
x <- tapply(fs$qty, fs$name, sum)
y <- tapply(fs$price, fs$name, sum)
#결과셋 만들기
#rbind
z <- rbind(x, y)
t(z)
#cbind
z <- cbind(qty=x,price=y)
z
#data.frame
z <- rbind(x, y)
data.frame(qty=z[1,], price=z[2,], row.names = colnames(z))

# [문제137] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(aggregate를 이용하세요)
# qty price
# apple   44 66000
# banana  31 70000
# berry   52 95100
# orange  21 83000
#개별결과생성
x <- aggregate(qty~name, fs, sum)
y <- aggregate(price~name, fs, sum)
#cbind
x <- cbind(x,y[2])
colnames(x)[1] <- ''

#merge
x <- merge(x,y)
colnames(x)[1] <- ''
x

# [문제138] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(sqldf를 이용하세요)
# qty price
# apple   44 66000
# banana  31 70000
# berry   52 95100
# orange  21 83000
sqldf('select name as " ", sum(qty) as qty, sum(price) as price from fs group by name')

# [문제139] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(tapply를 이용하세요)
x <- tapply(fs$qty, fs$year,sum)
names(x[x==max(x)])
rownames(x)[x==max(x)]

# [문제140] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(aggregate를 이용하세요)
x <- aggregate(qty~year, fs, sum)
x[x[2]==max(x[2]),'year']

# [문제141] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(sqldf를 이용하세요)
sqldf('with fr as (select year, sum(qty) as qsum from fs group by year) select year as bestYear from fr where qsum = ((select max(qsum) as sumax from fr))')

# [문제142] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.
# ddply함수를 이용하세요.
ddply(fs, 'name', summarise, netQty=sum(qty), netSales=sum(qty))

# [문제143] emp 데이터 프레임을 새로운 df 이름으로 복제하세요.
# df 데이터 프레임에  새로운 comm 컬럼을 생성하는데 COMMISSION_PCT 값을 기반으로 값을 입력하시고
# 결측값은 기존 COMMISSION_PCT의 평균 값으로 입력해주세요.(단 mutate함수를 이용하세요)
df <- emp
df <- mutate(df, comm=ifelse(is.na(COMMISSION_PCT), round(mean(COMMISSION_PCT, na.rm=T),2), COMMISSION_PCT))
head(df)

# [문제144] 부서별 급여의 총액을 pie chart를 생성하세요.
#tapply
x <- tapply(emp$SALARY, emp$DEPARTMENT_ID, sum)
pie(x, label=names(x), main='부서별 급여 총액')
pie(x, label=paste0(names(x),'번 부서 급여 총액 ', x), main='부서별 급여 총액')

#aggregate
x <- aggregate(SALARY~DEPARTMENT_ID, emp, sum)
pie(x[[2]], label=paste0(x[[1]], '번 부서', x[[2]], '만원'), main='부서별 급여 총액')

df <- aggregate(SALARY~DEPARTMENT_ID, emp, sum)
label1 <- paste(df$DEPARTMENT_ID, '부서', sep="")
label2 <- paste(df$SALARY, '만원', sep="")
pie(df$SALARY, labels=label2, main= '부서별 총액 급여', col=rainbow(length(df$SALARY)), radius=0.5)
legend(1,1,label1,fill=rainbow(length(df$SALARY)))

# [문제145] 성별 현황을 조사 자료를 이용하여 성별 인구 비율을 원형 차트로 만드세요.
# 성별 현황
# 구분	조사수
# ----	------
# 남자	226965
# 여자	241319
data <- c(226965, 241319)
name <- c('남자', '여자')
ratio <- paste0(round(data/sum(data)*100), '%')
clr <- c('blue', 'red')
#pie
pie(data, labels=ratio, main='성별 인구 현황', col=clr, radius=0.7)
legend(0.5,1.2,name,fill=clr, cex=0.8)

#pie3D
library(plotrix)
pie3D(data, labels=ratio, explode=0.1, labelcex=1.2, col=clr, main='성별 인구 현황', start=90, theta=1.1)
legend(0.4,1,name,fill=clr, cex=0.8)

legend('topright',name,fill=clr, cex=0.8)

p <- pie3D(data, labels=ratio, explode=0.1, labelcex=1.2, col=clr, main='성별 인구 현황', start=90, theta=1.1)
pie3D.labels(p, labels=name, labelrad=0.5, labelcex=1, labelcol='whitesmoke')

# [문제146] 성별 현황을 조사 자료를 이용하여 성별 인구수를 막대그래프로 만드세요.
# 성별 현황
# 구분	조사수
# ----	------
# 남자	226965
# 여자	241319
#barplot
bar <- barplot(height=data, width=0.5, names.arg=name, horiz=F, col=clr, xlab='성별', ylab='인구수(명)', ylim=c(0, 300000))
text(x=bar,y=data, labels=ratio, pos=3)

bar <- barplot(height=data, width=1, names.arg=name, horiz=F, col=clr, main='성별 인구 현황', xlab='성별', axes=F, ylim=c(0, 290000))
text(x=bar, y=data, labels=paste0(data, '명'), pos=3)

# [문제147] 부서별 인원수 막대그래프를 생성하세요. 단 부서없는 사원들의 인원수도 포함하세요.
setwd('c:/data')
emp <- read.csv('emp_new.csv')
#tapply
data <- tapply(emp$EMPLOYEE_ID,ifelse(is.na(emp$DEPARTMENT_ID), 'NA', emp$DEPARTMENT_ID), NROW)
name <- names(data)
bp <- barplot(height=data, width=0.5, names.arg=name, horiz=F, col=terrain.colors(length(data)), main='부서별 인원수', xlab='부서ID', ylab='인원수(명)', ylim=c(0, 50))
text(x=bp, y=data, labels=paste0(data, '명'), pos=3)

#aggregate
dept_cn <- aggregate(EMPLOYEE_ID~ifelse(is.na(DEPARTMENT_ID), '부서없음', DEPARTMENT_ID), emp, length)
names(dept_cn) <- c('dept_id', 'cn')
bp <- barplot(dept_cn$cn, names.arg=dept_cn$dept_id, main='부서별 인원수', xlab='부서', col=rainbow(length(dept_cn$dept_id)), cex.name=0.7, axes=F)
text(x=bp, y=dept_cn$cn, labels=paste0(dept_cn$cn, '명'),cex=0.9, pos=3)

#ddply
library(plyr)
x <- ddply(emp, 'DEPARTMENT_ID', summarise, cn=NROW(EMPLOYEE_ID))
data <- x$cn
name <- ifelse(is.na(x$DEPARTMENT_ID), 'NA', x$DEPARTMENT_ID)
bp <- barplot(height=data, width=0.5, names.arg=name, horiz=F, col=terrain.colors(length(data)), main='부서별 인원수', xlab='부서ID', ylab='인원수(명)', ylim=c(0, 50))
text(x=bp, y=data, labels=paste0(data, '명'), pos=3)

# [문제148] 부서 이름별 급여 총액에 대해서 막대그래프를 생성하세요.단 부서없는 사원들의 인원수도 포함하세요.
dept <- read.csv('dept.csv', stringsAsFactors=F)
# sqldf
library(sqldf)
raw <- sqldf('select d.department_name, sum(e.salary) as sumSal from emp e left join dept d on e.department_id=d.department_id group by d.department_name')
data <- raw$sumSal
name <- ifelse(is.na(raw$DEPARTMENT_NAME), 'NA', raw$DEPARTMENT_NAME)

# 그래프그리기
bp <- barplot(height=data, width=0.1, names.arg=name, cex.names=0.7, horiz=F, col=rainbow(length(data)), main='부서별 총액 급여', xlab='부서이름', ylab='총 급여($)', ylim=c(0,350000), las=2)
text(x=bp, y=data, labels=paste0(data, '$'), cex=0.7, pos=1, offset=0.1)

# 최고급여, 최저급여, 부서없음을 하나로 달기/서로 중첩되지 않는다면...
x <- c(rep('', length(name)))
x[which(data==max(data))] <- '최고급여'
x[which(data==min(data))] <- '최저급여'
x[which(is.na(raw$DEPARTMENT_NAME))] <- '부서없음'
text(x=bp, y=data, labels=x, cex=0.7, pos=3, col='red')

#최고급여 label을 별개로 달기
text(x=bp[data==max(data)], y=data[data==max(data)], labels='최고급여', cex=0.7, pos=3, col='red')

#최저급여 label을 별개로 달기
text(x=bp[data==min(data)], y=data[data==min(data)], labels='최저급여', cex=0.7, pos=3, col='red')

#부서없음 label을 별개로 달기
text(x=bp[is.na(raw$DEPARTMENT_NAME)], y=raw[is.na(raw$DEPARTMENT_NAME), 2], labels='부서없음', cex=0.7, pos=3, col='red')

# [문제149] fruits_sales.csv을 읽어 들인 후 년도별, 과일이름별 판매량을  그룹형 막대 그래프로 만드세요.
sales <- read.csv('fruits_sales.csv')

#orderBy
raw <- orderBy(~year+name, sales)[,1:3]

## 연도별 > 과일이름별
data <- matrix(raw$qty, ncol=4, byrow=T)
name <- unique(raw$year)
label <- unique(raw$name)
bp <- barplot(data, names.arg=name, main='연도별 과일 판매량', xlab='연도', ylab='판매량', legend.text=label, col=c('red', 'yellow', 'purple', 'orange'), ylim=c(0, 25),beside=T)
text(x=bp, y=data, labels=data, pos=3)

## 과일이름별 > 연도별
data <- matrix(raw$qty, ncol=4, byrow=F)
name <- unique(raw$name)
label <- unique(raw$year)
bp <- barplot(data, names.arg=name, main='과일별 연간 판매량', xlab='과일명', ylab='판매량', legend.text=label, col=topo.colors(length(name)), ylim=c(0, 25), beside=T)
text(x=bp, y=data, labels=data, pos=3)

# tapply
## 연도별 > 과일이름별
data <- tapply(sales$qty, list(sales$year, sales$name), sum)
name <- rownames(data)
label <- colnames(data)
bp <- barplot(data, names.arg=name, main='연도별 과일 판매량', xlab='연도', ylab='판매량', legend.text=label, col=c('red', 'yellow', 'purple', 'orange'), ylim=c(0, 25),beside=T)
text(x=bp, y=data, labels=data, pos=3)

## 과일이름별 > 연도별
data <- tapply(sales$qty, list(sales$name, sales$year), sum)
name <- rownames(data)
label <- colnames(data)
bp <- barplot(data, names.arg=name, main='과일별 연간 판매량', xlab='과일명', ylab='판매량', legend.text=label, col=topo.colors(length(name)), ylim=c(0, 25), beside=T)
text(x=bp, y=data, labels=data, pos=3)

bp <- barplot(data, names.arg=name, main='과일별 연간 판매량', xlab='과일명', ylab='판매량', col=topo.colors(length(name)), ylim=c(0, 25), beside=T)
legend('topright', title='과일', legend=label, pch=15, col=c('red', 'yellow', 'purple', 'orange'), cex=0.7)

library(plotrix)
#barlabels(x축, y축, 라벨값, cex=텍스트크기, prop=라벨위치)
barlabels(bp, data, data, cex=0.8, prop=1.04)
# boxed.labels(x축, y축, 라벨값, cex=텍스트크기, border=F(테두리 없앨시), srt=회전각도, bg=배경색)
boxed.labels(bp, data, data, cex=0.8, border=F, srt=0, bg=c('red','yellow','purple', 'orange'))

<!-- [문제150] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 SQL 점수를 막대그래프로 출력해주세요. --> 
setwd('c:/data')
exam <- read.csv('exam.csv', stringsAsFactors = F)
exam
sql <- exam[exam$subject=='SQL', c('name', 'grade')]
bp <- barplot(sql$grade, names.arg=sql$name, cex.names=0.7,main='SQL 시험점수', xlab='이름', ylab='점수', ylim=c(0,100), col=rainbow(length(sql$grade)))
text(x=bp, y=sql$grade, labels=sql$grade, pos=3)

<!-- [문제151] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 R 점수를 막대그래프로 출력해주세요. -->
r <- exam[exam$subject=='R', c('name', 'grade')]
barplot(r$grade, names.arg=r$name, cex.names=0.7, main='R 시험점수', xlab='이름', ylab='점수', ylim=c(0, 100), col=rainbow(length(r$name)))

<!-- [문제152] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 PYTHON 점수를 막대그래프로 출력해주세요. -->
python <- exam[exam$subject=='PYTHON', c('name', 'grade')]
barplot(python$grade, names.arg=python$name, main='PYTHON 시험점수', cex.names=0.7, xlab='이름', ylab='점수', ylim=c(0, 100), col=rainbow(length(python$name)))

<!-- [문제153] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 과목 총 점수를 막대그래프로 출력하세요. -->
total <- tapply(exam$grade, exam$subject, sum)
barplot(total, names.arg=names(total), main='과목별 시험점수', xlab='과목명', ylab='점수', ylim=c(0, 700), col=rainbow(length(total)))

<!-- [문제154] 학생들의 이름을 기준으로 과목점수를 스택형 막대그래프로 생성하세요. -->
library(doBy)
library(plotrix)
data <- orderBy(~name, exam)
data
score <- matrix(data$grade, nrow=3)
name <- data$name[seq(1, length(data$name), 3)]
bp <- barplot(score, names.arg=name, cex.names=0.7, main='과목별 점수', xlab='이름', ylab='점수', ylim=c(0, 300), beside=F, col=c('gray', 'blue', 'red'), border=F)
legend('topright',data$subject[1:3], cex=0.7, fill=c('gray', 'blue', 'red'), pch=15, pt.cex=0.5)
text(x=bp, y=colSums(score), labels=paste0(colSums(score), '점'),cex=0.8, pos=3)
boxed.labels(x=bp, y=colSums(score)-(score[3,]/2), labels=paste0(score[3,], '점'),cex=0.7, border=F)
boxed.labels(x=bp, y=colSums(score[1:2,])-(score[2,]/2), labels=paste0(score[2,], '점'),cex=0.7, border=F)
boxed.labels(x=bp, y=score[1,]-(score[1,]/2), labels=paste0(score[1,], '점'),cex=0.7, border=F)
 
# tapply로 데이터 처리
t <- tapply(exam$grade, list(exam$subject, exam$name), sum)
bp <- barplot(t, names.arg=names(t), ylim=c(0,350),
        xlab='이름', ylab='성적',col=c('blue','green','purple'),
        main='과목별 점수',las=2)
legend('topright',legend=rownames(t), title='과목', pch=15,
       col=c('blue','green','purple'),
       cex=0.9, pt.cex=1)
# 기준선 긋기
abline(h=seq(100,300,100),col='red',lty=2)
library(plotrix)
barlabels(bp,t,bg=c('blue','green','purple'),border=c('blue','green','purple'))
total<-apply(t,2,sum)
text(bp,y=total*1.1,labels=paste(total,'점',sep=""))

<!-- [문제155] 학생들의 이름을 기준으로 과목점수를 그룹형 막대그래프로 생성하세요. -->
data <- orderBy(~name, exam)
data
score <- matrix(data$grade, nrow=3)
name <- data$name[seq(1, length(data$name), 3)]
bp <- barplot(score, names.arg=name, cex.names=0.7, main='과목별 점수', xlab='이름', ylab='점수', ylim=c(0, 110), beside=T, col=c('gray', 'blue', 'red'), border=F)
legend('topright',data$subject[1:3], cex=0.7, fill=c('gray', 'blue', 'red'))
text(bp, score, labels=score, cex=0.6, pos=3)

<!-- [문제156] 창업건수.csv 파일에 데이터 중에 년도별 치킨집 창업 건수를 막대그래프로 생성하세요. -->
data <- read.csv('창업건수.csv')
data
bp <- barplot(data$치킨집, names.arg=data$년도, main='연도별 치킨집 창업 건수', xlab='연도', ylab='창업건수', ylim=c(0, 1200), col=rev(heat.colors(length(data$년도))))
barlabels(bp, data$치킨집, data$치킨집, cex=0.9, border=rev(heat.colors(length(data$년도))), bg=rev(heat.colors(length(data$년도))))

<!-- [문제157] 년도별 치킨집 창업, 폐업 건수를 그룹형 막대그래프로 생성하세요. -->
open <- read.csv('창업건수.csv')
close <- read.csv('폐업건수.csv')
chicken <- rbind(open$치킨집, close$치킨집)
bp <- barplot(chicken, names.arg=open$년도, main='연도별 치킨집 창업/폐업 현황', xlab='연도', ylab='건수', ylim=c(0, 3600), col=c('red', 'blue'), beside=T, legend.text=c('창업', '폐업'))
text(bp-0.1, chicken/2, labels=chicken, cex=1, srt=90, col='white')

<!-- [문제158] 2014 년도 업종별 창업 비율을 원형 그래프로 생성하세요. -->
x <- unlist(open[open$년도==2014, -1])
pie(x, labels=paste0(names(x),' ', round(x/sum(x)*100),'%'), main='2014년 업종별 창업 비율', col=rainbow(length(x)), border='whitesmoke')
  
x <- unlist(open[open$년도==2014, -1])
pie3D(x, labels=paste0(names(x),'\n', round(x/sum(x)*100),'%'), explode=0.15, labelcex=0.7, theta=1, main='2014년 업종별 창업 비율', col=rainbow(length(x)), border='snow3')

<!-- [문제159] 년도를 입력하면 해당 년도의 원형 그래프 생성할 수 있는 함수를 생성하세요. -->
<!-- show_pie(2006) -->
show_pie <- function(year){
  open <- read.csv('창업건수.csv')
  x <- unlist(open[open$년도==year, -1])
  pie(x, labels=paste0(names(x),' ', round(x/sum(x)*100),'%'), main=paste0(year, '년 업종별 창업 비율'), col=rainbow(length(x)), border='whitesmoke')
}

show_pie(2006)
  
show_pie3D <- function(year){
  open <- read.csv('창업건수.csv')
  x <- unlist(open[open$년도==year, -1])
  pie3D(x, labels=paste0(names(x),'\n', round(x/sum(x)*100),'%'), explode=0.15, labelcex=0.7, theta=1, main=paste0(year,'년 업종별 창업 비율'), col=rainbow(length(x)), border='snow3')
}

show_pie3D(2006)

<!-- [문제160] 한 주간 영업 판매량을 막대그래프를 생성하데 막대그래프의 색상은 판매량에 따라 다르게 해야 합니다. -->
<!-- 판매량이 200 이상이면 red, 199 ~ 150 이면 yellow, 149 ~ 100 이면 blue, 99 ~ 50 pink, 49 ~ black색으로 출력하세요. -->
<!-- 월요일 : 70 -->
<!-- 화요일 : 151 -->
<!-- 수요일 : 210 -->
<!-- 목요일 : 180 -->
<!-- 금요일 : 250 -->
<!-- 토요일 : 300 -->
<!-- 일요일 : 40 -->
  
pickCol <- function(num){
  col <- NULL
  for(i in num){
    x <- i%/%50
    if(x >= 4){col <- c(col, 'red')}
    else if(x == 3){col <- c(col, 'yellow')}
    else if(x == 2){col <- c(col, 'blue')}
    else if(x == 1){col <- c(col, 'pink')}
    else {col <- c(col, 'black')}  
  }
  return(col)
}

sell <- c(월요일=70, 화요일=151, 수요일=210, 목요일=180, 금요일=250, 토요일=300, 일요일=40)
barplot(sell, width=0.2,names.arg=names(sell), col=pickCol(sell), main='주간 영업 판매량', xlab='요일', ylab='판매량', ylim=c(0, 350))

<!-- [문제161] itwill hotel 투수객 조사를 통해 고객들의 평가에 대한 정보는  survey.csv에 저장 되어 있습니다. -->
<!-- 파일 내용을 통해서 호텔에 대한 고객들의 반응을 그래프로 생성하세요. -->
  
survey <- read.csv('survey.csv', stringsAsFactors = F, header=F)
# result 만들기 by for
fac <- unique(t(survey))
result <- c()
for(i in fac){
  result[i] <- 0
}
for(i in survey){
  result[i] <- result[i] + 1
}
 

  
# result 만들기 by str_count
library(stringr)
result <- c('매우좋음'=sum(str_count(survey, '매우좋음')), '좋음'=sum(str_count(survey, '좋음')), '보통'=sum(str_count(survey, '보통')), '나쁨'=sum(str_count(survey, '나쁨')), '매우나쁨'=sum(str_count(survey, '매우나쁨')))
result

 

  
# barplot
bp <- barplot(result, names.arg = names(result), main='ITWILL HOTEL 투숙객 서베이 결과', xlab='반응', ylab='응답수', ylim=c(0, 11), col=rev(heat.colors(length(result))), border='grey70')
text(bp, result, labels=result, pos=3)
 
  
# pie
pie(result, labels= paste0(names(result),' ',result,'명'), main='ITWILL HOTEL 투숙객 서베이 결과', col=rev(heat.colors(length(result))), border='firebrick')
 

  
# pie3D
pie3D(result, labels= paste0(names(result),' ',result,'명'), labelcex=0.9, main='ITWILL HOTEL 투숙객 서베이 결과', explode=0.1, theta=1.1, col=rev(heat.colors(length(result))), border='tomato')

 

  
# factor 활용하기
s <- t(survey)
u <- unique(s)
u <- factor(u, levels=unlist(u))
result <- data.frame(eval=sort(u), cn=0)
for(i in s){
  result[result$eval==i, 'cn'] <- result[result$eval==i, 'cn']+1
}
result

[문제162] itwill hotel 투수객 조사를 통해 고객들의 평가에 대한 정보는  survey.csv에 저장 되어 있습니다.
파일 내용을 통해서 호텔에 대한 고객들의 반응을 그래프로 생성하세요.(table함수를 이용해서 해결해주세요)
hotel <- read.csv('survey.csv', header=F, stringsAsFactors = F)
data <- table(t(factor(hotel, levels = c('매우좋음', '좋음', '보통', '나쁨', '매우나쁨'))))
ratio <- prop.table(data)*100
# barplot
bp <- barplot(data, names.arg=names(data),main='ITWILL HOTEL 고객 평가', xlab='평가', ylab='명수', ylim=c(0, 10), col=heat.colors(length(data)))
text(bp, data, labels = paste0(data,'명','\n',ratio, '%'))
# pie
pie(data, labels=paste0(names(data),'\n',data,'명(', ratio, '%)'), main='ITWILL HOTEL 고객 평가', col=heat.colors(length(data)))
# pie3D
library(plotrix)
pie3D(data, labels=paste0(names(data),'\n',data,'명(', ratio, '%)'), labelcex=1.1, explode=0.15, theta=1, main='ITWILL HOTEL 고객 평가', col=heat.colors(length(data)))


[문제163] 1군전염병발병현환_년도별.csv 에 데이터를 가지고 그래프를 생성하세요.
raw <- read.csv('1군전염병발병현황_년도별.csv', header=T)
epidemic <- raw[,-1]
# plot
for(i in c(1:length(epidemic))){
  if(i==1){plot(x=epidemic[,1], ylim=c(0, max(epidemic)*1.1), xlab='', ylab='발병건수', axes=F, col=rainbow(length(raw))[1], type='o', lwd=1, main='연도별 1군전염병 발병현황(단위: 건, 출처: 통계청)')}
  else{lines(epidemic[,i], col=rainbow(length(raw))[i], type='o', lwd=1)}
}
abline(h=seq(0, 6000, 250), v=seq(1, 11, 1), lty=3, lwd=0.2)
axis(1, at=1:11, labels=raw$년도별, las=2)
legend(x=1, y=5500, legend=names(raw[-1]), cex=0.8, col=rainbow(length(raw)), lty=1, lwd=1, pch=1)

# barplot
barplot(t(as.matrix(epidemic)), names.arg=raw$년도별, col=rainbow(length(epidemic)), main='연도별 1군전염병 발병현황(단위:건, 출처: 통계청)', xlab='', ylab='건수', ylim=c(0, max(epidemic)*1.1), beside=T, las=2)
legend('topleft', names(epidemic), fill=rainbow(length(raw)),cex=0.7)

[문제164] 조사된 데이터 값들이 있습니다. 도수분포표를 만드세요.
90 88 78 65 80 94 69 72 83 64 95 68 87 69 82 91 63 70 81 67 
              계급 도수
           90점이상    4
  80점이상~90점미만    6
  70점이상~80점미만    3
  60점이상~70점미만    7

input <- '90 88 78 65 80 94 69 72 83 64 95 68 87 69 82 91 63 70 81 67'
score <- as.integer(unlist(strsplit(input, split=' ')))
result <- data.frame(계급=c('90점이상', '80점 이상~90점 미만', '70점 이상~80점 미만', '60점 이상~70점 미만', '전체'), 도수=0, 상대도수=0, 누적도수=0)
for(i in score){
  checker <- i%/%10
  if(checker>=9){result[1,2] <- result[1,2]+1}
  else if(checker==8){result[2,2] <- result[2,2]+1}
  else if(checker==7){result[3,2] <- result[3,2]+1}
  else if(checker==6){result[4,2] <- result[4,2]+1}
}
result$상대도수 <- result$도수/sum(result$도수)
sums <- 0
for(i in 1:length(result)){
  sums <- sums+result$도수[i]
  result$누적도수[i] <- sums
}

for(i in 2:length(result)){
  result[5,i] <- sum(result[,i])
}
result

[문제165] itwill 자동차 수리점 부품 비용 자료 입니다. 분석하세요.
91 78 93 57 75 52 99 80 97 62
71 69 72 89 66 75 79 75 72 76
104 74 62 68 97 105 77 65 80 109
85 97 88 68 83 68 71 69 67 74
62 82 98 101 79 105 79 69 62 73

# cost <- scan()
data <- '91 78 93 57 75 52 99 80 97 62 71 69 72 89 66 75 79 75 72 76 104 74 62 68 97 105 77 65 80 109 85 97 88 68 83 68 71 69 67 74 62 82 98 101 79 105 79 69 62 73'
cost <- as.numeric(unlist(strsplit(data, split=' ')))
step <- ceiling((max(cost)-min(cost))/round(length(cost)^(1/3)))
lvl <- (bMax-bMin)/step
bMin <- (min(cost)%/%step)*step
bMax <- ((max(cost)%/%step)+1)*step
freq <- table(cut(cost, breaks=seq(bMin, bMax, step), right=F))
names(freq) <- c('45~60', '60~75', '75~90', '90~105', '105~120')
hist(cost, breaks=seq(bMin, bMax, step), right=F, main=paste0('ITWILL 자동차 수리점','\n','부품 비용 현황'), axes=F, xlab='부품비용', ylab='갯수',ylim=c(0,max(freq)*1.25), col=rev(heat.colors(lvl)))
axis(1, at=seq(bMin, bMax, step), labels=seq(bMin, bMax, step), las=2)
axis(2, at=seq(0, max(freq)*1.25, (max(freq)*1.25)/5), labels=seq(0, max(freq)*1.25, (max(freq)*1.25)/5), las=2)

# pie
pie(freq, labels=paste0('가격: ',names(freq),'\n','재고비율: ',prop.table(freq)*100,'%'), main=paste0('ITWILL 자동차 수리점','\n','부품 비용 현황'), col=rev(heat.colors(lvl)))

#pie3D
library(plotrix)
pie3D(freq, labels=paste0('가격: ',names(freq),'\n','재고비율: ',prop.table(freq)*100,'%'), labelcex=1, explode=0.1, theta=1, main=paste0('ITWILL 자동차 수리점','\n','부품 비용 현황'), col=rev(heat.colors(lvl)))
```


hist(cost, breaks=seq(bMin, bMax, step), right=F, main=paste0('ITWILL 자동차 수리점','\n','부품 비용 현황'), axes=F, xlab='부품비용', ylab='갯수',ylim=c(0,max(freq)*1.25), col=rev(heat.colors(lvl)), labels=T)
par(new=T) #그래프 겹치기
plot(density(cost), type='l', col='darkblue', lwd=2, axes=F, xlab='', ylab='', main='')


[문제166] 학생들의 몸무게 자료를 이용해서 도수분포표,그래프를 생성하세요.
weight <- read.table("c:/data/weight.txt")

weight <- unlist(read.table("weight.txt", header = F))
step <- 5
bMin <- (min(weight)%/%step)*step
bMax <- ((max(weight)%/%step)+1)*step
lvl <- (bMax-bMin)/step
freq <- table(cut(weight, breaks=seq(bMin, bMax, step), right=F))
floors <- seq(bMin, bMax, step)
name <- c()
for(i in floors){
  if(i==max(floors)){NULL}
  else{
    floor <- paste0(i,'이상~',i+5,'미만')
    name <- append(name, floor, after=length(name))
  }
    
}

table(cut(weight, breaks = floors, right=F, labels = name))

hist(weight, breaks=floors, right=F, main='몸무게 현황', axes=F, xlab='몸무게(Kg)', ylab='명', ylim=c(0, (round(max(freq)/10)*10)+5), col=rev(heat.colors(lvl)), labels=T)
axis(1, at=floors, labels=floors, col=rev(heat.colors(lvl)), las=1, cex.axis=0.7)
axis(2, at=seq(0, (round(max(freq)/10)*10)+5, 5), labels=seq(0, (round(max(freq)/10)*10)+5, 5))
par(new=T)
plot(density(unlist(weight)), type='l', col='darkblue', lwd=2, axes=F, xlab='', ylab='', main='')

[문제167] 2016년_서울_주요구별_병원현황.csv file을 읽어 들인후 구별로 진료과목별 병원현황을 그룹막대형 그래프로 만드세요.
raw <- read.csv('2016년_서울_주요구별_병원현황.csv', header=T, stringsAsFactors=F)
sh <- as.matrix(raw[,-1])
name <- raw[,1]
rc <- rainbow(length(name))
# barplot
barplot(sh, cex.axis=0.7, names.arg=names(sh), cex.names=0.7, main='2016년 서울 주요구별 병원현황', xlab='구 이름', ylab='갯수', ylim=c(0, max(sh)*1.2), col=rc, border='lightblue1', beside=T, las=1) 
abline(h=seq(0, 350, 50), v=seq(0, max(sh), 10), lty=3, lwd=0.1)
legend('topright', name, fill=rc, cex=0.8, border='lightblue1')

[문제168] 강남구 과목별 병원수만 막대형 그래프를 생성하세요.(단 10개 1개로 표현하세요.)
raw
gn <- matrix(raw[, names(raw)=='강남구'], ncol=1)%/%10
name <- raw[,1]
bp <- barplot(gn, cex.axis=0.7, names.arg=name, cex.names=0.7, main='2016년 강남구 병원현황', ylab='갯수 (단위:10)', ylim=c(0, max(gn)*1.2), col=rainbow(length(name)), border='lightblue1', beside=T, las=2)
text(bp, gn, labels=raw$강남구, pos=1, cex=0.7, offset=0.2)

[문제169] 2016년_서울_주요구별_병원현황.csv file을 읽어 들인후 구별 진료과목에 해당하는 병원수를 막대형 그래프로 만드세요. 단 막대높이는 10개당 1개로 만드시고 막대그래프 프로그램은 한개를 가지고 모든 구별 막대그래프가 생성되도록 만드세요.
raw
db <- as.matrix(raw[,-1])
name <- raw[,1]
par(mfrow=c(2,5)) 
# stacked bar chart
for(i in 1:ncol(db)){
  data <- as.matrix(db[,i]%/%10, ncol=1)
  bp <- barplot(data, cex.axis=0.7, names.arg=name, cex.names=0.5, main=paste0(names(raw[,-1])[i],' 병원현황'), ylab='갯수 (단위:10)', ylim=c(0, max(data)*1.2), col=rainbow(length(name)), border='lightblue1', beside=T, las=2)
  text(bp, data, labels=db[,i], pos=3, cex=0.7)
}

# bar chart
par(mfrow=c(2,5))
for(i in 1:ncol(db)){
  data <- db[,i]%/%10
  bp <- barplot(data, cex.axis=0.7, names.arg=name, cex.names=0.7, main=paste0(names(raw[,-1])[i],' 병원현황'), ylab='갯수 (단위:10)', ylim=c(0, max(data)*1.2), col=rainbow(ncol(db)), border='lightblue1', las=2)
  text(bp, data, labels=db[,i], pos=3, cex=0.7)
}

[문제 170] 모기업의 영업팀은 'A팀', 'B팀', 'C팀', 'D팀', 'E팀'이 있다. 영업팀별 영업 매출액은 90, 45, 70, 67, 85 이다. 이 자료를 이용해서 barplot, pie, pie3D 그래프를 그리시오.
data <- c(90, 45, 70, 67, 85)
names(data) <- c('A팀', 'B팀', 'C팀', 'D팀', 'E팀')
library(plotrix)
# barplot
mycol=rainbow(length(data))
bp <- barplot(data, names.arg=names(data), main='영업팀별 매출액 현황', xlab='팀명', ylab='매출', ylim=c(0, max(data)*1.2), col=mycol, border=F)
boxed.labels(bp, data/2, labels=data, col=mycol, border=mycol, bg='white', cex=2)

# pie
ratio <- round((data/sum(data))*100)
pie(data, labels=paste0(names(data),'\n',data,'(',ratio,'%)'), main='영업팀별 매출액 현황', col=mycol, border='gold')

# pie3D
pie3D(data, explode=0.13, theta=0.8, labels=paste0(names(data),'\n',data,'(',ratio,'%)'), main='영업팀별 매출액 현황', col=mycol, border='gold')

install.packages('jpeg')
library(jpeg)

# 그림으로 저장
jpeg('ex170_1.jpg', width=400, height=300, pointsize=12)

# barplot
mycol=rainbow(length(data))
bp <- barplot(data, names.arg=names(data), main='영업팀별 매출액 현황', xlab='팀명', ylab='매출', ylim=c(0, max(data)*1.2), col=mycol, border=F)
boxed.labels(bp, data/2, labels=data, col=mycol, border=mycol, bg='white', cex=2)

jpeg('ex170_2.jpg', width=400, height=300, pointsize=12)
# pie
ratio <- round((data/sum(data))*100)
pie(data, labels=paste0(names(data),'\n',data,'(',ratio,'%)'), main='영업팀별 매출액 현황', col=mycol, border='gold')

jpeg('ex170_3.jpg', width=400, height=300, pointsize=12)
# pie3D
pie3D(data, explode=0.13, theta=0.8, labels=paste0(names(data),'\n',data,'(',ratio,'%)'), main='영업팀별 매출액 현황', col=mycol, border='gold')

library(jpeg)
library(animation)
for(i in 1:3){
  img <- paste0('ex170_',i,'.jpg')
  img <- readJPEG(img)
  plot.new()
  rect(0, 0, 1, 1, col='white', border='white')
  rasterImage(img, 0,0,1,1)
  ani.pause()
}


[문제171] 문제169번을 수행하면서 구이름.jpg형식으로 파일이 생성하도록 한 후 구이름.jpg를 이용해서 애니메이션을 수행하세요.
raw <- read.csv('2016년_서울_주요구별_병원현황.csv', header=T, stringsAsFactors=F)
data <- as.matrix(raw[,-1])
name <- raw[,1]

for(i in 1:ncol(data)){
  jpeg(paste0('data/hospital_',i,'.jpg'), width=400, height=300, pointsize=12)
  subData <- data[,i]%/%10
  bp <- barplot(subData, cex.axis=0.7, names.arg=name, cex.names=0.5, main=paste0(colnames(data)[i],' 병원현황'), ylab='갯수 (단위:10)', ylim=c(0, max(data)*0.12), col=rainbow(length(name)), border='lightblue1', las=2)
  text(bp, subData, labels=subData, pos=3, cex=0.7)
  dev.off()
}

for(i in 1:ncol(data)){
  img <- paste0('C:/Users/stu/git/DA_Academy/data/hospital_',i,'.jpg')
  img <- readJPEG(img)
  plot.new()
  rect(0, 0, 1, 1, col='white', border='white')
  rasterImage(img, 0,0,1,1)
  ani.pause()
}

[문제172] R에서 오라클 접속한 후 부서별 인원수에 대한 막대그래프 그리세요.
library(RJDBC)
jdbcDriver <- JDBC(driverClass = 'oracle.jdbc.OracleDriver', classPath = 'C:/data/ojdbc6.jar')
conn <- dbConnect(jdbcDriver, 'jdbc:oracle:thin:@localhost:1521/xe', 'hr', 'hr')
result <- dbGetQuery(conn, 'select department_id, count(*) from employees group by department_id order by 2 desc')

deptN <- result[,2]
name <- result[,1]
top <- max(deptN)*1.2

bp <- barplot(deptN, names.arg = ifelse(is.na(name), 'NA', name), col=rainbow(NROW(result)), main='부서별 인원수 현황', xlab='부서ID', ylab='인원수(명)', ylim=c(0, top), border='gray70')
text(bp, deptN, labels = deptN, pos=3, cex=0.7)
abline(h=seq(0, top, 5), lty=3, col='gray50')

library(RJDBC)
jdbcDriver <- JDBC(driverClass = 'oracle.jdbc.OracleDriver', classPath = 'C:/data/ojdbc6.jar')
conn <- dbConnect(jdbcDriver, 'jdbc:oracle:thin:@localhost:1521/xe', 'hr', 'hr')
emp <- dbGetQuery(conn, 'select * from employees')
result <- sort(table(emp[,c("DEPARTMENT_ID")], useNA = 'always'), decreasing = T)

bp <- barplot(result, names.arg=ifelse(is.na(names(result)), 'NA', names(result)), col=rainbow(length(result)), main='부서별 인원수 현황', xlab='부서ID', ylab='인원수(명)', ylim=c(0, max(result)*1.2), border='gray70')
text(bp, deptN, labels = deptN, pos=3, cex=0.7)
abline(h=seq(0, top, 5), lty=3, col='gray50')
```

[문제173] 아래와 같은 결과를 출력하도록 SQL문을 작성하세요.
Job                     Dept 10    Dept 20    Dept 30    Dept 40    Dept 50    Dept 60    Dept 70    Dept 80    Dept 90   Dept 100
-------------------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------
AC_MGR
AC_ACCOUNT
IT_PROG                                                                          28800
ST_MAN                                                                36400
AD_ASST                       0
PU_MAN                                          11000
SH_CLERK                                                              64300
AD_VP                                                                                                     35700
FI_ACCOUNT                                                                                                           39600
MK_MAN                               13000
PR_REP                                                                                      10000
FI_MGR                                                                                                               12008
PU_CLERK                                        13900
SA_MAN                                                                                                 61000
MK_REP                                6000
AD_PRES                                                                                                   26400
SA_REP                                                                                                243500
HR_REP                                                      6500
ST_CLERK                                                              55700

dbGetQuery(conn, 'select job_id as "Job", (select sum(salary) from employees where department_id=10 and job_id=e.job_id) as "Dept 10", (select sum(salary) from employees where department_id=20 and job_id=e.job_id) as "Dept 20", (select sum(salary) from employees where department_id=30 and job_id=e.job_id) as "Dept 30", (select sum(salary) from employees where department_id=40 and job_id=e.job_id) as "Dept 40", (select sum(salary) from employees where department_id=50 and job_id=e.job_id) as "Dept 50", (select sum(salary) from employees where department_id=60 and job_id=e.job_id) as "Dept 60",(select sum(salary) from employees where department_id=70 and job_id=e.job_id) as "Dept 70",(select sum(salary) from employees where department_id=80 and job_id=e.job_id) as "Dept 80",(select sum(salary) from employees where department_id=90 and job_id=e.job_id) as "Dept 90",(select sum(salary) from employees where department_id=100 and job_id=e.job_id) as "Dept 100" from employees e group by job_id')


# decode 활용
dbGetQuery(conn, 'SELECT job_id "Job",
SUM(DECODE(department_id , 10, salary)) "Dept 10",
SUM(DECODE(department_id , 20, salary)) "Dept 20",
SUM(DECODE(department_id , 30, salary)) "Dept 30",
SUM(DECODE(department_id , 40, salary)) "Dept 40",
SUM(DECODE(department_id , 50, salary)) "Dept 50",
SUM(DECODE(department_id , 60, salary)) "Dept 60",
SUM(DECODE(department_id , 70, salary)) "Dept 70",
SUM(DECODE(department_id , 80, salary)) "Dept 80",
SUM(DECODE(department_id , 90, salary)) "Dept 90",
SUM(DECODE(department_id , 100, salary)) "Dept 100"
FROM employees
GROUP BY job_id')

# pivot활용
dbGetQuery(conn,'SELECT *
FROM   (SELECT department_id, job_id, salary
              FROM   employees)
PIVOT (SUM(salary)  FOR department_id  IN  (10,20,30,40,50,60,70,80,90,100,110))')

# pivot활용 / department_id가 na인 row도 포함
dbGetQuery(conn,'SELECT *
FROM   (SELECT nvl(department_id,0) dept_id, job_id, salary
              FROM   employees)
 PIVOT (SUM(salary)  FOR dept_id  IN  (10,20,30,40,50,60,70,80,90,100,110,0))')


[문제175] R에서 오라클에 있는 employees 테이블을 읽어들인 후 R함수를 이용하셔서 문제 173번과 동일한 결과를 출력하세요.
emp <- dbGetQuery(conn, 'select * from employees')
emp <- dbReadTable(conn, 'EMPLOYEES')
result <- emp[!is.na(emp$DEPARTMENT_ID),]
tapply(result$SALARY, list(result$JOB_ID, result$DEPARTMENT_ID), sum, default=0)


[문제176] 부서 인원수를 ggplot를 이용해서 막대그래프를 출력하세요.
deptMember <- data.frame(table(emp$DEPARTMENT_ID))
names(deptMember) <- c('DeptId', 'Member')
deptMember

ggplot(data=deptMember, aes(x=DeptId, y=Member))+geom_bar(stat='identity', fill=rainbow(NROW(deptMember)))+geom_text(aes(y=Member, label=paste(Member,'명')), col='black', size=4, position=position_nudge(y = 1.5))+theme(axis.text.x = element_text(angle=25, hjust=1, vjust=1, colour='blue', size=10))


emp <- dbGetQuery(conn, "select nvl(department_id,0) dept_id, count(*) cn from employees group by nvl(department_id,0) order by cn desc")
emp

ggplot(emp, aes(x=factor(DEPT_ID),y=CN))+
  geom_bar(stat="identity", fill= rainbow(12))+
  geom_text(aes(label=CN),vjust=-0.1,size=5)+
  labs(title='부서별 인원 현황', x='부서번호', y='인원수(명)')+
  theme(plot.title=element_text(face='bold', color='darkblue', hjust=0.5))+
  theme(axis.title.x=element_text(face='bold.italic', color='brown',size=6))+
  theme(axis.title.y=element_text(face='bold.italic', color='brown'))

[문제177] 년도별 입사한 수를 ggplot를 이용해서 막대그래프를 출력하세요.
result <- table(substr(emp$HIRE_DATE,1,4))
result <- tapply(emp$EMPLOYEE_ID, substr(emp$HIRE_DATE,1,4), NROW)
hireYear <- data.frame(year=names(result), cn=result)
hireYear

ggplot(data=hireYear, aes(x=year, y=cn))+geom_bar(stat='identity', fill=rainbow(NROW(hireYear)))+geom_text(aes(y=cn, label=paste(cn,'명')), col='black', size=4, position=position_nudge(y = 1.5))+theme(axis.text.x = element_text(angle=25, hjust=1, vjust=1, colour='gray1', size=10))


library(RJDBC)
library(ggplot2)
library(lubridate)
library(plyr)


emp <- dbGetQuery(conn, "select * from employees")

ggplot(emp,aes(x=year(HIRE_DATE)))+
  geom_bar()

ggplot(emp, aes(x=factor(year(HIRE_DATE)), fill=factor(year(HIRE_DATE))))+
  geom_bar()+
  labs(title = "년도별 입사현황", x="년도", y="인원수", fill="년도")+
  theme(plot.title=element_text(face='bold', color='darkblue', hjust=0.5))+
  theme(axis.title.x=element_text(face='bold', color='darkblue'))+
  theme(axis.title.y=element_text(face='bold', color='darkblue'))+
  theme(legend.title.align=0.5, legend.box.background = element_rect(),
        legend.box.margin = margin(t=0.1,r=0.1, b=0.1, l=0.1,unit='cm'))

count(emp,"year(HIRE_DATE)")
year_cn <- count(emp,"year(HIRE_DATE)")
colnames(year_cn) <- c("year","cn")
year_cn

ggplot(year_cn,aes(x=year,y=cn,fill=factor(year)))+
  geom_bar(stat="identity")+
  geom_text(aes(label=cn))+
  ggtitle("년도별 입사현황",subtitle="신입사원")+
  theme(plot.title = element_text(lineheight=.8, face="bold",color="darkblue",hjust=0.5))+
  theme(plot.subtitle = element_text(lineheight=.8, face="bold",color="darkblue",hjust=0.5))+
  labs(caption = "2001년 ~ 2008년")+
  labs(x="년도",y="인원수")+
  guides(fill=guide_legend(title="년도"))+
  theme(legend.title.align=0.5, legend.box.background = element_rect(),
      legend.box.margin = margin(t=0.1,r=0.1, b=0.1, l=0.1,unit='cm'))

hire_cn <- dbGetQuery(conn, "select to_char(hire_date,'yyyy') year,count(*) cn from employees group by to_char(hire_date,'yyyy')")
hire_cn
ggplot(hire_cn,aes(x=YEAR,y=CN,fill=YEAR))+
  geom_bar(stat="identity")+
  geom_text(aes(label=CN))+
  labs(title = "년도별 입사현황", x="년도", y="인원수", fill="년도")+
  theme(plot.title=element_text(face='bold', color='darkblue', hjust=0.5))+
  theme(axis.title.x=element_text(face='bold', color='darkblue'))+
  theme(axis.title.y=element_text(face='bold', color='darkblue'))+
  theme(legend.title.align=0.5, legend.box.background = element_rect(),
        legend.box.margin = margin(t=0.1,r=0.1, b=0.1, l=0.1,unit='cm'))

[문제178] 학생들의 과목 점수를 각각으로 막대그래프를 그리세요.
df <- read.csv("exam.csv", header=TRUE, stringsAsFactors=F)
df

ggplot(df, aes(x=name, y=grade))+
  geom_bar(stat="identity",fill="red")+
  theme(axis.text.x = element_blank())+
  facet_wrap(~ name+subject)


ggplot(df, aes(x=subject, y=grade, group=name))+
  geom_col(aes(fill=subject))+
  theme(axis.text.x = element_blank())+
  facet_wrap(~ name)

[문제179] 'Mata','Young' 학생의 과목점수를 선과점 그래프로 생성하세요.
```{r}
score <- read.csv('exam.csv', stringsAsFactors = F, header=T)
score

# ggplot2
library(ggplot2)
ggplot(score[score$name%in%c('Mata','Young'),], aes(x=subject, y=grade, color=name, group=name))+geom_line()+geom_point()+geom_text(aes(y=grade, label=paste0(grade, '점')), col='black', size=3, vjust=1.2)
```

[문제180] seoul.txt 파일을 단어별 빈도수를 확인 하시고 wordcloud를 그리세요.
```{r}
raw <- readLines('seoul.txt')
temp <- str_replace_all(raw, '[[0-9][:punct:][O+]]', '')
bow <- unlist(extractNoun(temp))
bow_cn <- table(bow)
sort(bow_cn, decreasing = T)

data <- bow_cn[bow_cn < 13 & nchar(names(bow_cn))>=2]
sort(data, decreasing = T)

wordcloud(names(data), freq=data, scale=c(2, 0.5), min.freq = 2, random.order=F, rot.per=0.25, colors=rev(terrain.colors(length(data))))
```

```{r}
library(KoNLP)
library(wordcloud)

seoul <- readLines('seoul.txt')
data <- extractNoun(seoul)

head(unlist(data), 30)
data2 <- unlist(data)
data3 <- Filter(function(x){nchar(x)>=2}, data2)
data3 <- gsub('\\d+', '', data3)
data3 <- gsub('서울시', '', data3)
data3 <- gsub('서울', '', data3)
data3 <- gsub('요청', '', data3)
data3 <- gsub('제안', '', data3)
data3 <- gsub(' ', '', data3)
data3 <- gsub('-', '', data3)
data3 <- gsub('O+', '', data3)
data3

write(unlist(data3), 'seoul_2.txt')
data4 <- read.table('seoul_2.txt')
data4

nrow(data4)
wordcount <- table(data4)
wordcount

head(sort(wordcount, decreasing = T), 50)

library(RColorBrewer)
# brewer.pal(색의 수, 팔레트이름)
# 팔레트 확인: display.brewer.all()
# 팔레트 종류: Dark2(8), Accent(8), Paired(12), pastel1(9), pastel2(8), Set1(9), Set2(8), Set3(12)
# 팔레트 색 확인: display.brewer.pal(색의 수, 팔레트 이름)
display.brewer.pal(8, 'Dark2')

palete <- brewer.pal(9, 'Set3')
wordcloud(names(wordcount), freq=wordcount, scale=c(2, 0.5), random.order = F, random.color = T, colors=palete)
```

[문제181] jeju.txt 분석하세요.
```{r}
# 데이터 로드
spots <- readLines('jejuspots.txt')
raw <- readLines('jeju.txt')

# 관광지 리스트 중복제거
spots <- sort(unique(spots))

# 관광지 리스트에서 유사한 이름 통합
library(stringr)
x <- grep(pattern = '제주', spots, value=T)
x <- str_replace_all(x, '제주', '')

spots <- spots[!spots%in%x]

write(x = spots, file = 'jejuspots_1.txt')

# 데이터에서 공백 제거(관광지 리스트에 포함된 단어 기준)
for(w in spots){
  reg <- ''
  for(i in 1:nchar(w)){
    c <- substr(w, i, i)
    reg <- paste(reg, c, sep=' *')
  }
  reg <- substr(reg, 3, nchar(reg))
  data <- str_replace_all(raw, reg, w)
}

# 문장기호, 공백문자 치환
data <- str_replace_all(data, '[[:punct:][:space:]]', ' ')

# 중복된 관광지 표현 통합
# 숫자 제거를 위해 숫자가 표현된 관광지는 한글로 변경
data <- str_replace_all(data, '1100도로|천백 *도로', '천백도로')
data <- str_replace_all(data, '1100고지|천백 *고지', '천백고지')
grep(pattern = '1100', x = data, value = T)

grep(pattern = '공룡 ', x = data, value = T) #NA

data <- str_replace_all(data, '협재 *해변', '협재해수욕장')
grep(pattern = '협재', x = data, value = T)

grep(pattern = '한림 +공원', x = data, value = T) #NA

grep(pattern = '유리의 +성', x = data, value = T) #NA
grep(pattern = '유리 *성', x = data, value = T) #NA

data <- str_replace_all(data, '오 *설록 *(박물관|뮤지엄|티 *하우스)', '오설록')
data <- str_replace_all(data, '오설록', '오설록티뮤지엄')
grep(pattern = '설록', x = data, value = T)

data <- str_replace_all(data, '테지움|테디 *베어 *(박물관|뮤지움|사파리)', '테디베어뮤지엄')
grep(pattern = '테디 ', x = data, value = T)

grep(pattern = '오성', x = data, value = T) #NA

data <- str_replace_all(data, '중문 *(랜드|단지)', '중문관광단지')
grep(pattern = '중문', x = data, value = T)

grep(pattern = 'KAL',ignore.case = T, x = data, value = T)
grep(pattern = '칼',ignore.case = T, x = data, value = T)
grep(pattern = '서귀포',ignore.case = T, x = data, value = T)

grep(pattern = '주상 ', x = data, value = T) #NA

data <- str_replace_all(data, ' +일출봉', '성산일출봉')
grep(pattern = '성산 ', x = data, value = T)
grep(pattern = ' 일출봉', x = data, value = T)

grep(pattern = '러브 ', x = data, value = T) #NA

grep(pattern = '섭지 ', x = data, value = T) #NA

grep(pattern = '신비', x = data, value = T) #NA

grep(pattern = '에코 ', x = data, value = T) #NA

data <- str_replace_all(data, '천지연폭포', '천지연')
data <- str_replace_all(data, '천지연', '천지연폭포')
grep(pattern = '천지연 ', x = data, value = T)

data <- str_replace_all(data, '천제연폭포', '천제연')
data <- str_replace_all(data, '천제연', '천제연폭포')
grep(pattern = '천제연 ', x = data, value = T)


grep(pattern = '월정리 ', x = data, value = T) #NA

grep(pattern = '함덕 ', x = data, value = T) #NA

grep(pattern = '산굼 ', x = data, value = T) #NA

grep(pattern = '새별 ', x = data, value = T) #NA

grep(pattern = '한라산 ', x = data, value = T) #NA

grep(pattern = '한라산국립공원', x = data, value = T) #NA

grep(pattern = '섭지 ', x = data, value = T) #NA

grep(pattern = '용눈이 ', x = data, value = T) #NA

grep(pattern = '김녕 *(해변|)', x = data, value = T) #NA

grep(pattern = '이호테우 *(해변|)', x = data, value = T) #NA

grep(pattern = '세화 *(해변|)', x = data, value = T) #NA

grep(pattern = '광치기 *(해변|)', x = data, value = T) #NA

grep(pattern = '애월 ', x = data, value = T) #NA

grep(pattern = '용머리 *[^해]', x = data, value = T) #NA

data <- str_replace_all(data, '절물 *자연 *휴양림', '제주절물자연휴양림')
grep(pattern = '절물', x = data, value = T) #NA

grep(pattern = '정방 ', x = data, value = T) #NA

grep(pattern = '색달 *', x = data, value = T) #NA

grep(pattern = '용두 *[^암]', x = data, value = T) #NA

grep(pattern = '당랑쉬 *', x = data, value = T) #NA

grep(pattern = '쇠머리 *', x = data, value = T) #NA

grep(pattern = '황우지 *', x = data, value = T) #NA

data <- str_replace_all(data, '1112번도로', '천백십이도로')
grep(pattern = '1112 *', x = data, value = T)

data <- str_replace_all(data, '김녕 *미로 *공원', '제주김녕미로공원')
grep(pattern = '미로 *', x = data, value = T)

data <- str_replace_all(data, '휴애리', '휴애리자연생활공원')
grep(pattern = '휴애리 *', x = data, value = T) 

grep(pattern = '여미지 *', x = data, value = T) #NA

data <- str_replace_all(data, '소인국테마파크', '소인국')
data <- str_replace_all(data, '소인국', '소인국테마파크')
grep(pattern = '소인국 *', x = data, value = T)

grep(pattern = '키티 *', x = data, value = T) #NA

grep(pattern = '케이 *팝', x = data, value = T) #NA

data <- str_replace_all(data, '이니스프리하우스', '이니스프리제주하우스')
grep(pattern = '이니스프리 *', x = data, value = T)

grep(pattern = '우주 *', x = data, value = T) #NA

data <- str_replace_all(data, '세계자동차박물관', '세계자동차제주박물관')
grep(pattern = '자동차 *', x = data, value = T)

data <- str_replace_all(data, '제주민속자연사박물관', '민속자연사박물관')
grep(pattern = '자연사 *', x = data, value = T)

grep(pattern = '영화 *', x = data, value = T)  #NA

grep(pattern = '렛츠 *', x = data, value = T)  #NA

# 제주 관광지 사전에 등록
library(KoNLP)
useSejongDic()
buildDictionary(ext_dic='sejong', user_dic=data.frame(readLines('jejuspots_1.txt'), 'ncn'), replace_usr_dic = T)

# 숫자 제거후 관광지 이름에 숫자 복구
data <- str_replace_all(data, '[0-9]', '')
data <- str_replace_all(data, '천백도로', '1100도로')
data <- str_replace_all(data, '천백고지', '1100고지')
data <- str_replace_all(data, '천백십이도로', '1112도로')
data <- str_replace_all(data, '있습니', '')

# 명사 추출
# bow <- extractNoun(data)

# 하나의 리뷰에서 반복된 명사 제거하여 추출
bow <- list()
for(i in 1:NROW(data)){
  bow <- append(x = bow, values = unique(extractNoun(data[i])), after = length(bow))
}

#빈도체크
bow_cn <- table(unlist(bow))
result <- sort(bow_cn[nchar(names(bow_cn))>=2], decreasing = T)

# 임의로 삭제할 단어 제거
stopWords <- c('제주', '여행', '숙소', '해안', '전망', '시간', '공항')
result <- result[!names(result)%in%stopWords]

# wordcloud 생성
# 전체 데이터
library(wordcloud)
pal <- brewer.pal(8, 'Accent')
wordcloud(names(result), freq=result, scale=c(3, 0.5), min.freq=2, max.words = 100, random.order=F, rot.per=.1, colors=pal)

# 지정된 관광지 데이터만 포함
loc <- names(result[names(result)%in%spots])
wordcloud(loc, freq=result, scale=c(3, 0.5), min.freq=2, max.words = 100, random.order=F, rot.per=.1, colors=pal)

# 구글맵 표시
library(ggmap)
library(ggplot2)
topN <- 20
names <- loc[1:topN]
gc <- geocode(enc2utf8(names))
df <- na.omit(data.frame(name=names, lon=gc$lon, lat=gc$lat))
cen <- c(mean(df$lon), mean(df$lat))
map <- get_googlemap(center=cen, maptype='satellite', zoom=10, markers = gc)
ggmap(map)+geom_point(data=df, aes(x=lon, y=lat), size=result[1:NROW(df)], alpha=0.3, color='orange')+ geom_text(data = df, aes(x=lon, y=lat, label=df$name), col='black', size=2, vjust=-1.2)

[문제182] noise.txt 데이터를 시각화 하세요.

데이터 읽어오기
```{r}
getwd()
setwd('C:/Users/stu/git/DA_Academy')
# read.csv
raw <- read.csv('noise.txt', header = F, stringsAsFactors = F, sep = ' ')
raw <- as.double(unlist(raw))

# read.table
# raw <- read.table('noise.txt')
```

히스토그램
```{r}
data <- raw
minimum <- (min(data)%/%10)*10
maximum <- ((max(data)%/%10)+1)*10
step <- 5

hist(data, breaks=seq(minimum, maximum, step), right = F, ylim=c(0, 10+(3*step)), col=rainbow(8), border=F, labels=T, main = 'Noise.txt의 데이터 분포', xlab='구간', ylab= '', axes=F)
axis(1, at=seq(minimum, maximum, step), labels=seq(minimum, maximum, step), las=1)
```

꺾은선 그래프
```{r}
library(ggplot2)
data <- round(raw)
minimum <- (min(data)%/%10)*10
maximum <- ((max(data)%/%10)+1)*10
step <- 5

freq <- table(cut(data, breaks=seq(minimum, maximum, step), right=F))
name <- names(freq)
name <- gsub('[[]', '', name)
name <- gsub(',', '이상 ', name)
name <- gsub(')', '미만', name)
names(freq) <- name
data <- as.data.frame(freq)

ggplot(data, aes(x=Var1, y=Freq, group=1))+ggtitle('Noise.txt의 분포')+labs(x='구간', y='분포')+geom_line()+geom_point()
```

[문제183] noise.txt 데이터에서 25%의 기준 데이터 75%의 기준 데이터를 찾으세요.
```{r}
raw <- read.csv('noise.txt', header = F, stringsAsFactors = F, sep = ' ')
raw <- as.double(unlist(raw))

findCriteria <- function(data, percentile, decreasing = F){
  if(decreasing==T){data <- sort(data, decreasing = T)}else{data <- sort(data, decreasing = F)}
  return(data[ceiling(length(data)*(percentile/100))])
}

# 하위 25% 기준 데이터
findCriteria(raw, 25, F)

# 하위 75% 기준 데이터
findCriteria(raw, 75, F)

# 상위 75% 기준 데이터
findCriteria(raw, 75, T)
```

### quantile()
* 데이터의 4분위수 리턴
* quantile(데이터, type=2)
```{r}
quantile(raw, type=2)['25%']
```


[문제184] food.csv 데이터를 기준으로 토마토의 sweetness은 6,  crunchiness은 4 입니다. 분류를 하세요.
```{r}
food <- read.csv('food.csv', stringsAsFactors = F, header = T)
food

train <- food[, c(2, 3)]
label <- food[, 4]
test <- data.frame(sweetness=6,crunchiness=4)

knn(train, test, label, k=3, prob=T)
```
```{r}
library(ggplot2)
tomato <- data.frame(ingredient='tomato', sweetness=6,crunchiness=4)
ggplot(data=food, aes(x=sweetness, y=crunchiness))+labs(title='What is tomato class?') + geom_point(aes(color=class, shape=class), size=6) + geom_text(aes(label=ingredient), vjust=-1, size=5)+geom_point(data=tomato, colour='black', size=6)+geom_text(data=tomato, aes(label=ingredient), vjust=-2, size=5, fontface='bold')

data.frame(ingredient=food[,1], distinct=sqrt((food[,2] - tomato[, 2])^2 + (food[,3] - tomato[,3]^2)))
```

[문제185]  나이, 월수입, 상품구매여부를 갖는 데이터가 있다.
이 데이터를 이용해서 나이가 44 이고 월급이 400 만원인 사람이
상품을 구매할지 비구매할지를 knn 분류 알고리즘으로 분석하세요.
```{r}
library(class)
setwd('C:/Users/stu/git/DA_Academy')

buy <- read.csv('buy.csv', stringsAsFactors = F, header = T)
train <- buy[, -3]
label <- buy[, 3]
test <- data.frame(나이=44, 월수입=440)

# 표준정규화
print('비표준화, K=1')
knn(train = train, test = test, cl = label, k = 1, prob = T)
print('비표준화, K=3')
knn(train = train, test = test, cl = label, k = 3, prob = T)
print('비표준화, K=5')
knn(train = train, test = test, cl = label, k = 5, prob = T)
print('*************************************************')

train1 <- scale(buy[,-3])
test1 <- matrix(c((44-mean(buy$나이))/sd(buy$나이), (440-mean(buy$월수입))/sd(buy$월수입)),nrow = 1)
print('표준화, K=1')
knn(train1, test1, label, k=1, prob=T)
print('표준화, K=3')
knn(train1, test1, label, k=3, prob=T)
print('표준화, K=5')
knn(train1, test1, label, k=5, prob=T)

# 0-1 변환
temp <- data.frame(나이=44, 월수입=440, 상품구매여부=NA)
buy1 <- rbind(buy, temp)
train1 <- buy1[, -3]
label <- buy1[-22, 3]

for(i in 1:length(train1)){
  cmax <- max(train1[, i])
  cmin <- min(train1[, i])
  for(j in 1:NROW(train1)){
    train1[j, i] <- (train1[j, i]-cmin)/(cmax-cmin)
  }
}

test1 <- train1[22, ]
train1 <- train1[-22,]

print('0-1표준화, K=1')
knn(train1, test1, label, k=1, prob=T)
print('0-1표준화, K=3')
knn(train1, test1, label, k=3, prob=T)
print('0-1표준화, K=5')
knn(train1, test1, label, k=5, prob=T)
```

[문제186] zoo.csv 데이터 집합은 동물의 특징과 부류 정보가 있습니다. 
	  특정 데이터 동물 정보가 어느 부류에 속하는 지를 knn 알고리즘을 이용해서 분석하세요.

[변수 정보]

   1. animal name:      Unique for each instance
   2. hair		Boolean
   3. feathers		Boolean
   4. eggs		Boolean
   5. milk		Boolean
   6. airborne		Boolean
   7. aquatic		Boolean
   8. predator		Boolean
   9. toothed		Boolean
  10. backbone		Boolean
  11. breathes		Boolean
  12. venomous		Boolean
  13. fins		Boolean
  14. legs		Numeric (set of values: {0,2,4,5,6,8})
  15. tail		Boolean
  16. domestic		Boolean
  17. catsize		Boolean
  18. type		Numeric (integer values in range [1,7])

[18. type]
1 : 포유류
2 : 조류
3 : 파충류
4 : 어류
5 : 양서류 
6 : 곤충
7 : 갑각류 
```{r}
zoo <- read.csv('zoo.csv', header = F, stringsAsFactors = F)
dim(zoo)
train <- zoo[-101,-c(1, 18)]
test <- zoo[101, -c(1, 18)]
label <- zoo[-101, 18]
type <- c('포유류', '조류', '파충류', '어류', '양서류', '곤충', '갑각류')
for(i in 1:length(type)){
  label[grep(i, label)] <- type[i]
}
label

train
test
knn(train, test, label, k=3, prob=T)

```