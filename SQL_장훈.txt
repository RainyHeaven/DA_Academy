-- 문제 1 employees 테이블에서 employee_id, last_name과 first_name은 연결해서 표시하고(공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성해 주세요.
select employee_id as "Emp#", last_name || ' ' || first_name as "Employee Name"
from employees;

-- 문제 2 employees 테이블에서 컬럼중에 last_name, job_id를 연결해서 표시하고(쉼표와 공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성하세요.
select last_name || ', ' || job_id as "Employee and Title"
from employees;

-- 문제3 employees테이블에서 급여가 2500 ~ 3500 인 사원들의 모든 정보를 조회하세요.
select *
from employees
where salary >= 2500 and salary <= 3500;

-- 문제4 관리자의 사원번호가 100, 101, 200인 사원들의 모든 정보를 출력해주세요.
select *
from employees
where manager_id = 100 or manager_id = 101 or manager_id = 200;

-- 문제5 last_name 두번째 위치에 소문자 o가 있고 뒤에 어떤 글자가 올지 모른다. 이 조건에 해당하는 데이터를 추출해부세요.
select *
from employees
where last_name like '_o%';

-- 문제6 departments 테이블에 있는 데이터에서 department_name , manager_id 컬럼을 가지고 화면 결과 처럼 출력하는 쿼리문장을 만드세요.
select department_name || 'Department''s Manager Id: ' || manager_id as "Department and Manager"
from departments;

-- 문제7 employees 테이블에 있는 데이터 중에  last_name에 Whalen 이라는 사원의 모든 정보를 출력하세요.
select *
from employees
where last_name = 'Whalen';

-- 문제8 EMPLOYEES 테이블에서 급여가 3000보다 작거나 같은 사원의 last_name, salary 를 출력하세요.
select last_name, salary
from employees
where salary <= 3000;

-- 문제9 EMPLOYEES 테이블에서 salary(급여)값이 10000이상부터 15000이하인 사원들의 모든정보를 출력하세요.
select *
from employees
where salary between 10000 and 15000;

-- 문제10 EMPLOYEES 테이블에서 last_name이 "S"로 시작하는 사원의 last_name, first_name 을 출력하세요.
select last_name, first_name
from employees
where last_name like 'S%';

-- 문제11 last_name의 세번째 문자가 "o"인 모든 사원의 last_name을 출력하세요.
select last_name
from employees
where last_name like '__o%';

-- 문제12 employees 테이블에 있는 데이터 중에 job_id에 SA_ 문자열로 시작되는 사원들의 employee_id, last_name, job_id를 출력하세요.
select employee_id, last_name, job_id 
from employees
where job_id like 'SA@_%' escape '@';

-- 문제13 employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' and salary >= 10000;

-- 문제14 employees 테이블에서  job_id 컬럼의 값이  SA로 시작하거나 10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' or salary >= 10000;

-- 문제15 employees 테이블에서  job_id컬럼의 값이  IT_PROG, ST_CLERK , SA_REP가 아닌 모든 사원의 last_name, job_id를  출력해주세요.
select last_name, job_id
from employees
where job_id not in ('IT_PROG','ST_CLERK', 'SA_REP');

-- 문제16 employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받고 2005년도에 입사한(hire_date) 모든 사원들의 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' and salary >= 10000 and hire_date between to_date('2005.01.01', 'yyyy.mm.dd') and to_date('2005.12.31', 'yyyy.mm.dd');

-- 문제17 employees 테이블에서 job_id 컬럼의 값이 SA_REP 또는 AD_PRES 사원들 중에 급여가 10000 초가 한 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id in ('SA_REP', 'AD_PRES') and salary > 10000;

select last_name, salary
from employees
order by salary desc;

select department_id, salary
from employees
order by department_id asc, salary desc;

-- 문제18 employees 테이블에 last_name 컬럼의 값 중에  "J" 또는 "A" 또는 "M"으로 시작하는 사원들의 last_name(첫번째 문자는대문자, 나머지는 모두 소문자)과 last_name의 길이를 표시하는 query 를 작성합니다.
-- 사원들의 last_name을 기준으로 결과를 오름차순 정렬해 주세요. 
select initcap(last_name), length(last_name)
from employees
where last_name like 'J%' or last_name like 'A%' or last_name like 'M%'
order by last_name;

select initcap(last_name), length(last_name)
from employees
where instr(last_name, 'J') = 1 or instr(last_name, 'A') = 1 or instr(last_name, 'M') = 1
order by last_name;

select initcap(last_name), length(last_name)
from employees
where substr(last_name, 1, 1) in ('J', 'M', 'A')
order by last_name;

-- 문제19 employees테이블에서 department_id(부서코드)가 50번 사원들 중에 last_name에 두번째 위치에 "a"글자가 있는 사원들을 조회하세요. 
select *
from employees
where department_id = 50 and last_name like '_a%';

select *
from employees
where department_id = 50 and substr(last_name, 2, 1) = 'a';

select *
from employees
where department_id = 50 and instr(last_name, 'a', 2, 1) = 2;

-- 문제20 사원의 last_name,hire_date 및 근무 6 개월 후 월요일에 해당하는 날짜를 조회하세요. 열별칭은 REVIEW 로 지정합니다. 
select last_name, hire_date, next_day(add_months(hire_date, 6), '월요일') as REVIEW
from employees;

-- 문제21 15년 이상 근무한 사원들의 employee_id(사원번호), hire_date(입사일), 근무개월수를 조회하세요.
select employee_id, hire_date, months_between(sysdate, hire_date) as work_months
from employees
where months_between(sysdate, hire_date) >= (15*12);

-- 문제22 employees(사원)테이블에 있는 last_name의 세번째 문자가 'a' 또는 'e'가 포함된 모든 사원의 last_name을 조회하세요.
select last_name
from employees
where substr(last_name, 3, 1) in ('a', 'e');

select last_name
from employees
where last_name like '__a%' or last_name like '__e%';

select last_name
from employees
where instr(last_name, 'a', 3, 1) = 3 or instr(last_name, 'e', 3, 1) = 3;

-- 스타트지점을 바꾸는 것은 작동 안하는 경우가 있음
select last_name
from employees
where instr(last_name, 'a') = 3 
or instr(last_name, 'a', 1, 2) = 3
or instr(last_name, 'a', 1, 3) = 3
or instr(last_name, 'e') = 3 
or instr(last_name, 'e', 1, 2) = 3
or instr(last_name, 'e', 1, 3) = 3;

-- 문제23 employees(사원)테이블에 있는  80번 부서(department_id) 사원중에 commission_pct 값이 0.2 이고 job_id는 SA_MAN인 사원의 employee_id, last_name, salary를 조회하세요.
select employee_id, last_name, salary
from employees
where department_id = 80 and commission_pct = 0.2 and job_id = 'SA_MAN';

-- 문제24 사원의 employees(사원)테이블에 있는 last_name,hire_date 및 근무 6 개월 후 첫번째 월요일에 해당하는 급여 협상 날짜를 표시합니다.
-- 열 레이블을 REVIEW 로 지정합니다. 날짜는 "월요일, the Second of 4, 2007"과 유사한 형식으로 나타나도록 지정합니다.
select last_name, hire_date, to_char(next_day(add_months(hire_date, 6), '월요일'), 'day, "the" ddspth "of" dd, yyyy') as REVIEW
from employees;

-- 문제25 employees(사원) 테이블에서  일요일에 입사한 사원의 정보를 조회하세요.
select *
from employees
where to_char(hire_date, 'day') = '일요일';

select *
from employees
where to_char(hire_date, 'd') = '1';

-- 문제26 짝수달에 입사한 사원의 정보를 조회하세요.
select *
from employees
where mod(to_number(to_char(hire_date, 'fmmm')), 2) = 0;

-- 문제27 2006년도에 홀수 달에 입사한 사원의 employee_id, last_name, hire_date를 조회하세요.
select employee_id, last_name, hire_date
from employees
where hire_date  between to_date('20050101', 'yyyymmdd') and to_date('20051231', 'yyyymmdd') and mod(to_number(to_char(hire_date, 'fmmm')), 2) = 1;

-- 문제 28 아래 화면의 결과 처럼 사원의  last_name,  salary, salary 값을 1000당 별표를 하나를 출력하는  query문을 작성하세요. 
select last_name, salary, lpad('*', trunc(salary/1000), '*') as "STAR"
from employees
order by salary desc;

-- 문제 29 아래 화면결과 처럼 출력하세요.
select '현재 서버의 날짜 시간 : ' || to_char(sysdate, 'yyyymmdd hh:mi:ss am') as "현재날짜시간"
from dual;

-- 문제 30 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 하루 전 : ' || to_char(sysdate-1, 'yyyymmdd hh24:mi:ss') as "하루전"
from dual;

-- 문제 31 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 1시간 전 : ' || to_char(sysdate-1/24, 'yyyymmdd hh24:mi:ss') as "1시간전"
from dual;

select '서버의 시간을 기준으로 1시간 전 : ' || to_char(sysdate-to_dsinterval('0 01:00:00'), 'yyyymmdd hh24:mi:ss') as "1시간전"
from dual;

-- 문제 32 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 5분 전 : ' || to_char(sysdate-to_dsinterval('0 00:05:00'), 'yyyymmdd hh24:mi:ss') as "5분전"
from dual;

select '서버의 시간을 기준으로 5분 전 : ' || to_char(sysdate-5/(24*60), 'yyyymmdd hh24:mi:ss') as "5분전"
from dual;

-- 문제 33 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 10초 전 : ' || to_char(sysdate-to_dsinterval('0 00:00:10'), 'yyyymmdd hh24:mi:ss') as "10초전"
from dual;

select '서버의 시간을 기준으로 10초 전 : ' || to_char(sysdate-10/(24*60*60), 'yyyymmdd hh24:mi:ss') as "10초전"
from dual;

-- 문제 34 JOB_ID 열의 값을 기준으로 모든 사원의 등급(GRADE)을 표시하는 query 를 작성하세요.
select job_id, decode(job_id, 'AD_PRES', 'A', 'ST_MAN', 'B', 'IT_PROG', 'C', 'SA_REP', 'D', 'ST_CLERK', 'E', 'Z') as "GRADE"
from employees;

-- 문제 35 사원테이블에  연봉을 계산 하는 쿼리문을 작성하세요 
-- 단 commission_pct 값이 null 아니면 (salary*12) + (salary*12*commission_pct) 이값이 수행되고
-- null 이면 salary * 12 가 수행합니다. 수행 결과는 화면처럼 만드세요.
-- (nvl, nvl2,  coalesce, case, decode 함수를 사용하여 각각으로 수행해서 보고서 작성해 주세요)
select last_name, salary, commission_pct, decode(commission_pct, null, salary * 12, (salary * 12) + (salary * 12 * commission_pct)) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, (salary * 12) + (salary * 12 * nvl(commission_pct, 0)) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, nvl2(commission_pct, (salary * 12) + (salary * 12 * commission_pct), salary * 12) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, coalesce((salary * 12) + (salary * 12 * commission_pct), salary * 12) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, case when commission_pct is null then salary * 12 else (salary * 12) + (salary * 12 * commission_pct) end as "ANN_SAL"
from employees;

-- 문제36 모든 사원의 최고급여, 최저급여, 합계 및 평균 급여를 찾습니다. 
-- 열 레이블을 각각 Maximum, Minimum, Sum 및 Average 로 지정합니다. 
-- 결과를 소수점은 반올림해서 정수값으로 출력하세요.
select max(salary) as "Maximum", min(salary) as "Minimum", sum(salary) as "Sum", round(avg(salary), 0) as "Average"
from employees;

-- 문제 37 2008년도에 입사한 사원들의 job_id별 인원수를 구하고 인원수가 많은 순으로 출력하세요. 
select job_id, count(*)
from employees
where to_char(hire_date, 'yyyy') = '2008'
group by job_id
order by 2 desc;

-- 문제 38 job_id별로 총액급여를 구합니다. 단 CLERK글자가 있는 job_id는 제외하고 총액급여는 13000가 넘는 정보를 출력하면서 총액 급여를 기준으로 내림차순 정렬하세요.
select job_id, sum(salary) as "payroll"
from employees
where job_id not like '%CLERK%'
group by job_id
having  sum(salary) > 13000
order by 2 desc;

-- 문제 39 입사한 년도별로 급여의 총액을 출력하세요.
select to_char(hire_date, 'yyyy'), sum(salary)
from employees
group by to_char(hire_date, 'yyyy');

select extract(year from hire_date), sum(salary)
from employees
group by extract(year from hire_date);

-- 문제 40 입사한 달별 인원수를 출력해주세요.
select to_char(hire_date, 'mm'), count(*)
from employees
group by to_char(hire_date, 'mm')
order by 1;

-- 문제 41 사원의 총 수와 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요.
-- 결과값에 1이 아닌 0이나 문자를 넣어도 무방(행 수를 세기 때문에)
select count(*) as TOTAL, count(decode(extract(year from hire_date), 2005, 1)) as "2005", count(decode(extract(year from hire_date), 2006, 1)) as "2006", count(decode(extract(year from hire_date), 2007, 1)) as "2007", count(decode(extract(year from hire_date), 2008, 1)) as "2008"
from employees;

-- 결과값에 1이 들어가야 합계가 계산됨
select count(*) as TOTAL, sum(case to_char(hire_date, 'yyyy') when '2005' then 1 end) as "2005", sum(case to_char(hire_date, 'yyyy') when '2006' then 1 end) as "2006", sum(case to_char(hire_date, 'yyyy') when '2007' then 1 end) as "2007", sum(case to_char(hire_date, 'yyyy') when '2008' then 1 end) as "2008"

-- 문제 42 모든 사원의 last_name, department_id, department_name을 표시하기 위한 query 를 작성합니다.

--오라클

select e.last_name, e.department_id, d.department_name
from employees e, departments d
where e.department_id = d.department_id(+);

--ANSI표준
select e.last_name, e.department_id, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id;

-- 문제 43 부서 80에 속하는 last_name, job_id, department_name, city를 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, e.job_id, d.department_name, l.city
from employees e, departments d, locations l
where e.department_id = 80 and e.department_id = d.department_id and d.location_id = l.location_id;

--ANSI표준
select e.last_name, e.job_id, d.department_name, l.city
from employees e join departments d
on e.department_id = d.department_id 
join locations l
on d.location_id = l.location_id
where e.department_id = 80;

--문제 44 commission_pct 에 null이 아닌 모든 사원의 last_name, department_name, location_id, city를 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, d.department_name, d.location_id, l.city
from employees e, departments d, locations l
where e.commission_pct is not null and e.department_id = d.department_id(+) and d.location_id = l.location_id(+);

--ANSI표준
select e.last_name, d.department_name, d.location_id, l.city
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
where e.commission_pct is not null;

--문제 45 last_name에 a(소문자)가 포함된 모든 사원의 last_name, department_name 을 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, d.department_name
from employees e, departments d
where e.last_name like '%a%' and e.department_id = d.department_id(+);

--ANSI표준
select e.last_name, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
where e.last_name like '%a%';

select e.last_name, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
where instr(e.last_name, 'a') >=1;

-- 문제 46 locations 테이블에 있는 city컬럼에  Toronto도시에서 근무하는 모든 사원의 last_name, job_id, department_id, department_name 을 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, e.job_id, e.department_id, d.department_name
from employees e, departments d, locations l
where l.city = 'Toronto' and e.department_id = d.department_id and d.location_id = l.location_id;

--ANSI표준
select e.last_name, e.job_id, e.department_id, d.department_name
from employees e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id
where l.city = 'Toronto';
desc employees

-- 문제 47 2006년도에 입사한 사원들의 부서이름별로 급여의 총액, 평균을 출력하세요.
--오라클
select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e, departments d
where extract(year from e.hire_date) = 2006 and e.department_id = d.department_id
-- extract로 뽑아내면 인덱스 스캔이 아닌 풀 스캔이 됨
group by d.department_name;

--ANSI표준
select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e join departments d
on e.department_id = d.department_id
where to_char(e.hire_date, 'yyyy') = '2006' 
-- to_char로 뽑아내면 인덱스 스캔이 아닌 풀 스캔이 됨
group by d.department_name;

select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e join departments d
on e.department_id = d.department_id
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
group by d.department_name;

-- 문제 48 2006년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요.
--오라클
select l.city, sum(e.salary), avg(e.salary)
from employees e, departments d, locations l
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
and e.department_id = d.department_id
and d.location_id = l.location_id
group by l.city;

--ANSI표준
select l.city, sum(e.salary), avg(e.salary)
from employees e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
group by l.city;

-- 문제49 2007년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요. 단 부서 배치를 받지 않는 사람들의 급여의 총액, 평균도 구하세요.
--오라클
select l.city, sum(e.salary), avg(e.salary)
from employees e, departments d, locations l
where e.hire_date >= to_date('20070101', 'yyyymmdd') and e.hire_date < to_date('20080101', 'yyyymmdd')
and e.department_id = d.department_id(+)
and d.location_id = l.location_id(+)
group by l.city;

--ANSI표준
select l.city, sum(e.salary), avg(e.salary)
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
where e.hire_date >= to_date('20070101', 'yyyymmdd') and e.hire_date < to_date('20080101', 'yyyymmdd')
group by l.city;

-- 문제 50 사원들의 사번, 급여, 급여등급, 부서이름을 출력하세요. 부서배치를 받지 않는 사원은 제외시켜주세요.
--오라클
select e.employee_id, e.salary, j.grade_level, d.department_name
from employees e, departments d, job_grades j
where e.department_id = d.department_id and e.salary between j.lowest_sal and j.highest_sal;

--ANSI표준
select e.employee_id, e.salary, j.grade_level, d.department_name
from employees e join departments d
on e.department_id = d.department_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal;

-- 문제 51 사원들의 사번, 급여, 급여등급, 부서이름, 근무 도시 정보를 출력하세요. 부서배치를 받지 않는 사원도 포함시켜주세요.
--오라클
select e.employee_id, e.salary, j.grade_level, d.department_name, l.city
from employees e, departments d, job_grades j, locations l
where e.department_id = d.department_id(+)
and e.salary between j.lowest_sal and j.highest_sal
and d.location_id = l.location_id(+);

--ANSI표준
select e.employee_id, e.salary, j.grade_level, d.department_name, l.city
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal;

-- 문제 52 사원들의 last_name,salary,grade_level, department_name을 출력하는데 last_name에 a문자가 2개 이상 포함되어 있는 사원들을 출력하세요.
--오라클
select e.last_name, e.salary, j.grade_level, d.department_name
from employees e, job_grades j, departments d
where instr(e.last_name, 'a', 1, 2) >= 2 and e.department_id = d.department_id(+) and e.salary between j.lowest_sal and j.highest_sal;

--ANSI표준
select e.last_name, e.salary, j.grade_level, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal
where instr(e.last_name, 'a', 1, 2) >= 2;

-- 문제 53 141번 사원의 job_id와 동일한 job_id를 가진 사원들 중에 141번 사원의 급여보다 더 많이 받는 사원을 출력해주세요
select *
from employees
where job_id = (select job_id
                from employees
                where employee_id = 141)
and salary > (select salary
                from employees
                where employee_id = 141);
                
-- 문제 54 최소월급을 받은 사원들의 정보를 출력해주세요.
select *
from employees
where salary = (select min(salary)
                from employees);

-- 문제 55 평균 급여가 가장 낮은 job_id를 찾아 주세요.
select job_id
from employees
group by job_id
having avg(salary) = (select min(avg(salary))
                      from employees
                      group by job_id);
                      
-- 문제 56 부서별로 최소 급여자들을 출력해주세요.
select *
from employees
where salary in (select min(salary) from employees group by department_id)
order by department_id;

-- 문제 57 last_name 에 문자 "u"가 포함된 사원과 같은 부서에 근무하는 모든 사원의 employee_id, last_name 을 출력하세요.
select employee_id, last_name
from employees
where department_id in (select distinct department_id from employees where last_name like '%u%');

-- 문제 58 부서 위치(location_id) ID 가 1700 인 모든 사원의 last_name, department_id, job_id 를 출력하세요.(조인, 서브쿼리)
--오라클
select e.last_name, e.department_id, e.job_id
from employees e, departments d
where e.department_id = d.department_id
and d.location_id = 1700;

--ANSI표준
select e.last_name, e.department_id, e.job_id
from employees e join departments d
on e.department_id = d.department_id
where d.location_id = 1700;

--서브쿼리
select last_name, department_id, job_id
from employees
where department_id in (select department_id from departments where location_id = 1700);

-- 문제 59 King 에게 보고하는 모든 사원의 last_name 및 salary 출력하세요.(조인, 서브쿼리)
--오라클
select e.last_name, e.salary
from employees e, employees m
where e.manager_id = m.employee_id
and m.last_name = 'King';

--ANSI표준
select e.last_name, e.salary
from employees e join employees m
on e.manager_id = m.employee_id
where m.last_name = 'King';

--서브쿼리
select last_name, salary
from employees
where manager_id in (select distinct employee_id from employees where last_name = 'King');

-- 문제 60 부서 이름(department_name) 이 Executive 부서의 모든 사원에 대한 department_id, last_name, job_id  출력하세요.
--오라클
select e.department_id, e.last_name, e.job_id
from employees e, departments d
where e.department_id = d.department_id
and d.department_name = 'Executive';

--ANSI표준
select e.department_id, e.last_name, e.job_id
from employees e join departments d
on e.department_id = d.department_id
where d.department_name = 'Executive';

--서브쿼리
select department_id, last_name, job_id
from employees
where department_id = (select department_id from departments where department_name = 'Executive');

-- 문제 61 60부서에 소속된 모든 사원의 급여(salary)보다 높은(max) 급여를 받는 모든 사원 출력하세요.
select *
from employees
where salary > all (select salary from employees where department_id = 60);

select *
from employees
where salary > (select max(salary) from employees where department_id = 60);

-- 문제 62 전체 평균 급여보다 많은 급여를 받고 last_name에 "u"가 포함된 사원이 있는 부서에서 근무하는 모든 사원의 employee_id, last_name, salary 출력하세요
select employee_id, last_name, salary
from employees
where salary > (select avg(salary) from employees)
and department_id in (select distinct department_id from employees where last_name like '%u%');

-- 문제 63 관리자 사원들의 정보를 출력해주세요 
select *
from employees
where employee_id in (select distinct manager_id from employees);

-- 문제 64 관리자가 아닌 사원들의 정보를 출력해 주세요
-- 서브쿼리에 null 값이 있을 경우 not in 연산자를 사용할 수 없음 
select *
from employees
where employee_id not in (select distinct manager_id from employees where manager_id is not null);

select *
from employees
where employee_id != all (select distinct manager_id from employees where manager_id is not null);

-- 문제 65 last_name에 Davies 사원보다 늦게 입사한 사원 중에 급여가 Davies 사원의 급여 이하로 받고 있는 사원들을 출력해주세요.
--서브쿼리
select *
from employees
where salary <= (select salary from employees where last_name = 'Davies')
and hire_date > (select hire_date from employees where last_name = 'Davies');

--오라클
select e.*
from employees e, employees d
where e.salary <= d.salary
and e.hire_date > d.hire_date
and d.last_name = 'Davies';

--ANSI표준
select e.*
from employees e join employees d
on e.salary <= d.salary
and e.hire_date > d.hire_date
where d.last_name = 'Davies';

-- 문제 66 자신의 부서 평균 급여보다 더 많은 급여를 받는 사원들의 정보를 출력해주세요
select *
from employees o
where o.salary > (select avg(salary) from employees where department_id = o.department_id);

-- 문제 67 두번 이상 job_id를 바꾼 사원 출력해주세요.
select j.*
from job_history j
where 2 <= (select count(employee_id) from job_history where employee_id = j.employee_id)
order by j.employee_id;

-- 문제 68 관리자 사원에 대해서 출력해주세요
select *
from employees e
where employee_id in (select distinct manager_id from employees where manager_id is not null);

select *
from employees o
where exists (select 'x'--문법 오류를 막기 위한 의미없는 표현 'x'
              from employees
              where manager_id = o.employee_id);
              
-- 문제 69 관리자가 아닌 사원에 대해서 출력해주세요
select *
from employees e
where employee_id not in (select distinct manager_id from employees where manager_id is not null);

select *
from employees o
where not exists (select 'x'
              from employees
              where manager_id = o.employee_id);

-- 문제 70 사원이 없는 부서 정보만 출력해주세요
select *
from departments
where department_id not in (select department_id from employees where department_id is not null);

select *
from departments d
where not exists (select 'x' from employees where department_id = d.department_id);

-- 문제 71 자신의 부서안에서 자신보다 늦게 입사하고 자신보다 급여를 많이받는 사람이 있는 사람들을 찾아주세요
select *
from employees e
where exists (select 'x' from employees where department_id = e.department_id and salary > e.salary and hire_date > e.hire_date)
and e.department_id = 50;

select distinct e.*
from employees e, employees l
where e.hire_date < l.hire_date 
and e.salary < l.salary
and e.department_id = l.department_id
and e.department_id = 50;

-- 문제 72 사원수가 3명 미만인 부서번호, 부서이름, 인원수를 출력해주세요
select d.department_id, d.department_name, m.peoples
from departments d, (select department_id, count(employee_id) peoples from employees where department_id is not null group by department_id having count(employee_id) < 3) m
where d.department_id = m.department_id
order by d.department_id;

select d.department_id, d.department_name, count(*)
from employees e, departments d
where e.department_id = d.department_id
group by d.department_id, d.department_name
having count(*) < 3
order by d.department_id;

--inline view를 통해 join의 양을 줄일 수 있다

-- 문제 73번 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요.
select count(*) as TOTAL, count(decode(extract(year from hire_date), 2005, 1)) as "2005", count(decode(extract(year from hire_date), 2006, 1)) as "2006", count(decode(extract(year from hire_date), 2007, 1)) as "2007", count(decode(extract(year from hire_date), 2008, 1)) as "2008"
from employees;

select to_char(hire_date, 'yyyy'), count(*) from employees group by to_char(hire_date, 'yyyy');

select 
       decode(hire_year, '2001', people) as "2001",
       decode(hire_year, '2002', people) as "2002",
       decode(hire_year, '2003', people) as "2003",
       decode(hire_year, '2004', people) as "2004",
       decode(hire_year, '2005', people) as "2005",
       decode(hire_year, '2006', people) as "2006",
       decode(hire_year, '2007', people) as "2007",
       decode(hire_year, '2008', people) as "2008"
from (select to_char(hire_date, 'yyyy') hire_year, count(*) people from employees group by to_char(hire_date, 'yyyy'));

SELECT 
       max(decode(year,'2001',cn)) "2001",
       max(decode(year,'2002',cn)) "2002",
       max(decode(year,'2003',cn)) "2003",
       max(decode(year,'2004',cn)) "2004",   
       max(decode(year,'2005',cn)) "2005",
       max(decode(year,'2006',cn)) "2006",
       max(decode(year,'2007',cn)) "2007",
       max(decode(year,'2008',cn)) "2008"       
FROM (
              SELECT to_char(hire_date, 'yyyy') year, count(*) cn
              FROM employees
              GROUP BY(to_char(hire_date, 'yyyy')));

-- 문제 74 평균 급여가 가장 높은 부서의 부서 번호와 최고, 최저, 평균 급여를 출력하세요.
select department_id, max(salary), min(salary), avg(salary) as average
from employees
group by department_id
having avg(salary) = (select max(avg(salary)) from employees group by department_id);

-- 부서별 최고, 최저, 평균급여 테이블
select department_id, max(salary), min(salary), avg(salary) as average
from employees
group by department_id;

-- 최고 평균급여 테이블
select max(avg(salary)) from employees group by department_id;


-- 문제 75 사원 수가 가장 많은 부서이름, 도시, 인원수를 출력해주세요.
select d.department_name, l.city, e.cn
from (select department_id, count(*) cn from employees group by department_id having count(*) 
      = (select max(count(*)) from employees group by department_id)) e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id;      

-- 문제 76 사원 채용 수가 가장 많은 요일을 출력해주세요.
select to_char(hire_date, 'day'), count(*)
from employees
group by to_char(hire_date, 'day')
having count(*) = (select max(count(*)) from employees group by to_char(hire_date, 'day'));

-- 문제 77 사원 채용 수가 가장 많은 요일에 입사한 사원들의 last_name, 요일을 출력해주세요.
select last_name, to_char(hire_date, 'day')
from employees
where to_char(hire_date, 'day') in (select to_char(hire_date, 'day') from employees group by to_char(hire_date, 'day')
having count(*) = (select max(count(*)) from employees group by to_char(hire_date, 'day')));

-- 문제 78 부서별로 인원수를 출력주세요.
select 
       max(decode(department_id, '10', cn)) as "10",
       max(decode(department_id, '20', cn)) as "20",
       max(decode(department_id, '30', cn)) as "30",
       max(decode(department_id, '40', cn)) as "40",
       max(decode(department_id, '50', cn)) as "50",
       max(decode(department_id, '60', cn)) as "60",
       max(decode(department_id, '70', cn)) as "70",
       max(decode(department_id, '80', cn)) as "80",
       max(decode(department_id, '90', cn)) as "90",
       max(decode(department_id, '100', cn)) as "100",
       max(decode(department_id, '110', cn)) as "110",
       max(decode(department_id, null, cn)) as "부서가 없는 사원"
from (select department_id, count(*) cn from employees group by department_id);

-- 문제 79 부서 번호와 급여가 커미션을 받는 사원의 부서 번호 및 급여와 일치하는 모든  사원의 last_name, department_id, salary 를 표시하는 query 를 작성하세요.
select last_name, department_id, salary
from employees
where (department_id, salary) in (select department_id, salary from employees where commission_pct is not null);

--커미션을 받는 사원 테이블
select department_id, salary from employees where commission_pct is not null;

-- 문제 80 급여와 커미션이 location_id가 1700 에 있는 사원의 급여 및 커미션과 일치하는 사원의 last_name, department_name, salary를 출력해주세요.
select e.last_name, d.department_name, e.salary
from employees e join departments d
on e.department_id = d.department_id
where (salary, nvl(e.commission_pct, 0)) in (select e.salary, nvl(e.commission_pct, 0) from employees e, departments d where e.department_id = d.department_id and d.location_id = 1700);

-- location_id = 1700인 사원들의 급여와 커미션
select e.salary, nvl(e.commission_pct, 0) 
from employees e, departments d 
where e.department_id = d.department_id and d.location_id = 1700;

-- 문제 81 select department_id, department_name from departments where location_id = 1700
select last_name, hire_date, salary, commission_pct
from employees
where (salary, nvl(commission_pct, 0)) = (select salary, nvl(commission_pct, 0) from employees where last_name = 'Johnson')
and last_name not like 'Johnson';

-- Johnson의 급여와 커미션
select salary, commission_pct from employees where last_name = 'Johnson';

-- 문제 82 부서의 총 급여가 전체 부서의 평균 급여보다 많은 부서의 이름과 총 급여를 표시하도록 query를 작성하세요.
--null 부서 미포함
select d.department_name, sum(e.salary)
from employees e join departments d
on e.department_id = d.department_id
group by d.department_name
having sum(e.salary) > (select avg(dep_sum) from (select department_id, sum(salary) dep_sum from employees where department_id is not null group by department_id));

--null 부서 포함
select d.department_name, sum(e.salary)
from employees e join departments d
on e.department_id = d.department_id
group by d.department_name
having sum(salary) > (select avg(dep_sum) from (select department_id, sum(salary) dep_sum from employees group by department_id));

--null 부서 포함(선생님 답)
select d.department_name, e.average
from (select department_id, sum(salary) average from employees group by department_id having sum(salary) > (select avg(average) from (select sum(salary) average from employees group by department_id))) e, departments d
where e.department_id = d.department_id;

-- 전체 부서의 총급여 평균
select avg(dep_sum)
from (select department_id, sum(salary) dep_sum from employees where department_id is not null group by department_id);

-- 각 부서별 총급여
select department_id, sum(salary)
from employees
where department_id is not null
group by department_id;

--with: 재사용이 가능한 가상테이블 생성
with
dept_cost as (select d.department_name, sum(e.salary) as sumsal  from employees e, departments d where e.department_id = d.department_id(+) group by d.department_name), 
avg_cost as (select sum(sumsal) / count(*) as deptavg from dept_cost)
select *
from dept_cost
where sumsal > (select deptavg from avg_cost);

-- 문제 83  job_id가  ST_CLERK 을 포함하지 않는 부서에 대한 department_id를 출력해주세요.
SELECT department_id
FROM departments
WHERE department_id NOT IN (SELECT DISTINCT department_id FROM employees WHERE job_id = 'ST_CLERK');

-- 값의 존재/비존재 여부를 찾기 위해서는 correlated subquery를 사용하는 것이 적합하다
SELECT department_id
FROM departments d
WHERE NOT EXISTS (SELECT 'x' FROM employees WHERE department_id = d.department_id AND job_id = 'ST_CLERK');
  
-- job_id가 ST_CLERK인 사원을 가진 부서
SELECT DISTINCT department_id
FROM employees
WHERE job_id = 'ST_CLERK';

-- 문제 84 부서가 소재하지 않는 국가의 리스트가 필요합니다. 해당 국가의 country_id, country_name을 출력해주세요.
-- in / not in 사용
-- 부서가 있는 나라들의 테이블
select distinct country_id
from locations
where location_id in (select location_id from departments);

-- 전체 나라 테이블에서 부서가 있는 나라들을 제외한 테이블
select country_id, country_name
from countries
where country_id not in (select distinct country_id from locations l where location_id in (select location_id from departments));

-- exists / not exists 사용
--부서가 있는 나라들의 테이블
select distinct country_id
from locations l
where exists (select 'x' from departments where location_id = l.location_id);

-- 전체 나라 테이블에서 부서가 있는 나라들을 제외한 테이블
select country_id, country_name
from countries o
where not exists (select 'x' from locations l where exists (select 'x' from departments where location_id = l.location_id) and l.country_id = o.country_id);

-- 집합연산자 사용 / sort를 하게되고 동일한 테이블을 여러번 사용하게 됨
select country_id, country_name
from countries
minus
select l.country_id, c.country_name
from departments d, locations l, countries c
where l.country_id = c.country_id
and d.locations_id = l.location_id

--not exists 사용 / join을 잘 활용하자 / 1족 -> m족 비교
select country_id, country_name
from countries c
where not exists (select 'x' from locations l, departments d where d.location_id = l.location_id and l.country_id = c.country_id);

-- 문제 85 사원들의 employee_id, last_name, department_name을 출력하는데 소속부서가 없는 사원도 출력하시고, 소속사원이 없는 부서도 출력하세요. ANSI표준 조인, 오라클 전용 조인으로 만드세요.
--오라클
--department_id = null을 포함
select e.employee_id, e.last_name, d.department_name
from employees e, departments d
where e.department_id = d.department_id(+)
union all
--employee_id = null을 포함
select e.employee_id, e.last_name, d.department_name
from employees e, departments d
where e.department_id(+) = d.department_id
and e.department_id is null;


--ANSI표준
select e.employee_id, e.last_name, d.department_name
from employees e full outer join departments d
on e.department_id = d.department_id;

-- union all & not exists
select e.employee_id, e.last_name, d.department_name
from employees e, departments d
where e.department_id = d.department_id(+)
union all
select null, null, d.department_name
from departments d
where not exists (select 'x' from employees e where e.department_id = d.department_id); 

-- 문제 86 1,2,3,4를 한꺼번에 출력해주세요.
-- 1. department_id, job_id, manager_id 기준으로 총액 급여를 출력
-- 2. department_id, job_id 기준으로 총액급여출력
-- 3. department_id 기준으로 총액급여 출력
-- 4. 전체 총액 급여를 출력

select department_id, job_id, manager_id, sum(salary) Total
from employees
group by department_id, job_id, manager_id
union all
select department_id, job_id, null, sum(salary)
from employees
group by department_id, job_id
union all
select department_id, null, null, sum(salary)
from employees
group by department_id
union all
select null, null, null, sum(salary)
from employees
order by 1, 2, 3, 4;


-- 1. department_id, job_id, manager_id 기준으로 총액 급여를 출력
select department_id, job_id, manager_id, sum(salary)
from employees
group by department_id, job_id, manager_id;

-- 2. department_id, job_id 기준으로 총액급여출력
select department_id, job_id, null, sum(salary)
from employees
group by department_id, job_id;

-- 3. department_id 기준으로 총액급여 출력
select department_id, null, null, sum(salary)
from employees
group by department_id;

-- 4. 전체 총액 급여를 출력
select null, null, null, sum(salary)
from employees;

--roll up연산자
-- group by 절에서 지정한 열 리스트를 오른쪽에서 왼쪽으로 한 컬럼씩 줄여가며 그룹화
select department_id, job_id, manager_id, sum(salary)
from employees
group by rollup (department_id, job_id, manager_id);

--cube 연산자
-- group by 절에 지정된 가능한 모든 그룹화
select department_id, job_id, manager_id, sum(salary)
from employees
group by cube (department_id, job_id, manager_id);

group by rollup(a, b, c)
sum(sal) = {a, b, c}
sum(sal) = {a, b}
sum(sal) = {a}
sum(sal) = {}

group by cube(a, b, c)
sum(sal) = {a, b, c}
sum(sal) = {a, b}
sum(sal) = {a, c}
sum(sal) = {b, c}
sum(sal) = {a}
sum(sal) = {b}
sum(sal) = {c}
sum(sal) = {}

-- 문제 87 1, 2 한꺼본에 출력해주세요
-- 1. department_id, manager_id 기준 급여 총 합
-- 2. department_id, job_id 기준 급여 총 합
select department_id, manager_id, null, sum(salary)
from employees
group by department_id, manager_id
union all
select department_id, null, job_id, sum(salary)
from employees
group by department_id, job_id;

-- 1. department_id, manager_id 기준 급여 총 합
select department_id, manager_id, sum(salary)
from employees
group by department_id, manager_id;

-- 2. department_id, job_id 기준 급여 총 합
select department_id, job_id, sum(salary)
from employees
group by department_id, job_id;

--grouping sets 연산자
select department_id, job_id, manager_id, sum(salary)
from employees
group by grouping sets ((department_id, manager_id), (department_id, job_id), ());

-- 문제 88  년도별로 입사한 인원수, 전체 인원수를 출력해주세요
SELECT 
       max(decode(year,'2001',cn)) "2001",
       max(decode(year,'2002',cn)) "2002",
       max(decode(year,'2003',cn)) "2003",
       max(decode(year,'2004',cn)) "2004",   
       max(decode(year,'2005',cn)) "2005",
       max(decode(year,'2006',cn)) "2006",
       max(decode(year,'2007',cn)) "2007",
       max(decode(year,'2008',cn)) "2008",
       sum(cn) "총인원수"
FROM (
              SELECT to_char(hire_date, 'yyyy') year, count(*) cn
              FROM employees
              GROUP BY(to_char(hire_date, 'yyyy')));

-- rollup 활용              
SELECT 
       max(decode(year,'2001',cn)) "2001",
       max(decode(year,'2002',cn)) "2002",
       max(decode(year,'2003',cn)) "2003",
       max(decode(year,'2004',cn)) "2004",   
       max(decode(year,'2005',cn)) "2005",
       max(decode(year,'2006',cn)) "2006",
       max(decode(year,'2007',cn)) "2007",
       max(decode(year,'2008',cn)) "2008",
       max(decode(year,null,cn)) "총인원수"
FROM (
              SELECT to_char(hire_date, 'yyyy') year, count(*) cn
              FROM employees
              GROUP BY rollup(to_char(hire_date, 'yyyy')));

-- 문제 89 달별 입사한 인원수, 총인원수를 출력해주세요.
SELECT 
       max(decode(hire_month,01,cn)) "1월",
       max(decode(hire_month,02,cn)) "2월",
       max(decode(hire_month,03,cn)) "3월",
       max(decode(hire_month,04,cn)) "4월",
       max(decode(hire_month,05,cn)) "5월",
       max(decode(hire_month,06,cn)) "6월",
       max(decode(hire_month,07,cn)) "7월",
       max(decode(hire_month,08,cn)) "8월",
       max(decode(hire_month,09,cn)) "9월",
       max(decode(hire_month,10,cn)) "10월",
       max(decode(hire_month,11,cn)) "11월",
       max(decode(hire_month,12,cn)) "12월",
       sum(cn) "총인원수"
FROM (
              SELECT to_char(hire_date, 'mm') hire_month, count(*) cn
              FROM employees
              GROUP BY(to_char(hire_date, 'mm')));              
              
 -- rollup 활용   
 SELECT 
       max(decode(hire_month,01,cn)) "1월",
       max(decode(hire_month,02,cn)) "2월",
       max(decode(hire_month,03,cn)) "3월",
       max(decode(hire_month,04,cn)) "4월",
       max(decode(hire_month,05,cn)) "5월",
       max(decode(hire_month,06,cn)) "6월",
       max(decode(hire_month,07,cn)) "7월",
       max(decode(hire_month,08,cn)) "8월",
       max(decode(hire_month,09,cn)) "9월",
       max(decode(hire_month,10,cn)) "10월",
       max(decode(hire_month,11,cn)) "11월",
       max(decode(hire_month,12,cn)) "12월",
       max(decode(hire_month,null,cn)) "총인원수"
FROM (SELECT to_char(hire_date, 'mm') hire_month, count(*) cn
      FROM employees
      GROUP BY rollup(to_char(hire_date, 'mm')));   
      
-- to_char(hire_date, 'month')로 나온 1자리 월 뒤에는 공백 1칸이 있다      
 SELECT 
       max(decode(hire_month,'1월 ',cn)) "1월",
       max(decode(hire_month,'2월 ',cn)) "2월",
       max(decode(hire_month,'3월 ',cn)) "3월",
       max(decode(hire_month,'4월 ',cn)) "4월",
       max(decode(hire_month,'5월 ',cn)) "5월",
       max(decode(hire_month,'6월 ',cn)) "6월",
       max(decode(hire_month,'7월 ',cn)) "7월",
       max(decode(hire_month,'8월 ',cn)) "8월",
       max(decode(hire_month,'9월 ',cn)) "9월",
       max(decode(hire_month,'10월',cn)) "10월",
       max(decode(hire_month,'11월',cn)) "11월",
       max(decode(hire_month,'12월',cn)) "12월",
       max(decode(hire_month,null,cn)) "총인원수"
FROM (SELECT to_char(hire_date, 'month') hire_month, count(*) cn
      FROM employees
      GROUP BY rollup(to_char(hire_date, 'month')));         
      
SELECT to_char(hire_date, 'month') hire_month, count(*) cn
FROM employees
GROUP BY rollup(to_char(hire_date, 'month'));

--문제 90 새로운 user를 생성하세요
-- 유저이름: insa default tablespace : users temporary tablespace : temp 	users tablespace 사용량 : 1m

create user insa
identified by oracle
default tablespace users
temporary tablespace temp
quota 1m on users;

select * from dba_sys_privs where grantee = 'insa';

-- 문제 91 insa유저에게 create session, create table 시스템 권한을 부여해주세요
grant create session, create table to insa;

-- 문제 92 insa 유저가 사용할 수 있는 users tablespace quota 값을 unlimited로 수정하세요
alter user insa
quota unlimited on users;

select * from dba_ts_quotas;
select * from user_ts_quotas;

-- 문제 93 hr유저가 소유한 employees 테이블의 select 객체 권한을 insa유저에게 부여해 주세요
grant select on hr.employees to insa;

--회수
revoke select on hr.employees from insa;

-- 문제 94 hr유저가 소유한 departments 테이블의 select 객체 권한을 insa유저에게 부여해주세요
grant select on hr.departments to insa;

-- 문제 95  insa 유저는 테이블논리적설계.pdf에 ERD(Entity Relationship Diagram)을 확인 한후 table instance chart를  보면서 테이블을 구성하세요.

create table dept
(dept_id number(3) constraint dept_id_pk primary key,
 dept_name varchar2(50) constraint dept_nn not null 
                        constraint dept_uk unique,
 mgr number(5));
 
 create table emp
 (id number(5) constraint emp_id_pk primary key,
  name varchar2(50) constraint emp_name_nn not null,
  hire_date date constraint emp_date_nn not null,
  sal number(8, 2) constraint emp_sal_ck check(sal > 100),
  mgr number(5),
  dept_id number(3),
  constraint emp_dept_id_fk foreign key(dept_id) references dept(dept_id),
  constraint emp_mgr_fk foreign key(mgr) references emp(id));
  
  desc emp;
  desc dept;

/* [문제96] hr.departments 테이블의 department_id, department_name, manager_id 데이터를 
insa 유저의 dept 테이블로 insert 한후 영구히 저장하세요. */
drop table dept purge;
select * from user_constraints where table_name = 'DEPT';

alter table dept
drop primary key cascade;

create table dept
as select department_id, department_name, manager_id from hr.departments;

select * from dept;

commit;

/* [문제97] hr.employees 테이블의 employee_id, last_name, hire_date, salary, manager_id, 
department_id 데이터를 insa 유저의 emp 테이블로 insert 한후 영구히 저장하세요. */
select * from emp;
desc emp;
drop table emp purge;

create table emp
as select employee_id, last_name, hire_date, salary, manager_id, department_id from hr.employees where 1=2;

select * from user_tab_privs;

insert all
into emp(employee_id, last_name, hire_date, salary, manager_id, department_id) values(employee_id, last_name, hire_date, salary, manager_id, department_id)
select * from hr.employees;

rollback;

insert into emp(employee_id, last_name, hire_date, salary, manager_id, department_id)
select employee_id, last_name, hire_date, salary, manager_id, department_id
from hr.employees;

commit;

/* [문제98] insa유저의 dept 테이블의 부서정보 중에 소속사원이 없는 부서정보를 삭제한 후 영구히 저장하세요. */
delete from dept d
where not exists(select 'x' from emp where department_id = d.department_id);

commit;

/* [문제99] 사원들 중에 근무연수가 15년 이상 이면서 급여는 10000이상 급여를 받는 사원들은 emp_1테이블에 
사번, 이름, 입사일, 근무연수,  급여 정보를 입력하고 근무연수가 15년 이상이면서 급여는 10000미만 급여를 
받는 사원들은 emp_2테이블에 사번, 이름, 입사일, 근무연수, 급여 정보를 입력하세요. */
create table emp_1
(employee_id number,
 last_name varchar2(20) constraint emp1_name_nn not null,
 hire_date date,
 work_year number,
 salary number constraint emp1_salary_nn not null,
 constraint emp1_id_pk primary key(employee_id))
tablespace users;
desc emp_1

create table emp_2
as select * from emp_1 where 1=2;
desc emp_2;

insert first
when work_year >= 15 and salary >= 10000 then
into emp_1(employee_id, last_name, hire_date, work_year, salary) values(employee_id, last_name, hire_date, work_year, salary)
when work_year >= 15 and salary < 10000 then
into emp_2(employee_id, last_name, hire_date, work_year, salary) values(employee_id, last_name, hire_date, work_year, salary)
select employee_id, last_name, hire_date, (months_between(sysdate, hire_date)/ 12) as work_year, salary from employees;

select * from emp_1;
select * from emp_2;


-- 문제 100 EMPLOYEES 테이블을 복제 EMP_COPY 이름으로 복제하세요.
create table emp_copy
as select * from hr.employees;
-- CTAS로 복제시 not null 제약조건만 복제된다.

--문제 101 EMP_COPY테이블에 employee_id에 emp_copy_id_pk 이름으로 primary key 제약조건을 추가하세요. 
alter table emp_copy
add constraints emp_id_pk primary key(employee_id);
	
--문제 102 EMP_COPY 테이블에 department_name varchar2(30) 컬럼을 추가하세요.
alter table emp_copy
add department_name varchar2(30);

--문제 103 DEPARTMENTS 테이블에 있는 department_name을 기준으로 EMP_COPY 테이블에 department_name에 값을 수정하세요.
--단 UPDATE문을 이용해서 해결한 후 수정된 정보를 확인하고 ROLLBACK 하세요.
update emp_copy e
set department_name = (select department_name from departments where department_id = e.department_id);

select department_id, department_name from emp_copy;	

rollback;

select department_id, department_name from emp_copy;	

--문제 104 DEPARTMENTS 테이블에 있는 department_name을 기준으로 EMP_COPY 테이블에 department_name에 값을 수정하세요.
--단 MERGE문을 이용해서 해결한 후  수정된 정보를 영구히 저장하세요.
merge into emp_copy e
using (select department_id, department_name from departments) d
on (e.department_id = d.department_id)
when matched then
update set e.department_name = d.department_name;

select department_id, department_name from emp_copy;

commit;

--문제 105 EMP_COPY 테이블에 department_name에 값을 NULL 값으로 수정하세요. 
--단 MERGE문을 이용해서 해결한 후 ROLLBACK 하세요.
merge into emp_copy e
using (select department_id from departments) d
on (e.department_id = d.department_id)
when matched then
update set e.department_name = null;

select department_name from emp_copy;

rollback;

select department_name from emp_copy;

-- 문제 106 사원들의 급여가 5000 미만일 경우 employee_id, salary 정보를 SPECIAL_SAL 테이블에 입력하고 
--아니면 employee_id, hire_date, salary정보를 SAL_HISTORY 테이블에 입력하고 
--또는  employee_id, manager_id, salary 정보를  MGR_HISTORY 테이블에 입력한다.

create table special_sal
(employee_id number,
 salary number)
 tablespace users;
  
create table sal_history
(employee_id number,
 hire_date date,
 salary number);
  
create table mgr_history
(employee_id number,
 manager_id number,
 salary number);
 
insert all
when sal < 5000 then
into special_sal(employee_id, salary) values (empid, sal)
else
into sal_history(employee_id, hire_date, salary) values (empid, hiredate, sal)
into mgr_history(employee_id, manager_id, salary) values (empid, mgrid, sal)
select employee_id as empid, salary as sal, hire_date as hiredate, manager_id as mgrid from employees;
 
select * from special_sal;
select * from sal_history;
select * from mgr_history;

--다른 답
insert first
when sal < 5000 then
into special_sal(employee_id, salary) values (empid, sal)
else
into sal_history(employee_id, hire_date, salary) values(empid, hiredate, sal)
into mgr_history(employee_id, manager_id, salary) values(empid, mgrid, sal)
select employee_id as empid, salary as sal, hire_date as hiredate, manager_id as mgrid from employees;

--문제 107 emp.csv 파일의 데이터를 분석하려고 한다. external table를 생성하세요.
--권한 확인
select * from user_tab_privs where table_name = 'DATA_DIR';
select * from all_directories where directory_name = 'DATA_DIR';

-- external table은 dml사용 불가(읽기 전용) / index 없음
create table empxt
(id number,
 name varchar2(30),
 hire_date date,
 job_id varchar2(20),
 department_id number)
 organization external
 (type oracle_loader
  default directory data_dir
  access parameters
   (records delimited by newline -- 한행의 끝은 문서의 끝이 아니라 새로운 줄이 있음.
    badfile 'empxt.bad'
    logfile 'empxt.log'
    fields terminated by ',' -- 필드 구분자
    missing field values are null -- 빈 값을 대체하여 null 입력
     (id, name, hire_date char date_format date mask "YYYYMMDD", job_id, department_id))
  location('emp.csv'))
reject limit unlimited; --오류 허용 / 거의 필수적

-- 주석이 달려있으면 실행 시 오류 발생
create table empxt
(id number,
 name varchar2(30),
 hire_date date,
 job_id varchar2(20),
 department_id number)
 organization external
 (type oracle_loader
  default directory data_dir
  access parameters
   (records delimited by newline
    badfile 'empxt.bad'
    logfile 'empxt.log'
    fields terminated by ','
    missing field values are null
     (id, name, hire_date char date_format date mask "YYYYMMDD", job_id, department_id))
  location('emp.csv'))
reject limit unlimited;

select * from empxt;

-- 문제 108 부서이름별 총액급여, 평균급여, 최고급여, 최저급여를 출력하는 query문을 작성한 후, dept_sal_vw view를 생성하세요.
create or replace view dept_sal_vw
as select d.department_name, sum(e.salary) as sumsal, avg(e.salary) as avgsal, max(e.salary) as maxsal, min(e.salary) as minsal from employees e join departments d on e.department_id = d.department_id group by d.department_name;

create or replace view dept_sal_vw
as select d.department_name, e.sumsal, e.avgsal, e.maxsal, e.minsal from departments d join (select department_id, sum(salary) as sumsal, avg(salary) as avgsal, max(salary) as maxsal, min(salary) as minsal from employees group by department_id) e on d.department_id = e.department_id;

select * from dept_sal_vw;

-- [문제109] emp 테이블을 생성한 후 통계정보를 확인 한후 통계수집을 하세요.
drop table emp purge;
create table emp
as select * from employees;

-- 통계정보 확인
select *
from user_tables
where table_name = 'EMP';

-- 통계정보 수집 no_invalidate 는 invalidation을 즉시하지 않겠다는 옵션
exec dbms_stats.gather_table_stats('hr', 'emp', no_invalidate => False);


-- [문제110] select문의 실행계획을 확인 한 후 filter를 access로 해결해 주세요.
select * from emp where employee_id = 100;

-- 실행계획을 plan_table에 저장
explain plan for select * from emp where employee_id = 100;

-- dbms_stats을 활용하여 실행계획을 보기좋게 확인
select * from table(dbms_xplan.display(null, null, 'typical'));

-- employee_id에 index를 걸어주자
-- PK만들기
alter table emp add constraint emp_id_pk primary key(employee_id);
-- 삭제
alter table emp drop constraint emp_id_pk;

-- unique index만들기
create unique index emp_id_unq_idx on emp(employee_id);
-- 삭제
drop index emp_id_unq_idx;


-- [문제111] select문의 실행계획을 확인 한 후 filter를 access로 해결해 주세요.
select * from emp where department_id = 10;

-- 실행계획을 테이블에 저장
explain plan for select * from emp where department_id = 10;

-- 실행계획을 확인
select * from table(dbms_xplan.display(null, null, 'typical'));

-- 중복값과 null값이 있어 PK는 불가
-- index 만들기
create index emp_dpid_idx on emp(department_id);

select * from user_ind_columns where table_name = 'EMP';


-- [문제112] select문의 실행계획을 확인 한 후 filter를 access로 해결해 주세요.
select * from emp where last_name = 'King' and first_name = 'Steven';

-- 실행계획 테이블에 저장
explain plan for select * from emp where last_name = 'King' and first_name = 'Steven';

-- xplan 으로 확인
select * from table(dbms_xplan.display(null, null, 'typical'));

-- composite index 생성
create index emp_lname_fname_idx on emp(last_name, first_name);

-- [문제113] emp 테이블의 통계 수집을 한 후 전체 row의 수, 사용한 block수, 한 행의 평균 byte 값을 확인 해주세요.
drop table emp  purge;

create table emp as
select rownum emp_id, last_name, first_name, job_id, hire_date, salary, commission_pct, email, department_id
from employees, (select rownum emp_id from dual connect by level < = 100) -- 100개의 emp_id 생성
order by dbms_random.value;  -- 데이터를 랜덤한 순서로 입력

-- 통계정보 수집
exec dbms_stats.gather_table_stats('hr', 'emp', no_invalidate => False);

-- 통계정보 확인
select num_rows, blocks, avg_row_len from user_tables where table_name = 'EMP';

-- 통계정보가 없을때 확인하는 방법
select bytes, blocks, extents from user_segments where segment_name = 'EMP';
select extent_id, bytes, blocks from user_extents where segment_name = 'EMP';


/* [문제114] hr 유저는 sql문을 수행 한 후 실제 수행한 실행계획 처리한 블록의 수를 확인하기위해서 
dbms_xplan.display_cursor 사용하려고 할때 필요한 권한은 작성해 주세요. */

grant select on v_$session to hr;
grant select on v_$sql to hr;
grant select on v_$sql_plan to hr;
grant select on v_$sql_plan_statistics to hr;
grant select on v_$sql_plan_statistics_all to hr;


-- [문제115]이 쿼리문장을 튜닝하기 전과 튜닝한 후를  비교해주세요.
select * from emp where emp_id = 100; 

-- 튜닝전
select /*+ gather_plan_statistics */ * from emp where emp_id = 100;
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SQL_ID  88qdck3u5mvqh, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ * from emp where emp_id = 100
 
Plan hash value: 3956160932
 
------------------------------------------------------------------------------------
| Id  | Operation         | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |      1 |        |      1 |00:00:00.01 |      84 |
|*  1 |  TABLE ACCESS FULL| EMP  |      1 |      1 |      1 |00:00:00.01 |      84 |
------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter("EMP_ID"=100);
  
-- 튜닝
-- index생성
alter table emp add constraint emp_id_pk primary key(emp_id);

-- index확인
select ix.index_name, ix.uniqueness, ic.column_name from user_indexes ix, user_ind_columns ic 
where ix.index_name = ic.index_name and ix.table_name = 'EMP';
  
-- 결과 확인
select /*+ gather_plan_statistics */ * from emp where emp_id = 100;
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
 
SQL_ID  88qdck3u5mvqh, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ * from emp where emp_id = 100
 
Plan hash value: 1252232671
 
---------------------------------------------------------------------------------------------------
| Id  | Operation                   | Name      | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |           |      1 |        |      1 |00:00:00.01 |       3 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP       |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  2 |   INDEX UNIQUE SCAN         | EMP_ID_PK |      1 |      1 |      1 |00:00:00.01 |       2 |
---------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("EMP_ID"=100);

-- [문제116] 이 쿼리문장을 튜닝하기 전과 튜닝한 후를  비교해주세요.
sql> select count(*) from emp where last_name = 'King';

-- 튜닝 전
select /*+ gather_plan_statistics */ count(*) from emp where last_name = 'King';
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SQL_ID  86z65hnkrghr2, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where last_name 
= 'King'
 
Plan hash value: 2083865914
 
-------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |        |      1 |00:00:00.01 |      84 |
|   1 |  SORT AGGREGATE    |      |      1 |      1 |      1 |00:00:00.01 |      84 |
|*  2 |   TABLE ACCESS FULL| EMP  |      1 |    105 |    200 |00:00:00.01 |      84 |
-------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter("LAST_NAME"='King');
   
-- 튜닝
create index emp_last_idx on emp(last_name);

-- index 확인
select ix.index_name, ix.uniqueness, ic.column_name from user_indexes ix, user_ind_columns ic
where ix.index_name = ic.index_name and ix.table_name = 'EMP';

-- 결과 확인
-- *group 관련 함수가 사용될 시 sort aggregate operation이 등장(실제 sort가 된 것이 아님, sort작동시 메모리 사용량이 표기됨)
select /*+ gather_plan_statistics */ count(*) from emp where last_name = 'King';
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SQL_ID  86z65hnkrghr2, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where last_name 
= 'King'
 
Plan hash value: 3683339819
 
--------------------------------------------------------------------------------------------
| Id  | Operation         | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |              |      1 |        |      1 |00:00:00.01 |       3 |
|   1 |  SORT AGGREGATE   |              |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  2 |   INDEX RANGE SCAN| EMP_LAST_IDX |      1 |    105 |    200 |00:00:00.01 |       3 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("LAST_NAME"='King');
   
-- [문제117] 이 쿼리문장을 튜닝하기 전과 튜닝한 후를  비교해주세요.
select count(*) from emp where last_name = 'King' and first_name = 'Steven';

-- 튜닝 전
select /*+ gather_plan_statistics */ count(*) from emp where last_name = 'King' and first_name = 'Steven';
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

-- 결과
SQL_ID  7x1fvprxgs8gj, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where last_name 
= 'King' and first_name = 'Steven'
 
Plan hash value: 2083865914
 
-------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |        |      1 |00:00:00.01 |      84 |
|   1 |  SORT AGGREGATE    |      |      1 |      1 |      1 |00:00:00.01 |      84 |
|*  2 |   TABLE ACCESS FULL| EMP  |      1 |      1 |    100 |00:00:00.01 |      84 |
-------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(("LAST_NAME"='King' AND "FIRST_NAME"='Steven'));
   
-- 튜닝
create index emp_last_first_idx on emp(last_name, first_name);

-- 결과 확인
select /*+ gather_plan_statistics */ count(*) from emp where last_name = 'King' and first_name = 'Steven';
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SQL_ID  7x1fvprxgs8gj, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where last_name 
= 'King' and first_name = 'Steven'
 
Plan hash value: 2071372003
 
--------------------------------------------------------------------------------------------------
| Id  | Operation         | Name               | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |                    |      1 |        |      1 |00:00:00.01 |       3 |
|   1 |  SORT AGGREGATE   |                    |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  2 |   INDEX RANGE SCAN| EMP_LAST_FIRST_IDX |      1 |    100 |    100 |00:00:00.01 |       3 |
--------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("LAST_NAME"='King' AND "FIRST_NAME"='Steven');
   
-- [문제118] emp 테이블에 있는 데이터 중에 2001년도 입사한 사원들의 인원수를 조회하는 쿼리문장을 만드시고 성능이 나도록 구성하세요.
-- 쿼리문
select /*+ gather_plan_statistics */ count(*) from emp where to_char(hire_date, 'yyyy') = 2001;
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

-- 결과확인
SQL_ID  2w293rjasahha, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where 
to_char(hire_date, 'yyyy') = 2001
 
Plan hash value: 2083865914
 
-------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |        |      1 |00:00:00.01 |      84 |
|   1 |  SORT AGGREGATE    |      |      1 |      1 |      1 |00:00:00.01 |      84 |
|*  2 |   TABLE ACCESS FULL| EMP  |      1 |    107 |    100 |00:00:00.01 |      84 |
-------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(TO_NUMBER(TO_CHAR(INTERNAL_FUNCTION("HIRE_DATE"),'yyyy'))=2001);
   
-- 튜닝
create index emp_hire_idx on emp(hire_date);
   
-- 확인
 select /*+ gather_plan_statistics */ count(*) from emp where to_char(hire_date, 'yyyy') = 2001;
 select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
   
   SQL_ID  2w293rjasahha, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where 
to_char(hire_date, 'yyyy') = 2001
 
Plan hash value: 1197236117
 
------------------------------------------------------------------------------------------------
| Id  | Operation             | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |              |      1 |        |      1 |00:00:00.01 |      34 |
|   1 |  SORT AGGREGATE       |              |      1 |      1 |      1 |00:00:00.01 |      34 |
|*  2 |   INDEX FAST FULL SCAN| EMP_HIRE_IDX |      1 |    107 |    100 |00:00:00.01 |      34 |
------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(TO_NUMBER(TO_CHAR(INTERNAL_FUNCTION("HIRE_DATE"),'yyyy'))=2001);
   
 -- 튜닝
 select /*+ gather_plan_statistics */ count(*) from emp where hire_date between to_date('20010101', 'yyyymmdd') and to_date('20011231 23:59:59', 'yyyymmdd hh24:mi:ss');
   
 -- 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
SQL_ID  08t760mp3j576, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where hire_date 
between to_date('20010101', 'yyyymmdd') and to_date('20011231 
23:59:59', 'yyyymmdd hh24:mi:ss')
 
Plan hash value: 2664633226
 
--------------------------------------------------------------------------------------------
| Id  | Operation         | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |              |      1 |        |      1 |00:00:00.01 |       2 |
|   1 |  SORT AGGREGATE   |              |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  2 |   INDEX RANGE SCAN| EMP_HIRE_IDX |      1 |   1532 |    100 |00:00:00.01 |       2 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("HIRE_DATE">=TO_DATE(' 2001-01-01 00:00:00', 'syyyy-mm-dd 
              hh24:mi:ss') AND "HIRE_DATE"<=TO_DATE(' 2001-12-31 23:59:59', 'syyyy-mm-dd 
              hh24:mi:ss'));

/* [문제119] emp 테이블에 있는 데이터 중에 2003년도 입사한 사원들 중에 
10번 부서 인원수를 조회하는 쿼리문장을 만드시고 성능이 나도록 구성하세요. */
-- 쿼리문장
select /*+ gather_plan_statistics */ count(*) from emp where department_id = 10 and to_char(hire_date, 'yyyy') = 2003;

-- 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
SQL_ID  c9juby1p74g0w, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where 
department_id = 10 and to_char(hire_date, 'yyyy') = 2003
 
Plan hash value: 2083865914
 
-------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |        |      1 |00:00:00.01 |      84 |
|   1 |  SORT AGGREGATE    |      |      1 |      1 |      1 |00:00:00.01 |      84 |
|*  2 |   TABLE ACCESS FULL| EMP  |      1 |     10 |    100 |00:00:00.01 |      84 |
-------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(("DEPARTMENT_ID"=10 AND TO_NUMBER(TO_CHAR(INTERNAL_FUNCTION("HI
              RE_DATE"),'yyyy'))=2003));

-- 튜닝
create index emp_dept_hire_idx on emp(department_id, hire_date);
select /*+ gather_plan_statistics */ count(*) from emp where department_id = 10 and hire_date between to_date('20030101', 'yyyymmdd') and to_date('20031231', 'yyyymmdd');

-- 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SQL_ID  7wcp52bq64qb5, child number 1
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where 
department_id = 10 and hire_date between to_date('20030101', 
'yyyymmdd') and to_date('20031231', 'yyyymmdd')
 
Plan hash value: 2210979594
 
----------------------------------------------------------------------------------------------------------
| Id  | Operation         | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |                   |      1 |        |      1 |00:00:00.01 |       2 |      4 |
|   1 |  SORT AGGREGATE   |                   |      1 |      1 |      1 |00:00:00.01 |       2 |      4 |
|*  2 |   INDEX RANGE SCAN| EMP_DEPT_HIRE_IDX |      1 |    152 |    100 |00:00:00.01 |       2 |      4 |
----------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("DEPARTMENT_ID"=10 and "HIRE_DATE">=to_date(' 2003-01-01 00:00:00', 'syyyy-mm-dd 
              hh24:mi:ss') AND "HIRE_DATE"<=TO_DATE(' 2003-12-31 00:00:00', 'syyyy-mm-dd hh24:mi:ss'));
 
-- [문제120] 아래 쿼리문장을 문제118번에서 만든 인덱스를 사용할때와  문제119번에 만든 인덱스를 사용할때를 비교하세요.
select count(*) from emp where hire_date >= to_date('2001-01-01','yyyy-mm-dd') and hire_date < to_date('2002-01-01','yyyy-mm-dd');

-- 118번 인덱스 사용
select /*+ index(e emp_hire_idx) gather_plan_statistics */count(*) from emp e where hire_date >= to_date('2001-01-01','yyyy-mm-dd') and hire_date < to_date('2002-01-01','yyyy-mm-dd');

-- 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
SQL_ID  91cq60xhsbmrm, child number 0
-------------------------------------
select /*+ index(e emp_hire_idx) gather_plan_statistics */count(*) from 
emp e where hire_date >= to_date('2001-01-01','yyyy-mm-dd') and 
hire_date < to_date('2002-01-01','yyyy-mm-dd')
 
Plan hash value: 2664633226
 
--------------------------------------------------------------------------------------------
| Id  | Operation         | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |              |      1 |        |      1 |00:00:00.01 |       2 |
|   1 |  SORT AGGREGATE   |              |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  2 |   INDEX RANGE SCAN| EMP_HIRE_IDX |      1 |   1423 |    100 |00:00:00.01 |       2 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("HIRE_DATE">=TO_DATE(' 2001-01-01 00:00:00', 'syyyy-mm-dd 
              hh24:mi:ss') AND "HIRE_DATE"<TO_DATE(' 2002-01-01 00:00:00', 'syyyy-mm-dd 
              hh24:mi:ss'));

-- 119번 인덱스 사용
select /*+ index(e emp_dept_hire_idx) gather_plan_statistics */count(*) from emp e where hire_date >= to_date('2001-01-01','yyyy-mm-dd') and hire_date < to_date('2002-01-01','yyyy-mm-dd');

-- 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
SQL_ID  gnk1h7npttywd, child number 0
-------------------------------------
select /*+ index(e emp_dept_hire_idx) gather_plan_statistics */count(*) 
from emp e where hire_date >= to_date('2001-01-01','yyyy-mm-dd') and 
hire_date < to_date('2002-01-01','yyyy-mm-dd')
 
Plan hash value: 4120062356
 
------------------------------------------------------------------------------------------------
| Id  | Operation        | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |                   |      1 |        |      1 |00:00:00.01 |      10 |
|   1 |  SORT AGGREGATE  |                   |      1 |      1 |      1 |00:00:00.01 |      10 |
|*  2 |   INDEX SKIP SCAN| EMP_DEPT_HIRE_IDX |      1 |   1423 |    100 |00:00:00.01 |      10 |
------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("HIRE_DATE">=TO_DATE(' 2001-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') 
              AND "HIRE_DATE"<TO_DATE(' 2002-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
       filter(("HIRE_DATE"<TO_DATE(' 2002-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') 
              AND "HIRE_DATE">=TO_DATE(' 2001-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss')));

-- [문제121] 쿼리문장을 확인하시고 튜닝하세요.
select /*+ gather_plan_statistics */ count(*) from emp where substr(last_name,1,2) = 'Ba';
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SQL_ID  5nbvsbgw8vr13, child number 1
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where 
substr(last_name,1,2) = 'Ba'
 
Plan hash value: 2621427937
 
------------------------------------------------------------------------------------------------
| Id  | Operation             | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |              |      1 |        |      1 |00:00:00.01 |      32 |
|   1 |  SORT AGGREGATE       |              |      1 |      1 |      1 |00:00:00.01 |      32 |
|*  2 |   INDEX FAST FULL SCAN| EMP_LAST_IDX |      1 |    107 |    400 |00:00:00.01 |      32 |
------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(substr("LAST_NAME",1,2)='Ba');

-- 튜닝
select /*+ gather_plan_statistics */ count(*) from emp where last_name like 'Ba%';
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SQL_ID  9cczzv7pp4kzx, child number 0
-------------------------------------
select /*+ gather_plan_statistics */ count(*) from emp where last_name 
like 'Ba%'
 
Plan hash value: 3683339819
 
--------------------------------------------------------------------------------------------
| Id  | Operation         | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |              |      1 |        |      1 |00:00:00.01 |       3 |
|   1 |  SORT AGGREGATE   |              |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  2 |   INDEX RANGE SCAN| EMP_LAST_IDX |      1 |    107 |    400 |00:00:00.01 |       3 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("LAST_NAME" like 'Ba%')
       filter("LAST_NAME" LIKE 'Ba%');

drop table emp purge;
create table emp as select * from employees;

drop table dept purge;
create table dept as select * from departments;

create table loc as select * from locations;

-- [문제122] 테이블 통계 수집을 하시고 컬럼 정보를 확인 하세요.
-- 통계정보 수집
exec dbms_stats.gather_table_stats('hr', 'emp');
exec dbms_stats.gather_table_stats('hr', 'dept');
exec dbms_stats.gather_table_stats('hr', 'loc');

-- 통계정보 확인
select table_name, num_rows, blocks, avg_row_len, last_analyzed from user_tables where table_name in('EMP','DEPT','LOC');

/*
TABLE_NAME                                                     NUM_ROWS     BLOCKS AVG_ROW_LEN LAST_ANA
------------------------------------------------------------ ---------- ---------- ----------- --------
DEPT                                                                 27          4          21 18/06/27
EMP                                                                 107          5          69 18/06/27
loc                                                                  23          4          49 18/06/27
*/


-- [문제123] SQL문장의 실행계획을 확인 한 후 nested loop join 으로 튜닝하세요.
-- 실행계획 확인
alter session set statistics_level = all;

select e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and e.employee_id = 100;

select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
/*
-------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
-------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |      |      1 |        |      1 |00:00:00.01 |       7 |       |       |          |
|*  1 |  HASH JOIN            |      |      1 |      1 |      1 |00:00:00.01 |       7 |   927K|   927K| 1271K (0)|
|   2 |   MERGE JOIN CARTESIAN|      |      1 |     23 |     23 |00:00:00.01 |       5 |       |       |          |
|*  3 |    TABLE ACCESS FULL  | EMP  |      1 |      1 |      1 |00:00:00.01 |       3 |       |       |          |
|   4 |    BUFFER SORT        |      |      1 |     23 |     23 |00:00:00.01 |       2 |  2048 |  2048 | 2048  (0)|
|   5 |     TABLE ACCESS FULL | LOC  |      1 |     23 |     23 |00:00:00.01 |       2 |       |       |          |
|   6 |   TABLE ACCESS FULL   | DEPT |      1 |     27 |     27 |00:00:00.01 |       2 |       |       |          |
-------------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID" AND "D"."LOCATION_ID"="L"."LOCATION_ID")
   3 - filter("E"."EMPLOYEE_ID"=100)
*/

select * from user_indexes where table_name in ('EMP', 'DEPT', 'LOC');

-- 문제확인: employee_id가 filter로 풀림 / table full scan
-- 튜닝: e.employee_id, d.department_id, l.location_id에 pk를 걸고 emp를 outer로 nl join
alter table emp add constraint emp_id_pk primary key(employee_id);
alter table dept add constraint dept_deptid_pk primary key(department_id);
alter table loc add constraint loc_locid_pk primary key(location_id);

-- 제약조건 확인
select a.constraint_name, b.column_name, a.constraint_type, a.search_condition, a.r_constraint_name, a.index_name
from user_constraints a, user_cons_columns b
where a.constraint_name = b.constraint_name
and a.table_name = 'EMP';

-- 인덱스 확인
select ix.index_name, ix.uniqueness, ic.column_name from user_indexes ix, user_ind_columns ic 
where ix.index_name = ic.index_name and ix.table_name = 'EMP';

select /*+ leading(e, d, l) use_nl(d) use_nl(l) */ e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and e.employee_id = 100;

-- 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
/*
----------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                |      1 |        |      1 |00:00:00.01 |       6 |
|   1 |  NESTED LOOPS                 |                |      1 |      1 |      1 |00:00:00.01 |       6 |
|   2 |   NESTED LOOPS                |                |      1 |      1 |      1 |00:00:00.01 |       4 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP            |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  4 |     INDEX UNIQUE SCAN         | EMP_ID_PK      |      1 |      1 |      1 |00:00:00.01 |       1 |
|   5 |    TABLE ACCESS BY INDEX ROWID| DEPT           |      1 |     27 |      1 |00:00:00.01 |       2 |
|*  6 |     INDEX UNIQUE SCAN         | DEPT_DEPTID_PK |      1 |      1 |      1 |00:00:00.01 |       1 |
|   7 |   TABLE ACCESS BY INDEX ROWID | LOC            |      1 |     23 |      1 |00:00:00.01 |       2 |
|*  8 |    INDEX UNIQUE SCAN          | LOC_LOCID_PK   |      1 |      1 |      1 |00:00:00.01 |       1 |
----------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - access("E"."EMPLOYEE_ID"=100)
   6 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   8 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
  */
  
-- [문제124] SQL문장의 실행계획을 확인 한 후 NESTED LOOP JOIN으로 튜닝하세요.

-- 실행계획 확인
select e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'; 

select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

/*
-----------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
-----------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |              |      1 |        |     18 |00:00:00.01 |       7 |       |       |          |
|*  1 |  HASH JOIN                    |              |      1 |     15 |     18 |00:00:00.01 |       7 |   972K|   972K| 1241K (0)|
|   2 |   MERGE JOIN                  |              |      1 |      4 |     21 |00:00:00.01 |       4 |       |       |          |
|*  3 |    TABLE ACCESS BY INDEX ROWID| LOC          |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
|   4 |     INDEX FULL SCAN           | LOC_LOCID_PK |      1 |     23 |     23 |00:00:00.01 |       1 |       |       |          |
|*  5 |    SORT JOIN                  |              |      1 |     27 |     21 |00:00:00.01 |       2 |  2048 |  2048 | 2048  (0)|
|   6 |     TABLE ACCESS FULL         | DEPT         |      1 |     27 |     27 |00:00:00.01 |       2 |       |       |          |
|   7 |   TABLE ACCESS FULL           | EMP          |      1 |    107 |    107 |00:00:00.01 |       3 |       |       |          |
-----------------------------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   3 - filter("L"."CITY"='Seattle')
   5 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
*/

-- 문제확인: l.city이 filter로 풀림
-- 튜닝: l.city, d.location_id, e.department_id 에 index를 걸고 loc를 outer로 nl join
create unique index loc_city_idx on loc(city);
create index dept_locid_idx on dept(location_id);
create index emp_deptid_idx on emp(department_id);

select /*+ leading(l, d, e) use_nl(d) use_nl(e) */ e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'; 

-- 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
/*
-----------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                |      1 |        |     18 |00:00:00.01 |      10 |
|   1 |  NESTED LOOPS                  |                |      1 |        |     18 |00:00:00.01 |      10 |
|   2 |   NESTED LOOPS                 |                |      1 |     15 |     18 |00:00:00.01 |       7 |
|   3 |    NESTED LOOPS                |                |      1 |      4 |     21 |00:00:00.01 |       4 |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOC            |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  5 |      INDEX UNIQUE SCAN         | LOC_CITY_IDX   |      1 |      1 |      1 |00:00:00.01 |       1 |
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPT           |      1 |      4 |     21 |00:00:00.01 |       2 |
|*  7 |      INDEX RANGE SCAN          | DEPT_LOCID_IDX |      1 |      4 |     21 |00:00:00.01 |       1 |
|*  8 |    INDEX RANGE SCAN            | EMP_DEPTID_IDX |     21 |     10 |     18 |00:00:00.01 |       3 |
|   9 |   TABLE ACCESS BY INDEX ROWID  | EMP            |     18 |      4 |     18 |00:00:00.01 |       3 |
-----------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   5 - access("L"."CITY"='Seattle')
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   8 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

-- [문제125] SQL문장의 실행계획을 확인 한 후 튜닝하세요.
-- 실행계획 확인
select  e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'
and e.job_id = 'AD_VP';  

select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
/*
-----------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                |      1 |        |      2 |00:00:00.01 |      10 |
|   1 |  NESTED LOOPS                  |                |      1 |        |      2 |00:00:00.01 |      10 |
|   2 |   NESTED LOOPS                 |                |      1 |      1 |     18 |00:00:00.01 |       7 |
|   3 |    NESTED LOOPS                |                |      1 |      4 |     21 |00:00:00.01 |       4 |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOC            |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  5 |      INDEX UNIQUE SCAN         | LOC_CITY_IDX   |      1 |      1 |      1 |00:00:00.01 |       1 |
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPT           |      1 |      4 |     21 |00:00:00.01 |       2 |
|*  7 |      INDEX RANGE SCAN          | DEPT_LOCID_IDX |      1 |      4 |     21 |00:00:00.01 |       1 |
|*  8 |    INDEX RANGE SCAN            | EMP_DEPTID_IDX |     21 |     10 |     18 |00:00:00.01 |       3 |
|*  9 |   TABLE ACCESS BY INDEX ROWID  | EMP            |     18 |      1 |      2 |00:00:00.01 |       3 |
-----------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   5 - access("L"."CITY"='Seattle')
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   8 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   9 - filter("E"."JOB_ID"='AD_VP')
*/

-- 문제확인: e.job_id가 filter로 풀림
-- 건수확인
select count(*) from emp e, dept d where e.department_id = d.department_id and job_id = 'AD_VP'; -- 2건
select count(*) from loc l, dept d where d.location_id = l.location_id and l.city = 'Seattle'; -- 21건

-- e.job_id = 'AD_VP' 먼저 처리
create index emp_jobid_idx on emp(job_id);
alter table dept add constraint dept_deptid_pk primary key(department_id);
create index loc_id_city_idx on loc(location_id, city);

select ix.index_name, ix.uniqueness, ic.column_name from user_indexes ix, user_ind_columns ic 
where ix.index_name = ic.index_name and ix.table_name = 'LOC';

select  /*+ leading(e, d, l) use_nl(d) use_nl(l) */e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'
and e.job_id = 'AD_VP';  

select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
/*
-----------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                 |      1 |        |      2 |00:00:00.01 |       8 |
|   1 |  NESTED LOOPS                 |                 |      1 |      1 |      2 |00:00:00.01 |       8 |
|   2 |   NESTED LOOPS                |                 |      1 |      6 |      2 |00:00:00.01 |       6 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP             |      1 |      6 |      2 |00:00:00.01 |       2 |
|*  4 |     INDEX RANGE SCAN          | EMP_JOBID_IDX   |      1 |      6 |      2 |00:00:00.01 |       1 |
|   5 |    TABLE ACCESS BY INDEX ROWID| DEPT            |      2 |      1 |      2 |00:00:00.01 |       4 |
|*  6 |     INDEX UNIQUE SCAN         | DEPT_DEPTID_PK  |      2 |      1 |      2 |00:00:00.01 |       2 |
|*  7 |   INDEX RANGE SCAN            | LOC_ID_CITY_IDX |      2 |      1 |      2 |00:00:00.01 |       2 |
-----------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - access("E"."JOB_ID"='AD_VP')
   6 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID" AND "L"."CITY"='Seattle')
*/


-- 사용 index 지정
select  /*+ leading(e, d, l) use_nl(d) use_nl_with_index(l loc_locid_pk) */e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'
and e.job_id = 'AD_VP';  

select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));


-- l.city = 'Seattle' 먼저 처리
create index emp_dept_jobid_idx on emp(department_id, job_id);

select  /*+ leading(l, d, e) use_nl(d) use_nl(e) */e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'
and e.job_id = 'AD_VP';  

select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
/*
---------------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name               | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
---------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                    |      1 |        |      2 |00:00:00.01 |       8 |
|   1 |  NESTED LOOPS                  |                    |      1 |        |      2 |00:00:00.01 |       8 |
|   2 |   NESTED LOOPS                 |                    |      1 |      1 |      2 |00:00:00.01 |       7 |
|   3 |    NESTED LOOPS                |                    |      1 |      4 |     21 |00:00:00.01 |       4 |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOC                |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  5 |      INDEX UNIQUE SCAN         | LOC_CITY_IDX       |      1 |      1 |      1 |00:00:00.01 |       1 |
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPT               |      1 |      4 |     21 |00:00:00.01 |       2 |
|*  7 |      INDEX RANGE SCAN          | DEPT_LOCID_IDX     |      1 |      4 |     21 |00:00:00.01 |       1 |
|*  8 |    INDEX RANGE SCAN            | EMP_DEPT_JOBID_IDX |     21 |      5 |      2 |00:00:00.01 |       3 |
|   9 |   TABLE ACCESS BY INDEX ROWID  | EMP                |      2 |      1 |      2 |00:00:00.01 |       1 |
---------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   5 - access("L"."CITY"='Seattle')
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   8 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID" and "E"."JOB_ID"='AD_VP')
  */

-- [문제126] SQL문장의 실행계획을 확인 한 후 sort merge join의 방법으로 튜닝하세요.
alter session set statistics_level = all;

select /*+ leading(l,d,e) use_nl(d) use_nl(e)  */ e.last_name, e.first_name, e.salary, e.job_id, d.department_name, l.city, l.street_address
from employees e, departments d, locations l
where d.department_id = e.department_id
and d.location_id = l.location_id;

-- 실행계획 확인
select * from table(dbms_xplan.display_cursor(null, null, 'allstats last'));
/*
--------------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                   |      1 |        |    106 |00:00:00.01 |   54 |
|   1 |  NESTED LOOPS                  |                   |      1 |        |    106 |00:00:00.01 |   54 |
|   2 |   NESTED LOOPS                 |                   |      1 |    106 |    106 |00:00:00.01 |   41 |
|   3 |    NESTED LOOPS                |                   |      1 |     27 |     27 |00:00:00.01 |   27 |
|   4 |     TABLE ACCESS FULL          | LOCATIONS         |      1 |     23 |     23 |00:00:00.01 |   11 |
|   5 |     TABLE ACCESS BY INDEX ROWID| DEPARTMENTS       |     23 |      1 |     27 |00:00:00.01 |   16 |
|*  6 |      INDEX RANGE SCAN          | DEPT_LOCATION_IX  |     23 |      4 |     27 |00:00:00.01 |   11 |
|*  7 |    INDEX RANGE SCAN            | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |   14 |
|   8 |   TABLE ACCESS BY INDEX ROWID  | EMPLOYEES         |    106 |      4 |    106 |00:00:00.01 |   13 |
--------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   6 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   7 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
*/

-- 튜닝: sort merge join 으로 변경
-- lde순서로
select /*+ leading(l,d,e) use_merge(d) use_merge(e)  */ e.last_name, e.first_name, e.salary, e.job_id, d.department_name, l.city, l.street_address
from employees e, departments d, locations l
where d.department_id = e.department_id
and d.location_id = l.location_id;

-- 실행계획 확인
/*
---------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem |
---------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |             |      1 |        |    106 |00:00:00.02 |      14 |      9 |       |       |
|   1 |  MERGE JOIN                    |             |      1 |    106 |    106 |00:00:00.02 |      14 |      9 |       |       |
|   2 |   SORT JOIN                    |             |      1 |     27 |     27 |00:00:00.01 |       8 |      6 |  4096 |  4096 |
|   3 |    MERGE JOIN                  |             |      1 |     27 |     27 |00:00:00.01 |       8 |      6 |       |       |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOCATIONS   |      1 |     23 |     19 |00:00:00.01 |       2 |      1 |       |       |
|   5 |      INDEX FULL SCAN           | LOC_ID_PK   |      1 |     23 |     19 |00:00:00.01 |       1 |      1 |       |       |
|*  6 |     SORT JOIN                  |             |     19 |     27 |     27 |00:00:00.01 |       6 |      5 |  2048 |  2048 |
|   7 |      TABLE ACCESS FULL         | DEPARTMENTS |      1 |     27 |     27 |00:00:00.01 |       6 |      5 |       |       |
|*  8 |   SORT JOIN                    |             |     27 |    107 |    106 |00:00:00.01 |       6 |      3 | 18432 | 18432 |
|   9 |    TABLE ACCESS FULL           | EMPLOYEES   |      1 |    107 |    107 |00:00:00.01 |       6 |      3 |       |       |
---------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   6 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
   8 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
       filter("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
*/

-- 4번 단계에서 전체 row가 아닌 19개 row만 사용한 이유: 통계정보를 활용하여 departments의 범위를 벗어나는 row는 제외함
-- |   4 |     TABLE ACCESS BY INDEX ROWID| LOCATIONS   |      1 |     23 |     19 |00:00:00.01 |       2 |      1 |       |       |
select location_id from locations order by location_id;
select distinct l.location_id from locations l, departments d where l.location_id = d.location_id;

select * from user_tab_col_statistics where table_name = 'LOCATIONS';
select * from user_tab_col_statistics where table_name = 'DEPARTMENTS';


A: 4, 5번
select l.location_id, l.city, l.street_address
from locations l
order by l.location_id;

B: 6, 7번
select d.location_id, d.department_name, department_id
from departments d
order by d.location id;

C: 3번
select l.location_id, l.city, l.street_address, d.department_name, d.department_id
from locations l, departments d
where d.location_id = l.location_id;


D: C결과를 정렬, 2번
order by d.department_id;

E: 8, 9번
select e.department_id, e.last_name, e.first_name, e.salary, e.job_id
from employees
order by department_id;

F: D와 E를 merge, 1번

       
-- edl순서로 : 큰 테이블을 first로 두었을때 buffer, memory 모두 증가
select /*+ leading(e, d, l) use_merge(d) use_merge(l)  */ e.last_name, e.first_name, e.salary, e.job_id, d.department_name, l.city, l.street_address
from employees e, departments d, locations l
where d.department_id = e.department_id
and d.location_id = l.location_id;

-- 실행계획 확인
/*
--------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
--------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |             |      1 |        |    106 |00:00:00.01 |      18 |       |       |          |
|   1 |  MERGE JOIN           |             |      1 |    106 |    106 |00:00:00.01 |      18 |       |       |          |
|   2 |   SORT JOIN           |             |      1 |    106 |    106 |00:00:00.01 |      12 | 13312 | 13312 |12288  (0)|
|   3 |    MERGE JOIN         |             |      1 |    106 |    106 |00:00:00.01 |      12 |       |       |          |
|   4 |     SORT JOIN         |             |      1 |    107 |    107 |00:00:00.01 |       6 | 18432 | 18432 |16384  (0)|
|   5 |      TABLE ACCESS FULL| EMPLOYEES   |      1 |    107 |    107 |00:00:00.01 |       6 |       |       |          |
|*  6 |     SORT JOIN         |             |    107 |     27 |    106 |00:00:00.01 |       6 |  2048 |  2048 | 2048  (0)|
|   7 |      TABLE ACCESS FULL| DEPARTMENTS |      1 |     27 |     27 |00:00:00.01 |       6 |       |       |          |
|*  8 |   SORT JOIN           |             |    106 |     23 |    106 |00:00:00.01 |       6 |  2048 |  2048 | 2048  (0)|
|   9 |    TABLE ACCESS FULL  | LOCATIONS   |      1 |     23 |     23 |00:00:00.01 |       6 |       |       |          |
--------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   6 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
       filter("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
   8 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
*/

-- [문제127] SQL문장의 실행계획을 nested loop join, sort merge join, hash join 방법으로 비교하세요.

select e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id; 

--기본 실행계획
/*
--------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name             | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
--------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                  |      1 |        |    106 |00:00:00.03 |   31 |        21 |       |       |          |
|*  1 |  HASH JOIN                      |                  |      1 |    106 |    106 |00:00:00.03 |   31 |        21 |   792K|   792K| 1274K (0)|
|*  2 |   HASH JOIN                     |                  |      1 |     27 |     27 |00:00:00.02 |   18 |        15 |   799K|   799K|  549K (0)|
|   3 |    NESTED LOOPS                 |                  |      1 |     27 |     27 |00:00:00.02 |   12 |         9 |       |       |          |
|   4 |     MERGE JOIN                  |                  |      1 |     27 |     27 |00:00:00.02 |    8 |         8 |       |       |          |
|   5 |      TABLE ACCESS BY INDEX ROWID| DEPARTMENTS      |      1 |     27 |     27 |00:00:00.01 |    2 |         2 |       |       |          |
|   6 |       INDEX FULL SCAN           | DEPT_LOCATION_IX |      1 |     27 |     27 |00:00:00.01 |    1 |         1 |       |       |          |
|*  7 |      SORT JOIN                  |                  |     27 |     23 |     27 |00:00:00.01 |    6 |         6 |  2048 |  2048 | 2048  (0)|
|   8 |       TABLE ACCESS FULL         | LOCATIONS        |      1 |     23 |     23 |00:00:00.01 |    6 |         6 |       |       |          |
|*  9 |     INDEX UNIQUE SCAN           | COUNTRY_C_ID_PK  |     27 |      1 |     27 |00:00:00.01 |    4 |         1 |       |       |          |
|  10 |    TABLE ACCESS FULL            | REGIONS          |      1 |      4 |      4 |00:00:00.01 |    6 |         6 |       |       |          |
|  11 |   TABLE ACCESS FULL             | EMPLOYEES        |      1 |    107 |    107 |00:00:00.01 |   13 |         6 |       |       |          |
--------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   2 - access("R"."REGION_ID"="C"."REGION_ID")
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
   9 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
*/


-- nested loop join 순서: employees - departments - locations - countries - regions
select /*+ leading (e, d, l, c, r) use_nl(d) use_nl(l) use_nl(c) use_nl(r) */e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id;

-- 결과
/*
-----------------------------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
-----------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |                 |      1 |        |    106 |00:00:00.02 |  371 |         3 |
|   1 |  NESTED LOOPS                    |                 |      1 |        |    106 |00:00:00.02 |  371 |         3 |
|   2 |   NESTED LOOPS                   |                 |      1 |    106 |    106 |00:00:00.02 |  265 |         3 |
|   3 |    NESTED LOOPS                  |                 |      1 |    106 |    106 |00:00:00.01 |  255 |         2 |
|   4 |     NESTED LOOPS                 |                 |      1 |    106 |    106 |00:00:00.01 |  245 |         2 |
|   5 |      NESTED LOOPS                |                 |      1 |    106 |    106 |00:00:00.01 |  129 |         1 |
|   6 |       TABLE ACCESS FULL          | EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |   13 |         0 |
|   7 |       TABLE ACCESS BY INDEX ROWID| DEPARTMENTS     |    107 |      1 |    106 |00:00:00.01 |  116 |         1 |
|*  8 |        INDEX UNIQUE SCAN         | DEPT_ID_PK      |    107 |      1 |    106 |00:00:00.01 |   10 |         1 |
|   9 |      TABLE ACCESS BY INDEX ROWID | LOCATIONS       |    106 |      1 |    106 |00:00:00.01 |  116 |         1 |
|* 10 |       INDEX UNIQUE SCAN          | LOC_ID_PK       |    106 |      1 |    106 |00:00:00.01 |   10 |         1 |
|* 11 |     INDEX UNIQUE SCAN            | COUNTRY_C_ID_PK |    106 |      1 |    106 |00:00:00.01 |   10 |         0 |
|* 12 |    INDEX UNIQUE SCAN             | REG_ID_PK       |    106 |      1 |    106 |00:00:00.01 |   10 |         1 |
|  13 |   TABLE ACCESS BY INDEX ROWID    | REGIONS         |    106 |      1 |    106 |00:00:00.01 |  106 |         0 |
-----------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   8 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
  10 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
  11 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
  12 - access("R"."REGION_ID"="C"."REGION_ID")
*/

-- nested loop join 순서: regions - countries - locations - departments - employees
select /*+ leading (r, c, l, d, e) use_nl(c) use_nl(l) use_nl(d) use_nl(e) */e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id;

-- 결과
/*
------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                   |      1 |        |    106 |00:00:00.01 |      82 |      3 |
|   1 |  NESTED LOOPS                   |                   |      1 |        |    106 |00:00:00.01 |      82 |      3 |
|   2 |   NESTED LOOPS                  |                   |      1 |    106 |    106 |00:00:00.01 |      68 |      3 |
|   3 |    NESTED LOOPS                 |                   |      1 |     27 |     27 |00:00:00.01 |      54 |      2 |
|   4 |     NESTED LOOPS                |                   |      1 |     23 |     23 |00:00:00.01 |      37 |      2 |
|   5 |      NESTED LOOPS               |                   |      1 |     25 |     25 |00:00:00.01 |      23 |      1 |
|   6 |       TABLE ACCESS FULL         | REGIONS           |      1 |      4 |      4 |00:00:00.01 |       8 |      0 |
|*  7 |       INDEX FAST FULL SCAN      | COUNTRY_C_ID_PK   |      4 |      6 |     25 |00:00:00.01 |      15 |      1 |
|   8 |      TABLE ACCESS BY INDEX ROWID| LOCATIONS         |     25 |      1 |     23 |00:00:00.01 |      14 |      1 |
|*  9 |       INDEX RANGE SCAN          | LOC_COUNTRY_IX    |     25 |      2 |     23 |00:00:00.01 |       9 |      1 |
|  10 |     TABLE ACCESS BY INDEX ROWID | DEPARTMENTS       |     23 |      1 |     27 |00:00:00.01 |      17 |      0 |
|* 11 |      INDEX RANGE SCAN           | DEPT_LOCATION_IX  |     23 |      4 |     27 |00:00:00.01 |      11 |      0 |
|* 12 |    INDEX RANGE SCAN             | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |      14 |      1 |
|  13 |   TABLE ACCESS BY INDEX ROWID   | EMPLOYEES         |    106 |      4 |    106 |00:00:00.01 |      14 |      0 |
------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   7 - filter("R"."REGION_ID"="C"."REGION_ID")
   9 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
  11 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
  12 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

-- sort merge join 순서: employees - departments - locations - countries - regions
select /*+ leading (e, d, l, c, r) use_merge(d) use_merge(l) use_merge(c) use_merge(r) */e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id;

/*
-------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                 | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
-------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT          |                 |      1 |        |    106 |00:00:00.02 |      25 |      5 |       |       |          |
|   1 |  MERGE JOIN               |                 |      1 |    106 |    106 |00:00:00.02 |      25 |      5 |       |       |          |
|   2 |   SORT JOIN               |                 |      1 |    106 |    106 |00:00:00.02 |      19 |      5 | 20480 | 20480 |18432  (0)|
|   3 |    MERGE JOIN             |                 |      1 |    106 |    106 |00:00:00.01 |      19 |      5 |       |       |          |
|   4 |     SORT JOIN             |                 |      1 |    106 |    106 |00:00:00.01 |      18 |      5 | 15360 | 15360 |14336  (0)|
|   5 |      MERGE JOIN           |                 |      1 |    106 |    106 |00:00:00.01 |      18 |      5 |       |       |          |
|   6 |       SORT JOIN           |                 |      1 |    106 |    106 |00:00:00.01 |      12 |      5 | 13312 | 13312 |12288  (0)|
|   7 |        MERGE JOIN         |                 |      1 |    106 |    106 |00:00:00.01 |      12 |      5 |       |       |          |
|   8 |         SORT JOIN         |                 |      1 |    107 |    107 |00:00:00.01 |       6 |      0 | 18432 | 18432 |16384  (0)|
|   9 |          TABLE ACCESS FULL| EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |       6 |      0 |       |       |          |
|* 10 |         SORT JOIN         |                 |    107 |     27 |    106 |00:00:00.01 |       6 |      5 |  2048 |  2048 | 2048  (0)|
|  11 |          TABLE ACCESS FULL| DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |      5 |       |       |          |
|* 12 |       SORT JOIN           |                 |    106 |     23 |    106 |00:00:00.01 |       6 |      0 |  2048 |  2048 | 2048  (0)|
|  13 |        TABLE ACCESS FULL  | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |       6 |      0 |       |       |          |
|* 14 |     SORT JOIN             |                 |    106 |     25 |    106 |00:00:00.01 |       1 |      0 |  2048 |  2048 | 2048  (0)|
|  15 |      INDEX FULL SCAN      | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |      0 |       |       |          |
|* 16 |   SORT JOIN               |                 |    106 |      4 |    106 |00:00:00.01 |       6 |      0 |  2048 |  2048 | 2048  (0)|
|  17 |    TABLE ACCESS FULL      | REGIONS         |      1 |      4 |      4 |00:00:00.01 |       6 |      0 |       |       |          |
-------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

  10 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
  12 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
  14 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
       filter("L"."COUNTRY_ID"="C"."COUNTRY_ID")
  16 - access("R"."REGION_ID"="C"."REGION_ID")
       filter("R"."REGION_ID"="C"."REGION_ID")
*/


-- sort merge join 순서: regions - countries - locations - departments - employees
select /*+ leading (r, c, l, d, e) use_merge(c) use_merge(l) use_merge(d) use_merge(e) */e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id;

/*
-------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                          | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
-------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                   |                 |      1 |        |    106 |00:00:00.01 |      21 |       |       |          |
|   1 |  MERGE JOIN                        |                 |      1 |    106 |    106 |00:00:00.01 |      21 |       |       |          |
|   2 |   SORT JOIN                        |                 |      1 |     27 |     27 |00:00:00.01 |      15 |  4096 |  4096 | 4096  (0)|
|   3 |    MERGE JOIN                      |                 |      1 |     27 |     27 |00:00:00.01 |      15 |       |       |          |
|   4 |     SORT JOIN                      |                 |      1 |     23 |     19 |00:00:00.01 |       9 |  4096 |  4096 | 4096  (0)|
|   5 |      MERGE JOIN                    |                 |      1 |     23 |     23 |00:00:00.01 |       9 |       |       |          |
|   6 |       SORT JOIN                    |                 |      1 |     25 |     24 |00:00:00.01 |       3 |  2048 |  2048 | 2048  (0)|
|   7 |        MERGE JOIN                  |                 |      1 |     25 |     25 |00:00:00.01 |       3 |       |       |          |
|   8 |         TABLE ACCESS BY INDEX ROWID| REGIONS         |      1 |      4 |      4 |00:00:00.01 |       2 |       |       |          |
|   9 |          INDEX FULL SCAN           | REG_ID_PK       |      1 |      4 |      4 |00:00:00.01 |       1 |       |       |          |
|* 10 |         SORT JOIN                  |                 |      4 |     25 |     25 |00:00:00.01 |       1 |  2048 |  2048 | 2048  (0)|
|  11 |          INDEX FULL SCAN           | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |       |       |          |
|* 12 |       SORT JOIN                    |                 |     24 |     23 |     23 |00:00:00.01 |       6 |  2048 |  2048 | 2048  (0)|
|  13 |        TABLE ACCESS FULL           | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |       6 |       |       |          |
|* 14 |     SORT JOIN                      |                 |     19 |     27 |     27 |00:00:00.01 |       6 |  2048 |  2048 | 2048  (0)|
|  15 |      TABLE ACCESS FULL             | DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |       |       |          |
|* 16 |   SORT JOIN                        |                 |     27 |    107 |    106 |00:00:00.01 |       6 | 18432 | 18432 |16384  (0)|
|  17 |    TABLE ACCESS FULL               | EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |       6 |       |       |          |
-------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

  10 - access("R"."REGION_ID"="C"."REGION_ID")
       filter("R"."REGION_ID"="C"."REGION_ID")
  12 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
       filter("L"."COUNTRY_ID"="C"."COUNTRY_ID")
  14 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
  16 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

-- hash join 순서: employees - departments - locations - countries - regions
select /*+ leading (e, d, l, c, r) use_hash(d) use_hash(l) use_hash(c) use_hash(r) */e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id;
/*
------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                 |      1 |        |    106 |00:00:00.01 |      30 |    |          |          |
|*  1 |  HASH JOIN            |                 |      1 |    106 |    106 |00:00:00.01 |      30 |  1079K|  1079K|  735K (0)|
|   2 |   TABLE ACCESS FULL   | REGIONS         |      1 |      4 |      4 |00:00:00.01 |       6 |    |          |          |
|*  3 |   HASH JOIN           |                 |      1 |    106 |    106 |00:00:00.01 |      24 |  1079K|  1079K| 1241K (0)|
|   4 |    INDEX FULL SCAN    | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |    |          |          |
|*  5 |    HASH JOIN          |                 |      1 |    106 |    106 |00:00:00.01 |      23 |   889K|   889K|  643K (0)|
|*  6 |     HASH JOIN         |                 |      1 |    106 |    106 |00:00:00.01 |      12 |   940K|   940K|  906K (0)|
|   7 |      TABLE ACCESS FULL| EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |       6 |    |          |          |
|   8 |      TABLE ACCESS FULL| DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |    |          |          |
|   9 |     TABLE ACCESS FULL | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |      11 |    |          |          |
------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("R"."REGION_ID"="C"."REGION_ID")
   3 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
   5 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   6 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

-- hash join 순서: regions - countries - locations - departments - employees
select /*+ leading (r, c, l, d, e) use_hash(c) use_hash(l) use_hash(d) use_hash(e) */e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id;
/*
------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                 |      1 |        |    106 |00:00:00.01 |      32 |    |          |          |
|*  1 |  HASH JOIN            |                 |      1 |    106 |    106 |00:00:00.01 |      32 |   792K|   792K| 1252K (0)|
|*  2 |   HASH JOIN           |                 |      1 |     27 |     27 |00:00:00.01 |      19 |   832K|   832K| 1159K (0)|
|*  3 |    HASH JOIN          |                 |      1 |     23 |     23 |00:00:00.01 |      13 |   981K|   981K| 1255K (0)|
|*  4 |     HASH JOIN         |                 |      1 |     25 |     25 |00:00:00.01 |       7 |  1096K|  1096K|  741K (0)|
|   5 |      TABLE ACCESS FULL| REGIONS         |      1 |      4 |      4 |00:00:00.01 |       6 |    |          |          |
|   6 |      INDEX FULL SCAN  | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |    |          |          |
|   7 |     TABLE ACCESS FULL | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |       6 |    |          |          |
|   8 |    TABLE ACCESS FULL  | DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |    |          |          |
|   9 |   TABLE ACCESS FULL   | EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |      13 |    |          |          |
------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   2 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   3 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
   4 - access("R"."REGION_ID"="C"."REGION_ID")
*/

-- arraysize 1000
-- hash join 순서: employees - departments - locations - countries - regions
/*
------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                 |      1 |        |    106 |00:00:00.01 |      26 |    |          |          |
|*  1 |  HASH JOIN            |                 |      1 |    106 |    106 |00:00:00.01 |      26 |  1079K|  1079K|  742K (0)|
|   2 |   TABLE ACCESS FULL   | REGIONS         |      1 |      4 |      4 |00:00:00.01 |       6 |    |          |          |
|*  3 |   HASH JOIN           |                 |      1 |    106 |    106 |00:00:00.01 |      20 |  1079K|  1079K| 1253K (0)|
|   4 |    INDEX FULL SCAN    | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |    |          |          |
|*  5 |    HASH JOIN          |                 |      1 |    106 |    106 |00:00:00.01 |      19 |   889K|   889K|  651K (0)|
|*  6 |     HASH JOIN         |                 |      1 |    106 |    106 |00:00:00.01 |      12 |   940K|   940K|  901K (0)|
|   7 |      TABLE ACCESS FULL| EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |       6 |    |          |          |
|   8 |      TABLE ACCESS FULL| DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |    |          |          |
|   9 |     TABLE ACCESS FULL | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |       7 |    |          |          |
------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("R"."REGION_ID"="C"."REGION_ID")
   3 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
   5 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   6 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

-- hash join 순서: regions - countries - locations - departments - employees
/*
------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                 |      1 |        |    106 |00:00:00.01 |      26 |    |          |          |
|*  1 |  HASH JOIN            |                 |      1 |    106 |    106 |00:00:00.01 |      26 |   792K|   792K| 1294K (0)|
|*  2 |   HASH JOIN           |                 |      1 |     27 |     27 |00:00:00.01 |      19 |   832K|   832K| 1156K (0)|
|*  3 |    HASH JOIN          |                 |      1 |     23 |     23 |00:00:00.01 |      13 |   981K|   981K| 1254K (0)|
|*  4 |     HASH JOIN         |                 |      1 |     25 |     25 |00:00:00.01 |       7 |  1096K|  1096K|  770K (0)|
|   5 |      TABLE ACCESS FULL| REGIONS         |      1 |      4 |      4 |00:00:00.01 |       6 |    |          |          |
|   6 |      INDEX FULL SCAN  | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |    |          |          |
|   7 |     TABLE ACCESS FULL | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |       6 |    |          |          |
|   8 |    TABLE ACCESS FULL  | DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |    |          |          |
|   9 |   TABLE ACCESS FULL   | EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |       7 |    |          |          |
------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   2 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   3 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
   4 - access("R"."REGION_ID"="C"."REGION_ID")
*/

-- [문제128] 아래 SQL문을 분석해보세요.
select *
FROM employees e
where exists (select 'x' 	from departments d WHERE department_id = e.department_id	and location_id = 1500);
/*
-----------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
-----------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                   |      1 |        |     45 |00:00:00.01 |   11 |          |       |          |
|   1 |  NESTED LOOPS                  |                   |      1 |        |     45 |00:00:00.01 |   11 |          |       |          |
|   2 |   NESTED LOOPS                 |                   |      1 |     10 |     45 |00:00:00.01 |    6 |          |       |          |
|   3 |    SORT UNIQUE                 |                   |      1 |      1 |      1 |00:00:00.01 |    2 |     2048 |  2048 | 2048  (0)|
|   4 |     TABLE ACCESS BY INDEX ROWID| DEPARTMENTS       |      1 |      1 |      1 |00:00:00.01 |    2 |          |       |          |
|*  5 |      INDEX RANGE SCAN          | DEPT_LOCATION_IX  |      1 |      1 |      1 |00:00:00.01 |    1 |          |       |          |
|*  6 |    INDEX RANGE SCAN            | EMP_DEPARTMENT_IX |      1 |     10 |     45 |00:00:00.01 |    4 |          |       |          |
|   7 |   TABLE ACCESS BY INDEX ROWID  | EMPLOYEES         |     45 |     10 |     45 |00:00:00.01 |    5 |          |       |          |
-----------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("LOCATION_ID"=1500)
   6 - access("DEPARTMENT_ID"="E"."DEPARTMENT_ID")
*/

-- 3: SORT UNIQUE 발생: driven쪽이 1쪽집합인지 확실하지 않은 상황
-- 6,7: batch i/o 작동

-- join으로 만들기
SELECT /*+ leading(d) use_nl(e)*/e.*
FROM employees e, departments d
WHERE d.department_id = e.department_id	AND d.location_id = 1500;
/*
-------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                   |      1 |        |     45 |00:00:00.01 |   12 |
|   1 |  NESTED LOOPS                 |                   |      1 |        |     45 |00:00:00.01 |   12 |
|   2 |   NESTED LOOPS                |                   |      1 |     10 |     45 |00:00:00.01 |    7 |
|   3 |    TABLE ACCESS BY INDEX ROWID| DEPARTMENTS       |      1 |      1 |      1 |00:00:00.01 |    3 |
|*  4 |     INDEX RANGE SCAN          | DEPT_LOCATION_IX  |      1 |      1 |      1 |00:00:00.01 |    2 |
|*  5 |    INDEX RANGE SCAN           | EMP_DEPARTMENT_IX |      1 |     10 |     45 |00:00:00.01 |    4 |
|   6 |   TABLE ACCESS BY INDEX ROWID | EMPLOYEES         |     45 |     10 |     45 |00:00:00.01 |    5 |
-------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("D"."LOCATION_ID"=1500)
   5 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
*/

SELECT /*+ leading(d) use_hash(e)*/e.*
FROM employees e, departments d
WHERE d.department_id = e.department_id	AND d.location_id = 1500;
/*
--------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name             | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
--------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                  |      1 |        |     45 |00:00:00.01 |      11 |       |       |          |
|*  1 |  HASH JOIN                   |                  |      1 |     10 |     45 |00:00:00.01 |      11 |  1517K|  1517K|  386K (0)|
|   2 |   TABLE ACCESS BY INDEX ROWID| DEPARTMENTS      |      1 |      1 |      1 |00:00:00.01 |    2 |          |       |          |
|*  3 |    INDEX RANGE SCAN          | DEPT_LOCATION_IX |      1 |      1 |      1 |00:00:00.01 |    1 |          |       |          |
|   4 |   TABLE ACCESS FULL          | EMPLOYEES        |      1 |    107 |    107 |00:00:00.01 |    9 |          |       |          |
--------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
   3 - access("D"."LOCATION_ID"=1500)
*/
SELECT /*+ leading(d) use_merge(e)*/e.*
FROM employees e, departments d
WHERE d.department_id = e.department_id	AND d.location_id = 1500;
/*
---------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name             | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
---------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                  |      1 |        |     45 |00:00:00.01 |    8 |          |       |          |
|   1 |  MERGE JOIN                   |                  |      1 |     10 |     45 |00:00:00.01 |    8 |          |       |          |
|   2 |   SORT JOIN                   |                  |      1 |      1 |      1 |00:00:00.01 |    2 |  2048 |  2048 | 2048  (0)|
|   3 |    TABLE ACCESS BY INDEX ROWID| DEPARTMENTS      |      1 |      1 |      1 |00:00:00.01 |    2 |          |       |          |
|*  4 |     INDEX RANGE SCAN          | DEPT_LOCATION_IX |      1 |      1 |      1 |00:00:00.01 |    1 |          |       |          |
|*  5 |   SORT JOIN                   |                  |      1 |    107 |     45 |00:00:00.01 |    6 | 22528 | 22528 |20480  (0)|
|   6 |    TABLE ACCESS FULL          | EMPLOYEES        |      1 |    107 |    107 |00:00:00.01 |    6 |          |       |          |
---------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("D"."LOCATION_ID"=1500)
   5 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
       filter("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
*/

-- [문제129] SQL문을 튜닝하세요.
select department_name, (select sum(salary)	from employees	where department_id = d.department_id) sumsal,	(select avg(salary)	from employees	WHERE department_id = d.department_id) avgsal
FROM departments d;
/*
------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                   |      1 |        |     27 |00:00:00.01 |    8 |
|   1 |  SORT AGGREGATE              |                   |     27 |      1 |     27 |00:00:00.01 |   14 |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |     27 |     10 |    106 |00:00:00.01 |   14 |
|*  3 |    INDEX RANGE SCAN          | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |    4 |
|   4 |  SORT AGGREGATE              |                   |     27 |      1 |     27 |00:00:00.01 |   14 |
|   5 |   TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |     27 |     10 |    106 |00:00:00.01 |   14 |
|*  6 |    INDEX RANGE SCAN          | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |    4 |
|   7 |  TABLE ACCESS FULL           | DEPARTMENTS       |      1 |     27 |     27 |00:00:00.01 |    8 |
------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - access("DEPARTMENT_ID"=:B1)
   6 - access("DEPARTMENT_ID"=:B1)
*/


-- 스칼라서브쿼리가 2개 있어 같은 테이블에 여러번 접근

-- 스칼라서브쿼리 활용
SELECT department_name, substr(sal, 1, 10) sum_sal, substr(sal, 11) avg_sal
FROM (SELECT department_name, (SELECT lpad(sum(salary), 10)||lpad(avg(salary), 10) FROM employees WHERE department_id = d.department_id) sal FROM departments d)
where sal is not null;
/*
------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                   |      1 |        |     11 |00:00:00.01 |   20 |
|   1 |  SORT AGGREGATE              |                   |     27 |      1 |     27 |00:00:00.01 |   13 |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |     27 |     10 |    106 |00:00:00.01 |   13 |
|*  3 |    INDEX RANGE SCAN          | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |    3 |
|*  4 |  VIEW                        |                   |      1 |     27 |     11 |00:00:00.01 |   20 |
|   5 |   TABLE ACCESS FULL          | DEPARTMENTS       |      1 |     27 |     27 |00:00:00.01 |    7 |
------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - access("DEPARTMENT_ID"=:B1)
   4 - filter("SAL" IS NOT NULL)
*/

-- join 활용
SELECT /*+ leading(d) use_nl(e)*/d.department_name, e.sumsal, e.avgsal
FROM departments d, (SELECT department_id, sum(salary) AS sumsal, avg(salary) AS avgsal FROM employees GROUP BY department_id) e
where e.department_id(+) = d.department_id;
/*
----------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
----------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                   |      1 |        |     27 |00:00:00.01 |   18 |          |       |          |
|   1 |  HASH GROUP BY                |                   |      1 |    106 |     27 |00:00:00.01 |   18 |      806K|   806K| 1347K (0)|
|   2 |   NESTED LOOPS OUTER          |                   |      1 |    106 |    122 |00:00:00.01 |   18 |          |       |          |
|   3 |    TABLE ACCESS FULL          | DEPARTMENTS       |      1 |     27 |     27 |00:00:00.01 |    6 |          |       |          |
|   4 |    TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |     27 |      4 |    106 |00:00:00.01 |   12 |          |       |          |
|*  5 |     INDEX RANGE SCAN          | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |    3 |          |       |          |
----------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

SELECT /*+ leading(d) use_merge(e)*/d.department_name, e.sumsal, e.avgsal
FROM departments d, (SELECT department_id, sum(salary) AS sumsal, avg(salary) AS avgsal FROM employees GROUP BY department_id) e
where e.department_id(+) = d.department_id;
/*
---------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
---------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |      1 |        |     27 |00:00:00.01 |      12 |       |       |          |
|   1 |  MERGE JOIN OUTER            |             |      1 |     27 |     27 |00:00:00.01 |      12 |       |       |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| DEPARTMENTS |      1 |     27 |     27 |00:00:00.01 |       6 |       |       |          |
|   3 |    INDEX FULL SCAN           | DEPT_ID_PK  |      1 |     27 |     27 |00:00:00.01 |       3 |       |       |          |
|*  4 |   SORT JOIN                  |             |     27 |     11 |     11 |00:00:00.01 |       6 |  2048 |  2048 | 2048  (0)|
|   5 |    VIEW                      |             |      1 |     11 |     12 |00:00:00.01 |       6 |       |       |          |
|   6 |     HASH GROUP BY            |             |      1 |     11 |     12 |00:00:00.01 |       6 |   894K|   894K| 1718K (0)|
|   7 |      TABLE ACCESS FULL       | EMPLOYEES   |      1 |    107 |    107 |00:00:00.01 |       6 |       |       |          |
---------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

SELECT /*+ leading(d) use_hash(e)*/d.department_name, e.sumsal, e.avgsal
FROM departments d, (SELECT department_id, sum(salary) AS sumsal, avg(salary) AS avgsal FROM employees GROUP BY department_id) e
where e.department_id(+) = d.department_id;
/*
-------------------------------------------------------------------------------------------------------------------------
| Id  | Operation            | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
-------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |             |      1 |        |     27 |00:00:00.01 |      12 |       |       |          |
|*  1 |  HASH JOIN OUTER     |             |      1 |     27 |     27 |00:00:00.01 |      12 |  1079K|  1079K| 1280K (0)|
|   2 |   TABLE ACCESS FULL  | DEPARTMENTS |      1 |     27 |     27 |00:00:00.01 |       6 |       |       |          |
|   3 |   VIEW               |             |      1 |     11 |     12 |00:00:00.01 |       6 |       |       |          |
|   4 |    HASH GROUP BY     |             |      1 |     11 |     12 |00:00:00.01 |       6 |   894K|   894K| 1732K (0)|
|   5 |     TABLE ACCESS FULL| EMPLOYEES   |      1 |    107 |    107 |00:00:00.01 |       6 |       |       |          |
-------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
*/

/*[문제130] 20번 부서 사원들의 급여의 누적 합계를 아래와 같이 출력하세요.
<화면출력>
EMPLOYEE_ID     SALARY DEPARTMENT_ID      TOTAL
----------- ---------- ------------- ----------
        201      13000            20      13000
        202       6000            20      19000
*/
SELECT e.employee_id, e.salary, e.department_id, sum(t.salary) AS TOTAL
FROM employees e, employees t
WHERE e.department_id = 20 
AND  t.department_id = 20
AND e.employee_id >= t.employee_id
GROUP BY e.employee_id, e.salary, e.department_id
order by 1;

-- 누적함수 over (): group by와 order by를 동시에 할 수 있는 함수
-- COUNT(), MAX(), MIN(), SUM(), AVG(), RANK(), ROW_NUMBER() 등과 같은 집계함수나 분석함수와 함께 사용
SELECT employee_id, salary, department_id, sum(salary) OVER (ORDER BY employee_id) AS TOTAL
FROM employees
where department_id = 20;

SELECT employee_id, salary, department_id, sum(salary) OVER () AS TOTAL
FROM employees
where department_id = 20;

select employee_id, salary, department_id, avg(salary) over () as TOTAL
from employees
where department_id = 20;

-- over(partition by 그룹명): 그룹명으로 묶임
SELECT employee_id, salary, department_id, sum(salary) OVER (PARTITION BY department_id) AS DEPT_TOTAL
from employees;

SELECT employee_id, salary, department_id, sum(salary) OVER(PARTITION BY department_id) AS DEPT_TOTAL, sum(salary) OVER(PARTITION BY department_id ORDER BY employee_id) as TOTAL
from employees;

-- [문제131] 사원테이블에서 급여를 많이 받은 2등까지 사원번호, 급여를 출력 해주세요.
select employee_id, salary
FROM (SELECT employee_id, salary FROM employees ORDER BY 2 DESC)
WHERE ROWNUM <= 2;
--where절 부터 돌아가기 때문에 미정렬시 원하는 값을 얻지 못할수 있음
--구하기위해 부등호는 >,<보다 >=,<=를 이용하는게 효과적
--동일급여사람 누락할수있음>분석함수로 풀어줘야함

-- rank(): 중복순위는 갯수만큼 건너뛰고 순위를 리턴 / dense_rank(): 중복순위 상관없이 순차적 순위 리턴
SELECT employee_id, salary, rank() OVER(ORDER BY salary DESC), DENSE_RANK() OVER(ORDER BY salary DESC)
from employees;

SELECT rank, employee_id, salary
FROM (SELECT DENSE_RANK() OVER(ORDER BY salary DESC) AS rank, employee_id, salary FROM employees)
where rank <= 2;

SELECT department_id, salary, rank() OVER(PARTITION BY department_id ORDER BY salary DESC) as rank1,
DENSE_RANK() OVER(PARTITION BY department_id ORDER BY salary DESC) AS rank2
from employees;

SELECT employee_id, salary, 
sum(salary) OVER(ORDER BY employee_id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) sum_1,
sum(salary) OVER(ORDER BY employee_id) sum_2,
sum(salary) OVER(ORDER BY employee_id ROWS BETWEEN UNBOUNDED PRECEDING AND unbounded FOLLOWING) sum_3
FROM employees;
-- rows between unbounded preceding and current row: 처음부터 현재 행까지 정렬, default
-- rows between unbounded preceding and unbounded following: 처음부터 끝까지 정렬

-- [문제132] 부서별로 급여의 순위를 구하세요.
SELECT rank() OVER(ORDER BY dept_sal desc), department_id, dept_sal
FROM (SELECT department_id, sum(salary) AS dept_sal FROM employees GROUP BY department_id);

SELECT department_id, salary, rank() OVER(PARTITION BY department_id ORDER BY salary DESC) rank1, DENSE_RANK() OVER(PARTITION BY department_id ORDER BY salary DESC) rank2
from employees;

-- [문제133] 자신의 부서 평균급여 보다 많이 받는 사원들의 사번,이름,급여,부서이름을 출력하세요.
select e.employee_id, e.last_name, e.department_id, d.department_name
from (select employee_id, last_name, department_id, salary, avg(salary) over(partition by department_id) as avg_sal from employees) e, departments d
where e.department_id = d.department_id
and e.salary > e.avg_sal;

select e.employee_id,e.last_name,e.salary,d.department_name
from employees e,departments d
where e.department_id=d.department_id
and e.salary > (select avg(salary) from employees where department_id=e.department_id);

select employee_id,last_name, salary,department_name
from(select e.employee_id,e.last_name,e. salary,d.department_name, case when e.salary>avg(e.salary) over (partition by e.department_id) then 'good' end VM_COL_5 from employees e,departments d where e.department_id=d.department_id)
where vm_col_5 is not null;


/*[문제134] SQL문 실행 계획을 확인 한 후 튜닝하세요.
select *
from employees
where job_id = 'IT_PROG'
or department_id = 20;

-----------------------------------------------------------------------------------------
| Id  | Operation         | Name      | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |           |      1 |        |      7 |00:00:00.01 |       7 |
|*  1 |  TABLE ACCESS FULL| EMPLOYEES |      1 |      7 |      7 |00:00:00.01 |       7 |
-----------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter(("JOB_ID"='IT_PROG' OR "DEPARTMENT_ID"=20))
*/

-- 값의 분포도 확인
select distinct job_id, count(*) over(partition by job_id) from employees;
select distinct department_id, count(*) over(partition by department_id) from employees;

-- lnnvl(department_id = 20) : department_id <> 20 or department_id is null
select * from employees where department_id = 20
union all
select * from employees where job_id = 'IT_PROG' and lnnvl(department_id = 20);

-- 값의 분포도에 따라 concat을 사용해야 할 때가 있다 (중복값이 많을 때)
-- use_concat: or 구분을 union all로 변경
select /*+ use_concat */ *
from employees
where job_id = 'IT_PROG'
or department_id = 20;

-- use_concat과 반대 / or concatenation 을 막음
select /*+ no_expand */ *
from employees
where job_id = 'IT_PROG'
or department_id = 20;

-- [문제135] job_id가 AD_PRES를 제외한 사원중에 가장 큰 급여값을 O아주세요. 단 decode함수를 이용하세요.
select max(decode(job_id, 'AD_PRES', null, salary))
from employees;

-- decode 함수의 3번째 값이 4번째 값의 타입에 영향을 줌(3번째 값이 char면 4번째 값도 char화 됨)
-- 따라서 char중 가장 큰 숫자인 9로 인식되어 최대값 9600 출력
select max(decode(job_id, 'AD_PRES', to_number(null), salary)) -- null을 숫자타입으로
from employees;

select max(case when job_id = 'AD_PRES' then null else salary end)
from employees;

--[문제136] SQL문을 union을 union all로 변환하세요. 단 결과건수가 동일해야합니다.
-- 35건
select * from employees where department_id = 80
union
select * from employees where job_id = 'SA_REP';

SELECT * FROM employees e WHERE department_id = 80
UNION ALL
SELECT * FROM employees d WHERE job_id = 'SA_REP'
AND NOT EXISTS(SELECT 'x' FROM employees WHERE department_id = 80 AND employee_id = d.employee_id);

select * from employees where department_id = 80 or job_id = 'SA_REP';

SELECT * FROM employees WHERE department_id = 80
UNION ALL
SELECT * FROM employees WHERE job_id = 'SA_REP'
and department_id <> 80 or department_id is null;

SELECT * FROM employees WHERE department_id = 80
UNION ALL
SELECT * FROM employees WHERE job_id = 'SA_REP' and lnnvl (department_id = 80);