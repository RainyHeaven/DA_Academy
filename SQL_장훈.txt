-- 문제 1 employees 테이블에서 employee_id, last_name과 first_name은 연결해서 표시하고(공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성해 주세요.
select employee_id as "Emp#", last_name || ' ' || first_name as "Employee Name"
from employees;

-- 문제 2 employees 테이블에서 컬럼중에 last_name, job_id를 연결해서 표시하고(쉼표와 공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성하세요.
select last_name || ', ' || job_id as "Employee and Title"
from employees;

-- 문제3 employees테이블에서 급여가 2500 ~ 3500 인 사원들의 모든 정보를 조회하세요.
select *
from employees
where salary >= 2500 and salary <= 3500;

-- 문제4 관리자의 사원번호가 100, 101, 200인 사원들의 모든 정보를 출력해주세요.
select *
from employees
where manager_id = 100 or manager_id = 101 or manager_id = 200;

-- 문제5 last_name 두번째 위치에 소문자 o가 있고 뒤에 어떤 글자가 올지 모른다. 이 조건에 해당하는 데이터를 추출해부세요.
select *
from employees
where last_name like '_o%';

-- 문제6 departments 테이블에 있는 데이터에서 department_name , manager_id 컬럼을 가지고 화면 결과 처럼 출력하는 쿼리문장을 만드세요.
select department_name || 'Department''s Manager Id: ' || manager_id as "Department and Manager"
from departments;

-- 문제7 employees 테이블에 있는 데이터 중에  last_name에 Whalen 이라는 사원의 모든 정보를 출력하세요.
select *
from employees
where last_name = 'Whalen';

-- 문제8 EMPLOYEES 테이블에서 급여가 3000보다 작거나 같은 사원의 last_name, salary 를 출력하세요.
select last_name, salary
from employees
where salary <= 3000;

-- 문제9 EMPLOYEES 테이블에서 salary(급여)값이 10000이상부터 15000이하인 사원들의 모든정보를 출력하세요.
select *
from employees
where salary between 10000 and 15000;

-- 문제10 EMPLOYEES 테이블에서 last_name이 "S"로 시작하는 사원의 last_name, first_name 을 출력하세요.
select last_name, first_name
from employees
where last_name like 'S%';

-- 문제11 last_name의 세번째 문자가 "o"인 모든 사원의 last_name을 출력하세요.
select last_name
from employees
where last_name like '__o%';

-- 문제12 employees 테이블에 있는 데이터 중에 job_id에 SA_ 문자열로 시작되는 사원들의 employee_id, last_name, job_id를 출력하세요.
select employee_id, last_name, job_id 
from employees
where job_id like 'SA@_%' escape '@';

-- 문제13 employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' and salary >= 10000;

-- 문제14 employees 테이블에서  job_id 컬럼의 값이  SA로 시작하거나 10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' or salary >= 10000;

-- 문제15 employees 테이블에서  job_id컬럼의 값이  IT_PROG, ST_CLERK , SA_REP가 아닌 모든 사원의 last_name, job_id를  출력해주세요.
select last_name, job_id
from employees
where job_id not in ('IT_PROG','ST_CLERK', 'SA_REP');

-- 문제16 employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받고 2005년도에 입사한(hire_date) 모든 사원들의 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' and salary >= 10000 and hire_date between to_date('2005.01.01', 'yyyy.mm.dd') and to_date('2005.12.31', 'yyyy.mm.dd');

-- 문제17 employees 테이블에서 job_id 컬럼의 값이 SA_REP 또는 AD_PRES 사원들 중에 급여가 10000 초가 한 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id in ('SA_REP', 'AD_PRES') and salary > 10000;

select last_name, salary
from employees
order by salary desc;

select department_id, salary
from employees
order by department_id asc, salary desc;

-- 문제18 employees 테이블에 last_name 컬럼의 값 중에  "J" 또는 "A" 또는 "M"으로 시작하는 사원들의 last_name(첫번째 문자는대문자, 나머지는 모두 소문자)과 last_name의 길이를 표시하는 query 를 작성합니다.
-- 사원들의 last_name을 기준으로 결과를 오름차순 정렬해 주세요. 
select initcap(last_name), length(last_name)
from employees
where last_name like 'J%' or last_name like 'A%' or last_name like 'M%'
order by last_name;

select initcap(last_name), length(last_name)
from employees
where instr(last_name, 'J') = 1 or instr(last_name, 'A') = 1 or instr(last_name, 'M') = 1
order by last_name;

select initcap(last_name), length(last_name)
from employees
where substr(last_name, 1, 1) in ('J', 'M', 'A')
order by last_name;

-- 문제19 employees테이블에서 department_id(부서코드)가 50번 사원들 중에 last_name에 두번째 위치에 "a"글자가 있는 사원들을 조회하세요. 
select *
from employees
where department_id = 50 and last_name like '_a%';

select *
from employees
where department_id = 50 and substr(last_name, 2, 1) = 'a';

select *
from employees
where department_id = 50 and instr(last_name, 'a', 2, 1) = 2;

-- 문제20 사원의 last_name,hire_date 및 근무 6 개월 후 월요일에 해당하는 날짜를 조회하세요. 열별칭은 REVIEW 로 지정합니다. 
select last_name, hire_date, next_day(add_months(hire_date, 6), '월요일') as REVIEW
from employees;

-- 문제21 15년 이상 근무한 사원들의 employee_id(사원번호), hire_date(입사일), 근무개월수를 조회하세요.
select employee_id, hire_date, months_between(sysdate, hire_date) as work_months
from employees
where months_between(sysdate, hire_date) >= (15*12);

-- 문제22 employees(사원)테이블에 있는 last_name의 세번째 문자가 'a' 또는 'e'가 포함된 모든 사원의 last_name을 조회하세요.
select last_name
from employees
where substr(last_name, 3, 1) in ('a', 'e');

select last_name
from employees
where last_name like '__a%' or last_name like '__e%';

select last_name
from employees
where instr(last_name, 'a', 3, 1) = 3 or instr(last_name, 'e', 3, 1) = 3;

-- 스타트지점을 바꾸는 것은 작동 안하는 경우가 있음
select last_name
from employees
where instr(last_name, 'a') = 3 
or instr(last_name, 'a', 1, 2) = 3
or instr(last_name, 'a', 1, 3) = 3
or instr(last_name, 'e') = 3 
or instr(last_name, 'e', 1, 2) = 3
or instr(last_name, 'e', 1, 3) = 3;

-- 문제23 employees(사원)테이블에 있는  80번 부서(department_id) 사원중에 commission_pct 값이 0.2 이고 job_id는 SA_MAN인 사원의 employee_id, last_name, salary를 조회하세요.
select employee_id, last_name, salary
from employees
where department_id = 80 and commission_pct = 0.2 and job_id = 'SA_MAN';

-- 문제24 사원의 employees(사원)테이블에 있는 last_name,hire_date 및 근무 6 개월 후 첫번째 월요일에 해당하는 급여 협상 날짜를 표시합니다.
-- 열 레이블을 REVIEW 로 지정합니다. 날짜는 "월요일, the Second of 4, 2007"과 유사한 형식으로 나타나도록 지정합니다.
select last_name, hire_date, to_char(next_day(add_months(hire_date, 6), '월요일'), 'day, "the" ddspth "of" dd, yyyy') as REVIEW
from employees;

-- 문제25 employees(사원) 테이블에서  일요일에 입사한 사원의 정보를 조회하세요.
select *
from employees
where to_char(hire_date, 'day') = '일요일';

select *
from employees
where to_char(hire_date, 'd') = '1';

-- 문제26 짝수달에 입사한 사원의 정보를 조회하세요.
select *
from employees
where mod(to_number(to_char(hire_date, 'fmmm')), 2) = 0;

-- 문제27 2006년도에 홀수 달에 입사한 사원의 employee_id, last_name, hire_date를 조회하세요.
select employee_id, last_name, hire_date
from employees
where hire_date  between to_date('20050101', 'yyyymmdd') and to_date('20051231', 'yyyymmdd') and mod(to_number(to_char(hire_date, 'fmmm')), 2) = 1;

-- 문제 28 아래 화면의 결과 처럼 사원의  last_name,  salary, salary 값을 1000당 별표를 하나를 출력하는  query문을 작성하세요. 
select last_name, salary, lpad('*', trunc(salary/1000), '*') as "STAR"
from employees
order by salary desc;

-- 문제 29 아래 화면결과 처럼 출력하세요.
select '현재 서버의 날짜 시간 : ' || to_char(sysdate, 'yyyymmdd hh:mi:ss am') as "현재날짜시간"
from dual;

-- 문제 30 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 하루 전 : ' || to_char(sysdate-1, 'yyyymmdd hh24:mi:ss') as "하루전"
from dual;

-- 문제 31 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 1시간 전 : ' || to_char(sysdate-1/24, 'yyyymmdd hh24:mi:ss') as "1시간전"
from dual;

select '서버의 시간을 기준으로 1시간 전 : ' || to_char(sysdate-to_dsinterval('0 01:00:00'), 'yyyymmdd hh24:mi:ss') as "1시간전"
from dual;

-- 문제 32 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 5분 전 : ' || to_char(sysdate-to_dsinterval('0 00:05:00'), 'yyyymmdd hh24:mi:ss') as "5분전"
from dual;

select '서버의 시간을 기준으로 5분 전 : ' || to_char(sysdate-5/(24*60), 'yyyymmdd hh24:mi:ss') as "5분전"
from dual;

-- 문제 33 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 10초 전 : ' || to_char(sysdate-to_dsinterval('0 00:00:10'), 'yyyymmdd hh24:mi:ss') as "10초전"
from dual;

select '서버의 시간을 기준으로 10초 전 : ' || to_char(sysdate-10/(24*60*60), 'yyyymmdd hh24:mi:ss') as "10초전"
from dual;

-- 문제 34 JOB_ID 열의 값을 기준으로 모든 사원의 등급(GRADE)을 표시하는 query 를 작성하세요.
select job_id, decode(job_id, 'AD_PRES', 'A', 'ST_MAN', 'B', 'IT_PROG', 'C', 'SA_REP', 'D', 'ST_CLERK', 'E', 'Z') as "GRADE"
from employees;

-- 문제 35 사원테이블에  연봉을 계산 하는 쿼리문을 작성하세요 
-- 단 commission_pct 값이 null 아니면 (salary*12) + (salary*12*commission_pct) 이값이 수행되고
-- null 이면 salary * 12 가 수행합니다. 수행 결과는 화면처럼 만드세요.
-- (nvl, nvl2,  coalesce, case, decode 함수를 사용하여 각각으로 수행해서 보고서 작성해 주세요)
select last_name, salary, commission_pct, decode(commission_pct, null, salary * 12, (salary * 12) + (salary * 12 * commission_pct)) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, (salary * 12) + (salary * 12 * nvl(commission_pct, 0)) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, nvl2(commission_pct, (salary * 12) + (salary * 12 * commission_pct), salary * 12) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, coalesce((salary * 12) + (salary * 12 * commission_pct), salary * 12) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, case when commission_pct is null then salary * 12 else (salary * 12) + (salary * 12 * commission_pct) end as "ANN_SAL"
from employees;

-- 문제36 모든 사원의 최고급여, 최저급여, 합계 및 평균 급여를 찾습니다. 
-- 열 레이블을 각각 Maximum, Minimum, Sum 및 Average 로 지정합니다. 
-- 결과를 소수점은 반올림해서 정수값으로 출력하세요.
select max(salary) as "Maximum", min(salary) as "Minimum", sum(salary) as "Sum", round(avg(salary), 0) as "Average"
from employees;

-- 문제 37 2008년도에 입사한 사원들의 job_id별 인원수를 구하고 인원수가 많은 순으로 출력하세요. 
select job_id, count(*)
from employees
where to_char(hire_date, 'yyyy') = '2008'
group by job_id
order by 2 desc;

-- 문제 38 job_id별로 총액급여를 구합니다. 단 CLERK글자가 있는 job_id는 제외하고 총액급여는 13000가 넘는 정보를 출력하면서 총액 급여를 기준으로 내림차순 정렬하세요.
select job_id, sum(salary) as "payroll"
from employees
where job_id not like '%CLERK%'
group by job_id
having  sum(salary) > 13000
order by 2 desc;

-- 문제 39 입사한 년도별로 급여의 총액을 출력하세요.
select to_char(hire_date, 'yyyy'), sum(salary)
from employees
group by to_char(hire_date, 'yyyy');

select extract(year from hire_date), sum(salary)
from employees
group by extract(year from hire_date);

-- 문제 40 입사한 달별 인원수를 출력해주세요.
select to_char(hire_date, 'mm'), count(*)
from employees
group by to_char(hire_date, 'mm')
order by 1;

-- 문제 41 사원의 총 수와 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요.
-- 결과값에 1이 아닌 0이나 문자를 넣어도 무방(행 수를 세기 때문에)
select count(*) as TOTAL, count(decode(extract(year from hire_date), 2005, 1)) as "2005", count(decode(extract(year from hire_date), 2006, 1)) as "2006", count(decode(extract(year from hire_date), 2007, 1)) as "2007", count(decode(extract(year from hire_date), 2008, 1)) as "2008"
from employees;

-- 결과값에 1이 들어가야 합계가 계산됨
select count(*) as TOTAL, sum(case to_char(hire_date, 'yyyy') when '2005' then 1 end) as "2005", sum(case to_char(hire_date, 'yyyy') when '2006' then 1 end) as "2006", sum(case to_char(hire_date, 'yyyy') when '2007' then 1 end) as "2007", sum(case to_char(hire_date, 'yyyy') when '2008' then 1 end) as "2008"

-- 문제 42 모든 사원의 last_name, department_id, department_name을 표시하기 위한 query 를 작성합니다.

--오라클

select e.last_name, e.department_id, d.department_name
from employees e, departments d
where e.department_id = d.department_id(+);

--ANSI표준
select e.last_name, e.department_id, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id;

-- 문제 43 부서 80에 속하는 last_name, job_id, department_name, city를 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, e.job_id, d.department_name, l.city
from employees e, departments d, locations l
where e.department_id = 80 and e.department_id = d.department_id and d.location_id = l.location_id;

--ANSI표준
select e.last_name, e.job_id, d.department_name, l.city
from employees e join departments d
on e.department_id = d.department_id 
join locations l
on d.location_id = l.location_id
where e.department_id = 80;

--문제 44 commission_pct 에 null이 아닌 모든 사원의 last_name, department_name, location_id, city를 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, d.department_name, d.location_id, l.city
from employees e, departments d, locations l
where e.commission_pct is not null and e.department_id = d.department_id(+) and d.location_id = l.location_id(+);

--ANSI표준
select e.last_name, d.department_name, d.location_id, l.city
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
where e.commission_pct is not null;

--문제 45 last_name에 a(소문자)가 포함된 모든 사원의 last_name, department_name 을 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, d.department_name
from employees e, departments d
where e.last_name like '%a%' and e.department_id = d.department_id(+);

--ANSI표준
select e.last_name, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
where e.last_name like '%a%';

select e.last_name, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
where instr(e.last_name, 'a') >=1;

-- 문제 46 locations 테이블에 있는 city컬럼에  Toronto도시에서 근무하는 모든 사원의 last_name, job_id, department_id, department_name 을 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, e.job_id, e.department_id, d.department_name
from employees e, departments d, locations l
where l.city = 'Toronto' and e.department_id = d.department_id and d.location_id = l.location_id;

--ANSI표준
select e.last_name, e.job_id, e.department_id, d.department_name
from employees e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id
where l.city = 'Toronto';
desc employees

-- 문제 47 2006년도에 입사한 사원들의 부서이름별로 급여의 총액, 평균을 출력하세요.
--오라클
select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e, departments d
where extract(year from e.hire_date) = 2006 and e.department_id = d.department_id
-- extract로 뽑아내면 인덱스 스캔이 아닌 풀 스캔이 됨
group by d.department_name;

--ANSI표준
select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e join departments d
on e.department_id = d.department_id
where to_char(e.hire_date, 'yyyy') = '2006' 
-- to_char로 뽑아내면 인덱스 스캔이 아닌 풀 스캔이 됨
group by d.department_name;

select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e join departments d
on e.department_id = d.department_id
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
group by d.department_name;

-- 문제 48 2006년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요.
--오라클
select l.city, sum(e.salary), avg(e.salary)
from employees e, departments d, locations l
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
and e.department_id = d.department_id
and d.location_id = l.location_id
group by l.city;

--ANSI표준
select l.city, sum(e.salary), avg(e.salary)
from employees e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
group by l.city;

-- 문제49 2007년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요. 단 부서 배치를 받지 않는 사람들의 급여의 총액, 평균도 구하세요.
--오라클
select l.city, sum(e.salary), avg(e.salary)
from employees e, departments d, locations l
where e.hire_date >= to_date('20070101', 'yyyymmdd') and e.hire_date < to_date('20080101', 'yyyymmdd')
and e.department_id = d.department_id(+)
and d.location_id = l.location_id(+)
group by l.city;

--ANSI표준
select l.city, sum(e.salary), avg(e.salary)
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
where e.hire_date >= to_date('20070101', 'yyyymmdd') and e.hire_date < to_date('20080101', 'yyyymmdd')
group by l.city;

-- 문제 50 사원들의 사번, 급여, 급여등급, 부서이름을 출력하세요. 부서배치를 받지 않는 사원은 제외시켜주세요.
--오라클
select e.employee_id, e.salary, j.grade_level, d.department_name
from employees e, departments d, job_grades j
where e.department_id = d.department_id and e.salary between j.lowest_sal and j.highest_sal;

--ANSI표준
select e.employee_id, e.salary, j.grade_level, d.department_name
from employees e join departments d
on e.department_id = d.department_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal;

-- 문제 51 사원들의 사번, 급여, 급여등급, 부서이름, 근무 도시 정보를 출력하세요. 부서배치를 받지 않는 사원도 포함시켜주세요.
--오라클
select e.employee_id, e.salary, j.grade_level, d.department_name, l.city
from employees e, departments d, job_grades j, locations l
where e.department_id = d.department_id(+)
and e.salary between j.lowest_sal and j.highest_sal
and d.location_id = l.location_id(+);

--ANSI표준
select e.employee_id, e.salary, j.grade_level, d.department_name, l.city
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal;

-- 문제 52 사원들의 last_name,salary,grade_level, department_name을 출력하는데 last_name에 a문자가 2개 이상 포함되어 있는 사원들을 출력하세요.
--오라클
select e.last_name, e.salary, j.grade_level, d.department_name
from employees e, job_grades j, departments d
where instr(e.last_name, 'a', 1, 2) >= 2 and e.department_id = d.department_id(+) and e.salary between j.lowest_sal and j.highest_sal;

--ANSI표준
select e.last_name, e.salary, j.grade_level, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal
where instr(e.last_name, 'a', 1, 2) >= 2;

-- 문제 53 141번 사원의 job_id와 동일한 job_id를 가진 사원들 중에 141번 사원의 급여보다 더 많이 받는 사원을 출력해주세요
select *
from employees
where job_id = (select job_id
                from employees
                where employee_id = 141)
and salary > (select salary
                from employees
                where employee_id = 141);
                
-- 문제 54 최소월급을 받은 사원들의 정보를 출력해주세요.
select *
from employees
where salary = (select min(salary)
                from employees);

-- 문제 55 평균 급여가 가장 낮은 job_id를 찾아 주세요.
select job_id
from employees
group by job_id
having avg(salary) = (select min(avg(salary))
                      from employees
                      group by job_id);
                      
-- 문제 56 부서별로 최소 급여자들을 출력해주세요.
select *
from employees
where salary in (select min(salary) from employees group by department_id)
order by department_id;

-- 문제 57 last_name 에 문자 "u"가 포함된 사원과 같은 부서에 근무하는 모든 사원의 employee_id, last_name 을 출력하세요.
select employee_id, last_name
from employees
where department_id in (select distinct department_id from employees where last_name like '%u%');

-- 문제 58 부서 위치(location_id) ID 가 1700 인 모든 사원의 last_name, department_id, job_id 를 출력하세요.(조인, 서브쿼리)
--오라클
select e.last_name, e.department_id, e.job_id
from employees e, departments d
where e.department_id = d.department_id
and d.location_id = 1700;

--ANSI표준
select e.last_name, e.department_id, e.job_id
from employees e join departments d
on e.department_id = d.department_id
where d.location_id = 1700;

--서브쿼리
select last_name, department_id, job_id
from employees
where department_id in (select department_id from departments where location_id = 1700);

-- 문제 59 King 에게 보고하는 모든 사원의 last_name 및 salary 출력하세요.(조인, 서브쿼리)
--오라클
select e.last_name, e.salary
from employees e, employees m
where e.manager_id = m.employee_id
and m.last_name = 'King';

--ANSI표준
select e.last_name, e.salary
from employees e join employees m
on e.manager_id = m.employee_id
where m.last_name = 'King';

--서브쿼리
select last_name, salary
from employees
where manager_id in (select distinct employee_id from employees where last_name = 'King');

-- 문제 60 부서 이름(department_name) 이 Executive 부서의 모든 사원에 대한 department_id, last_name, job_id  출력하세요.
--오라클
select e.department_id, e.last_name, e.job_id
from employees e, departments d
where e.department_id = d.department_id
and d.department_name = 'Executive';

--ANSI표준
select e.department_id, e.last_name, e.job_id
from employees e join departments d
on e.department_id = d.department_id
where d.department_name = 'Executive';

--서브쿼리
select department_id, last_name, job_id
from employees
where department_id = (select department_id from departments where department_name = 'Executive');

-- 문제 61 60부서에 소속된 모든 사원의 급여(salary)보다 높은(max) 급여를 받는 모든 사원 출력하세요.
select *
from employees
where salary > all (select salary from employees where department_id = 60);

select *
from employees
where salary > (select max(salary) from employees where department_id = 60);

-- 문제 62 전체 평균 급여보다 많은 급여를 받고 last_name에 "u"가 포함된 사원이 있는 부서에서 근무하는 모든 사원의 employee_id, last_name, salary 출력하세요
select employee_id, last_name, salary
from employees
where salary > (select avg(salary) from employees)
and department_id in (select distinct department_id from employees where last_name like '%u%');

-- 문제 63 관리자 사원들의 정보를 출력해주세요 
select *
from employees
where employee_id in (select distinct manager_id from employees);

-- 문제 64 관리자가 아닌 사원들의 정보를 출력해 주세요
-- 서브쿼리에 null 값이 있을 경우 not in 연산자를 사용할 수 없음 
select *
from employees
where employee_id not in (select distinct manager_id from employees where manager_id is not null);

select *
from employees
where employee_id != all (select distinct manager_id from employees where manager_id is not null);

-- 문제 65 last_name에 Davies 사원보다 늦게 입사한 사원 중에 급여가 Davies 사원의 급여 이하로 받고 있는 사원들을 출력해주세요.
--서브쿼리
select *
from employees
where salary <= (select salary from employees where last_name = 'Davies')
and hire_date > (select hire_date from employees where last_name = 'Davies');

--오라클
select e.*
from employees e, employees d
where e.salary <= d.salary
and e.hire_date > d.hire_date
and d.last_name = 'Davies';

--ANSI표준
select e.*
from employees e join employees d
on e.salary <= d.salary
and e.hire_date > d.hire_date
where d.last_name = 'Davies';

-- 문제 66 자신의 부서 평균 급여보다 더 많은 급여를 받는 사원들의 정보를 출력해주세요
select *
from employees o
where o.salary > (select avg(salary) from employees where department_id = o.department_id);

-- 문제 67 두번 이상 job_id를 바꾼 사원 출력해주세요.
select j.*
from job_history j
where 2 <= (select count(employee_id) from job_history where employee_id = j.employee_id)
order by j.employee_id;

-- 문제 68 관리자 사원에 대해서 출력해주세요
select *
from employees e
where employee_id in (select distinct manager_id from employees where manager_id is not null);

select *
from employees o
where exists (select 'x'--문법 오류를 막기 위한 의미없는 표현 'x'
              from employees
              where manager_id = o.employee_id);
              
-- 문제 69 관리자가 아닌 사원에 대해서 출력해주세요
select *
from employees e
where employee_id not in (select distinct manager_id from employees where manager_id is not null);

select *
from employees o
where not exists (select 'x'
              from employees
              where manager_id = o.employee_id);

-- 문제 70 사원이 없는 부서 정보만 출력해주세요
select *
from departments
where department_id not in (select department_id from employees where department_id is not null);

select *
from departments d
where not exists (select 'x' from employees where department_id = d.department_id);

-- 문제 71 자신의 부서안에서 자신보다 늦게 입사하고 자신보다 급여를 많이받는 사람이 있는 사람들을 찾아주세요
select *
from employees e
where exists (select 'x' from employees where department_id = e.department_id and salary > e.salary and hire_date > e.hire_date)
and e.department_id = 50;

select distinct e.*
from employees e, employees l
where e.hire_date < l.hire_date 
and e.salary < l.salary
and e.department_id = l.department_id
and e.department_id = 50;

-- 문제 72 사원수가 3명 미만인 부서번호, 부서이름, 인원수를 출력해주세요
select d.department_id, d.department_name, m.peoples
from departments d, (select department_id, count(employee_id) peoples from employees where department_id is not null group by department_id having count(employee_id) < 3) m
where d.department_id = m.department_id
order by d.department_id;

select d.department_id, d.department_name, count(*)
from employees e, departments d
where e.department_id = d.department_id
group by d.department_id, d.department_name
having count(*) < 3
order by d.department_id;

--inline view를 통해 join의 양을 줄일 수 있다

-- 문제 73번 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요.
select count(*) as TOTAL, count(decode(extract(year from hire_date), 2005, 1)) as "2005", count(decode(extract(year from hire_date), 2006, 1)) as "2006", count(decode(extract(year from hire_date), 2007, 1)) as "2007", count(decode(extract(year from hire_date), 2008, 1)) as "2008"
from employees;

select to_char(hire_date, 'yyyy'), count(*) from employees group by to_char(hire_date, 'yyyy');

select 
       decode(hire_year, '2001', people) as "2001",
       decode(hire_year, '2002', people) as "2002",
       decode(hire_year, '2003', people) as "2003",
       decode(hire_year, '2004', people) as "2004",
       decode(hire_year, '2005', people) as "2005",
       decode(hire_year, '2006', people) as "2006",
       decode(hire_year, '2007', people) as "2007",
       decode(hire_year, '2008', people) as "2008"
from (select to_char(hire_date, 'yyyy') hire_year, count(*) people from employees group by to_char(hire_date, 'yyyy'));

SELECT 
       max(decode(year,'2001',cn)) "2001",
       max(decode(year,'2002',cn)) "2002",
       max(decode(year,'2003',cn)) "2003",
       max(decode(year,'2004',cn)) "2004",   
       max(decode(year,'2005',cn)) "2005",
       max(decode(year,'2006',cn)) "2006",
       max(decode(year,'2007',cn)) "2007",
       max(decode(year,'2008',cn)) "2008"       
FROM (
              SELECT to_char(hire_date, 'yyyy') year, count(*) cn
              FROM employees
              GROUP BY(to_char(hire_date, 'yyyy')));

-- 문제 74 평균 급여가 가장 높은 부서의 부서 번호와 최고, 최저, 평균 급여를 출력하세요.
select department_id, max(salary), min(salary), avg(salary) as average
from employees
group by department_id
having avg(salary) = (select max(avg(salary)) from employees group by department_id);

-- 부서별 최고, 최저, 평균급여 테이블
select department_id, max(salary), min(salary), avg(salary) as average
from employees
group by department_id;

-- 최고 평균급여 테이블
select max(avg(salary)) from employees group by department_id;


-- 문제 75 사원 수가 가장 많은 부서이름, 도시, 인원수를 출력해주세요.
select d.department_name, l.city, e.cn
from (select department_id, count(*) cn from employees group by department_id having count(*) 
      = (select max(count(*)) from employees group by department_id)) e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id;      

-- 문제 76 사원 채용 수가 가장 많은 요일을 출력해주세요.
select to_char(hire_date, 'day'), count(*)
from employees
group by to_char(hire_date, 'day')
having count(*) = (select max(count(*)) from employees group by to_char(hire_date, 'day'));

-- 문제 77 사원 채용 수가 가장 많은 요일에 입사한 사원들의 last_name, 요일을 출력해주세요.
select last_name, to_char(hire_date, 'day')
from employees
where to_char(hire_date, 'day') in (select to_char(hire_date, 'day') from employees group by to_char(hire_date, 'day')
having count(*) = (select max(count(*)) from employees group by to_char(hire_date, 'day')));

-- 문제 78 부서별로 인원수를 출력주세요.
select 
       max(decode(department_id, '10', cn)) as "10",
       max(decode(department_id, '20', cn)) as "20",
       max(decode(department_id, '30', cn)) as "30",
       max(decode(department_id, '40', cn)) as "40",
       max(decode(department_id, '50', cn)) as "50",
       max(decode(department_id, '60', cn)) as "60",
       max(decode(department_id, '70', cn)) as "70",
       max(decode(department_id, '80', cn)) as "80",
       max(decode(department_id, '90', cn)) as "90",
       max(decode(department_id, '100', cn)) as "100",
       max(decode(department_id, '110', cn)) as "110",
       max(decode(department_id, null, cn)) as "부서가 없는 사원"
from (select department_id, count(*) cn from employees group by department_id);

-- 문제 79 부서 번호와 급여가 커미션을 받는 사원의 부서 번호 및 급여와 일치하는 모든  사원의 last_name, department_id, salary 를 표시하는 query 를 작성하세요.
select last_name, department_id, salary
from employees
where (department_id, salary) in (select department_id, salary from employees where commission_pct is not null);

--커미션을 받는 사원 테이블
select department_id, salary from employees where commission_pct is not null;

-- 문제 80 급여와 커미션이 location_id가 1700 에 있는 사원의 급여 및 커미션과 일치하는 사원의 last_name, department_name, salary를 출력해주세요.
select e.last_name, d.department_name, e.salary
from employees e join departments d
on e.department_id = d.department_id
where (salary, nvl(e.commission_pct, 0)) in (select e.salary, nvl(e.commission_pct, 0) from employees e, departments d where e.department_id = d.department_id and d.location_id = 1700);

-- location_id = 1700인 사원들의 급여와 커미션
select e.salary, nvl(e.commission_pct, 0) 
from employees e, departments d 
where e.department_id = d.department_id and d.location_id = 1700;

-- 문제 81 select department_id, department_name from departments where location_id = 1700
select last_name, hire_date, salary, commission_pct
from employees
where (salary, nvl(commission_pct, 0)) = (select salary, nvl(commission_pct, 0) from employees where last_name = 'Johnson')
and last_name not like 'Johnson';

-- Johnson의 급여와 커미션
select salary, commission_pct from employees where last_name = 'Johnson';

-- 문제 82 부서의 총 급여가 전체 부서의 평균 급여보다 많은 부서의 이름과 총 급여를 표시하도록 query를 작성하세요.
--null 부서 미포함
select d.department_name, sum(e.salary)
from employees e join departments d
on e.department_id = d.department_id
group by d.department_name
having sum(e.salary) > (select avg(dep_sum) from (select department_id, sum(salary) dep_sum from employees where department_id is not null group by department_id));

--null 부서 포함
select d.department_name, sum(e.salary)
from employees e join departments d
on e.department_id = d.department_id
group by d.department_name
having sum(salary) > (select avg(dep_sum) from (select department_id, sum(salary) dep_sum from employees group by department_id));

--null 부서 포함(선생님 답)
select d.department_name, e.average
from (select department_id, sum(salary) average from employees group by department_id having sum(salary) > (select avg(average) from (select sum(salary) average from employees group by department_id))) e, departments d
where e.department_id = d.department_id;

-- 전체 부서의 총급여 평균
select avg(dep_sum)
from (select department_id, sum(salary) dep_sum from employees where department_id is not null group by department_id);

-- 각 부서별 총급여
select department_id, sum(salary)
from employees
where department_id is not null
group by department_id;

--with: 재사용이 가능한 가상테이블 생성
with
dept_cost as (select d.department_name, sum(e.salary) as sumsal  from employees e, departments d where e.department_id = d.department_id(+) group by d.department_name), 
avg_cost as (select sum(sumsal) / count(*) as deptavg from dept_cost)
select *
from dept_cost
where sumsal > (select deptavg from avg_cost);