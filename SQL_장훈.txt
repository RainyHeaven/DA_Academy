-- 문제 1 employees 테이블에서 employee_id, last_name과 first_name은 연결해서 표시하고(공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성해 주세요.
select employee_id as "Emp#", last_name || ' ' || first_name as "Employee Name"
from employees;

-- 문제 2 employees 테이블에서 컬럼중에 last_name, job_id를 연결해서 표시하고(쉼표와 공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성하세요.
select last_name || ', ' || job_id as "Employee and Title"
from employees;

-- 문제3 employees테이블에서 급여가 2500 ~ 3500 인 사원들의 모든 정보를 조회하세요.
select *
from employees
where salary >= 2500 and salary <= 3500;

-- 문제4 관리자의 사원번호가 100, 101, 200인 사원들의 모든 정보를 출력해주세요.
select *
from employees
where manager_id = 100 or manager_id = 101 or manager_id = 200;

-- 문제5 last_name 두번째 위치에 소문자 o가 있고 뒤에 어떤 글자가 올지 모른다. 이 조건에 해당하는 데이터를 추출해부세요.
select *
from employees
where last_name like '_o%';

-- 문제6 departments 테이블에 있는 데이터에서 department_name , manager_id 컬럼을 가지고 화면 결과 처럼 출력하는 쿼리문장을 만드세요.
select department_name || 'Department''s Manager Id: ' || manager_id as "Department and Manager"
from departments;

-- 문제7 employees 테이블에 있는 데이터 중에  last_name에 Whalen 이라는 사원의 모든 정보를 출력하세요.
select *
from employees
where last_name = 'Whalen';

-- 문제8 EMPLOYEES 테이블에서 급여가 3000보다 작거나 같은 사원의 last_name, salary 를 출력하세요.
select last_name, salary
from employees
where salary <= 3000;

-- 문제9 EMPLOYEES 테이블에서 salary(급여)값이 10000이상부터 15000이하인 사원들의 모든정보를 출력하세요.
select *
from employees
where salary between 10000 and 15000;

-- 문제10 EMPLOYEES 테이블에서 last_name이 "S"로 시작하는 사원의 last_name, first_name 을 출력하세요.
select last_name, first_name
from employees
where last_name like 'S%';

-- 문제11 last_name의 세번째 문자가 "o"인 모든 사원의 last_name을 출력하세요.
select last_name
from employees
where last_name like '__o%';

-- 문제12 employees 테이블에 있는 데이터 중에 job_id에 SA_ 문자열로 시작되는 사원들의 employee_id, last_name, job_id를 출력하세요.
select employee_id, last_name, job_id 
from employees
where job_id like 'SA@_%' escape '@';

-- 문제13 employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' and salary >= 10000;

-- 문제14 employees 테이블에서  job_id 컬럼의 값이  SA로 시작하거나 10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' or salary >= 10000;

-- 문제15 employees 테이블에서  job_id컬럼의 값이  IT_PROG, ST_CLERK , SA_REP가 아닌 모든 사원의 last_name, job_id를  출력해주세요.
select last_name, job_id
from employees
where job_id not in ('IT_PROG','ST_CLERK', 'SA_REP');

-- 문제16 employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받고 2005년도에 입사한(hire_date) 모든 사원들의 정보를 출력하세요.
select *
from employees
where job_id like 'SA%' and salary >= 10000 and hire_date between to_date('2005.01.01', 'yyyy.mm.dd') and to_date('2005.12.31', 'yyyy.mm.dd');

-- 문제17 employees 테이블에서 job_id 컬럼의 값이 SA_REP 또는 AD_PRES 사원들 중에 급여가 10000 초가 한 사원들의 모든 정보를 출력하세요.
select *
from employees
where job_id in ('SA_REP', 'AD_PRES') and salary > 10000;

select last_name, salary
from employees
order by salary desc;

select department_id, salary
from employees
order by department_id asc, salary desc;

-- 문제18 employees 테이블에 last_name 컬럼의 값 중에  "J" 또는 "A" 또는 "M"으로 시작하는 사원들의 last_name(첫번째 문자는대문자, 나머지는 모두 소문자)과 last_name의 길이를 표시하는 query 를 작성합니다.
-- 사원들의 last_name을 기준으로 결과를 오름차순 정렬해 주세요. 
select initcap(last_name), length(last_name)
from employees
where last_name like 'J%' or last_name like 'A%' or last_name like 'M%'
order by last_name;

select initcap(last_name), length(last_name)
from employees
where instr(last_name, 'J') = 1 or instr(last_name, 'A') = 1 or instr(last_name, 'M') = 1
order by last_name;

select initcap(last_name), length(last_name)
from employees
where substr(last_name, 1, 1) in ('J', 'M', 'A')
order by last_name;

-- 문제19 employees테이블에서 department_id(부서코드)가 50번 사원들 중에 last_name에 두번째 위치에 "a"글자가 있는 사원들을 조회하세요. 
select *
from employees
where department_id = 50 and last_name like '_a%';

select *
from employees
where department_id = 50 and substr(last_name, 2, 1) = 'a';

select *
from employees
where department_id = 50 and instr(last_name, 'a', 2, 1) = 2;

-- 문제20 사원의 last_name,hire_date 및 근무 6 개월 후 월요일에 해당하는 날짜를 조회하세요. 열별칭은 REVIEW 로 지정합니다. 
select last_name, hire_date, next_day(add_months(hire_date, 6), '월요일') as REVIEW
from employees;

-- 문제21 15년 이상 근무한 사원들의 employee_id(사원번호), hire_date(입사일), 근무개월수를 조회하세요.
select employee_id, hire_date, months_between(sysdate, hire_date) as work_months
from employees
where months_between(sysdate, hire_date) >= (15*12);

-- 문제22 employees(사원)테이블에 있는 last_name의 세번째 문자가 'a' 또는 'e'가 포함된 모든 사원의 last_name을 조회하세요.
select last_name
from employees
where substr(last_name, 3, 1) in ('a', 'e');

select last_name
from employees
where last_name like '__a%' or last_name like '__e%';

select last_name
from employees
where instr(last_name, 'a', 3, 1) = 3 or instr(last_name, 'e', 3, 1) = 3;

-- 스타트지점을 바꾸는 것은 작동 안하는 경우가 있음
select last_name
from employees
where instr(last_name, 'a') = 3 
or instr(last_name, 'a', 1, 2) = 3
or instr(last_name, 'a', 1, 3) = 3
or instr(last_name, 'e') = 3 
or instr(last_name, 'e', 1, 2) = 3
or instr(last_name, 'e', 1, 3) = 3;

-- 문제23 employees(사원)테이블에 있는  80번 부서(department_id) 사원중에 commission_pct 값이 0.2 이고 job_id는 SA_MAN인 사원의 employee_id, last_name, salary를 조회하세요.
select employee_id, last_name, salary
from employees
where department_id = 80 and commission_pct = 0.2 and job_id = 'SA_MAN';

-- 문제24 사원의 employees(사원)테이블에 있는 last_name,hire_date 및 근무 6 개월 후 첫번째 월요일에 해당하는 급여 협상 날짜를 표시합니다.
-- 열 레이블을 REVIEW 로 지정합니다. 날짜는 "월요일, the Second of 4, 2007"과 유사한 형식으로 나타나도록 지정합니다.
select last_name, hire_date, to_char(next_day(add_months(hire_date, 6), '월요일'), 'day, "the" ddspth "of" dd, yyyy') as REVIEW
from employees;

-- 문제25 employees(사원) 테이블에서  일요일에 입사한 사원의 정보를 조회하세요.
select *
from employees
where to_char(hire_date, 'day') = '일요일';

select *
from employees
where to_char(hire_date, 'd') = '1';

-- 문제26 짝수달에 입사한 사원의 정보를 조회하세요.
select *
from employees
where mod(to_number(to_char(hire_date, 'fmmm')), 2) = 0;

-- 문제27 2006년도에 홀수 달에 입사한 사원의 employee_id, last_name, hire_date를 조회하세요.
select employee_id, last_name, hire_date
from employees
where hire_date  between to_date('20050101', 'yyyymmdd') and to_date('20051231', 'yyyymmdd') and mod(to_number(to_char(hire_date, 'fmmm')), 2) = 1;

-- 문제 28 아래 화면의 결과 처럼 사원의  last_name,  salary, salary 값을 1000당 별표를 하나를 출력하는  query문을 작성하세요. 
select last_name, salary, lpad('*', trunc(salary/1000), '*') as "STAR"
from employees
order by salary desc;

-- 문제 29 아래 화면결과 처럼 출력하세요.
select '현재 서버의 날짜 시간 : ' || to_char(sysdate, 'yyyymmdd hh:mi:ss am') as "현재날짜시간"
from dual;

-- 문제 30 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 하루 전 : ' || to_char(sysdate-1, 'yyyymmdd hh24:mi:ss') as "하루전"
from dual;

-- 문제 31 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 1시간 전 : ' || to_char(sysdate-1/24, 'yyyymmdd hh24:mi:ss') as "1시간전"
from dual;

select '서버의 시간을 기준으로 1시간 전 : ' || to_char(sysdate-to_dsinterval('0 01:00:00'), 'yyyymmdd hh24:mi:ss') as "1시간전"
from dual;

-- 문제 32 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 5분 전 : ' || to_char(sysdate-to_dsinterval('0 00:05:00'), 'yyyymmdd hh24:mi:ss') as "5분전"
from dual;

select '서버의 시간을 기준으로 5분 전 : ' || to_char(sysdate-5/(24*60), 'yyyymmdd hh24:mi:ss') as "5분전"
from dual;

-- 문제 33 아래 화면결과 처럼 출력하세요
select '서버의 시간을 기준으로 10초 전 : ' || to_char(sysdate-to_dsinterval('0 00:00:10'), 'yyyymmdd hh24:mi:ss') as "10초전"
from dual;

select '서버의 시간을 기준으로 10초 전 : ' || to_char(sysdate-10/(24*60*60), 'yyyymmdd hh24:mi:ss') as "10초전"
from dual;

-- 문제 34 JOB_ID 열의 값을 기준으로 모든 사원의 등급(GRADE)을 표시하는 query 를 작성하세요.
select job_id, decode(job_id, 'AD_PRES', 'A', 'ST_MAN', 'B', 'IT_PROG', 'C', 'SA_REP', 'D', 'ST_CLERK', 'E', 'Z') as "GRADE"
from employees;

-- 문제 35 사원테이블에  연봉을 계산 하는 쿼리문을 작성하세요 
-- 단 commission_pct 값이 null 아니면 (salary*12) + (salary*12*commission_pct) 이값이 수행되고
-- null 이면 salary * 12 가 수행합니다. 수행 결과는 화면처럼 만드세요.
-- (nvl, nvl2,  coalesce, case, decode 함수를 사용하여 각각으로 수행해서 보고서 작성해 주세요)
select last_name, salary, commission_pct, decode(commission_pct, null, salary * 12, (salary * 12) + (salary * 12 * commission_pct)) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, (salary * 12) + (salary * 12 * nvl(commission_pct, 0)) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, nvl2(commission_pct, (salary * 12) + (salary * 12 * commission_pct), salary * 12) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, coalesce((salary * 12) + (salary * 12 * commission_pct), salary * 12) as "ANN_SAL"
from employees;

select last_name, salary, commission_pct, case when commission_pct is null then salary * 12 else (salary * 12) + (salary * 12 * commission_pct) end as "ANN_SAL"
from employees;

-- 문제36 모든 사원의 최고급여, 최저급여, 합계 및 평균 급여를 찾습니다. 
-- 열 레이블을 각각 Maximum, Minimum, Sum 및 Average 로 지정합니다. 
-- 결과를 소수점은 반올림해서 정수값으로 출력하세요.
select max(salary) as "Maximum", min(salary) as "Minimum", sum(salary) as "Sum", round(avg(salary), 0) as "Average"
from employees;

-- 문제 37 2008년도에 입사한 사원들의 job_id별 인원수를 구하고 인원수가 많은 순으로 출력하세요. 
select job_id, count(*)
from employees
where to_char(hire_date, 'yyyy') = '2008'
group by job_id
order by 2 desc;

-- 문제 38 job_id별로 총액급여를 구합니다. 단 CLERK글자가 있는 job_id는 제외하고 총액급여는 13000가 넘는 정보를 출력하면서 총액 급여를 기준으로 내림차순 정렬하세요.
select job_id, sum(salary) as "payroll"
from employees
where job_id not like '%CLERK%'
group by job_id
having  sum(salary) > 13000
order by 2 desc;

-- 문제 39 입사한 년도별로 급여의 총액을 출력하세요.
select to_char(hire_date, 'yyyy'), sum(salary)
from employees
group by to_char(hire_date, 'yyyy');

select extract(year from hire_date), sum(salary)
from employees
group by extract(year from hire_date);

-- 문제 40 입사한 달별 인원수를 출력해주세요.
select to_char(hire_date, 'mm'), count(*)
from employees
group by to_char(hire_date, 'mm')
order by 1;

-- 문제 41 사원의 총 수와 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요.
-- 결과값에 1이 아닌 0이나 문자를 넣어도 무방(행 수를 세기 때문에)
select count(*) as TOTAL, count(decode(extract(year from hire_date), 2005, 1)) as "2005", count(decode(extract(year from hire_date), 2006, 1)) as "2006", count(decode(extract(year from hire_date), 2007, 1)) as "2007", count(decode(extract(year from hire_date), 2008, 1)) as "2008"
from employees;

-- 결과값에 1이 들어가야 합계가 계산됨
select count(*) as TOTAL, sum(case to_char(hire_date, 'yyyy') when '2005' then 1 end) as "2005", sum(case to_char(hire_date, 'yyyy') when '2006' then 1 end) as "2006", sum(case to_char(hire_date, 'yyyy') when '2007' then 1 end) as "2007", sum(case to_char(hire_date, 'yyyy') when '2008' then 1 end) as "2008"

-- 문제 42 모든 사원의 last_name, department_id, department_name을 표시하기 위한 query 를 작성합니다.

--오라클

select e.last_name, e.department_id, d.department_name
from employees e, departments d
where e.department_id = d.department_id(+);

--ANSI표준
select e.last_name, e.department_id, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id;

-- 문제 43 부서 80에 속하는 last_name, job_id, department_name, city를 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, e.job_id, d.department_name, l.city
from employees e, departments d, locations l
where e.department_id = 80 and e.department_id = d.department_id and d.location_id = l.location_id;

--ANSI표준
select e.last_name, e.job_id, d.department_name, l.city
from employees e join departments d
on e.department_id = d.department_id 
join locations l
on d.location_id = l.location_id
where e.department_id = 80;

--문제 44 commission_pct 에 null이 아닌 모든 사원의 last_name, department_name, location_id, city를 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, d.department_name, d.location_id, l.city
from employees e, departments d, locations l
where e.commission_pct is not null and e.department_id = d.department_id(+) and d.location_id = l.location_id(+);

--ANSI표준
select e.last_name, d.department_name, d.location_id, l.city
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
where e.commission_pct is not null;

--문제 45 last_name에 a(소문자)가 포함된 모든 사원의 last_name, department_name 을 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, d.department_name
from employees e, departments d
where e.last_name like '%a%' and e.department_id = d.department_id(+);

--ANSI표준
select e.last_name, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
where e.last_name like '%a%';

select e.last_name, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
where instr(e.last_name, 'a') >=1;

-- 문제 46 locations 테이블에 있는 city컬럼에  Toronto도시에서 근무하는 모든 사원의 last_name, job_id, department_id, department_name 을 표시하기 위한 query 를 작성합니다.
--오라클
select e.last_name, e.job_id, e.department_id, d.department_name
from employees e, departments d, locations l
where l.city = 'Toronto' and e.department_id = d.department_id and d.location_id = l.location_id;

--ANSI표준
select e.last_name, e.job_id, e.department_id, d.department_name
from employees e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id
where l.city = 'Toronto';
desc employees

-- 문제 47 2006년도에 입사한 사원들의 부서이름별로 급여의 총액, 평균을 출력하세요.
--오라클
select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e, departments d
where extract(year from e.hire_date) = 2006 and e.department_id = d.department_id
-- extract로 뽑아내면 인덱스 스캔이 아닌 풀 스캔이 됨
group by d.department_name;

--ANSI표준
select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e join departments d
on e.department_id = d.department_id
where to_char(e.hire_date, 'yyyy') = '2006' 
-- to_char로 뽑아내면 인덱스 스캔이 아닌 풀 스캔이 됨
group by d.department_name;

select d.department_name, sum(e.salary) as "Total", avg(e.salary) as "Average"
from employees e join departments d
on e.department_id = d.department_id
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
group by d.department_name;

-- 문제 48 2006년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요.
--오라클
select l.city, sum(e.salary), avg(e.salary)
from employees e, departments d, locations l
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
and e.department_id = d.department_id
and d.location_id = l.location_id
group by l.city;

--ANSI표준
select l.city, sum(e.salary), avg(e.salary)
from employees e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id
where e.hire_date >= to_date('20060101', 'yyyymmdd') and e.hire_date < to_date('20070101', 'yyyymmdd')
group by l.city;

-- 문제49 2007년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요. 단 부서 배치를 받지 않는 사람들의 급여의 총액, 평균도 구하세요.
--오라클
select l.city, sum(e.salary), avg(e.salary)
from employees e, departments d, locations l
where e.hire_date >= to_date('20070101', 'yyyymmdd') and e.hire_date < to_date('20080101', 'yyyymmdd')
and e.department_id = d.department_id(+)
and d.location_id = l.location_id(+)
group by l.city;

--ANSI표준
select l.city, sum(e.salary), avg(e.salary)
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
where e.hire_date >= to_date('20070101', 'yyyymmdd') and e.hire_date < to_date('20080101', 'yyyymmdd')
group by l.city;

-- 문제 50 사원들의 사번, 급여, 급여등급, 부서이름을 출력하세요. 부서배치를 받지 않는 사원은 제외시켜주세요.
--오라클
select e.employee_id, e.salary, j.grade_level, d.department_name
from employees e, departments d, job_grades j
where e.department_id = d.department_id and e.salary between j.lowest_sal and j.highest_sal;

--ANSI표준
select e.employee_id, e.salary, j.grade_level, d.department_name
from employees e join departments d
on e.department_id = d.department_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal;

-- 문제 51 사원들의 사번, 급여, 급여등급, 부서이름, 근무 도시 정보를 출력하세요. 부서배치를 받지 않는 사원도 포함시켜주세요.
--오라클
select e.employee_id, e.salary, j.grade_level, d.department_name, l.city
from employees e, departments d, job_grades j, locations l
where e.department_id = d.department_id(+)
and e.salary between j.lowest_sal and j.highest_sal
and d.location_id = l.location_id(+);

--ANSI표준
select e.employee_id, e.salary, j.grade_level, d.department_name, l.city
from employees e left outer join departments d
on e.department_id = d.department_id
left outer join locations l
on d.location_id = l.location_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal;

-- 문제 52 사원들의 last_name,salary,grade_level, department_name을 출력하는데 last_name에 a문자가 2개 이상 포함되어 있는 사원들을 출력하세요.
--오라클
select e.last_name, e.salary, j.grade_level, d.department_name
from employees e, job_grades j, departments d
where instr(e.last_name, 'a', 1, 2) >= 2 and e.department_id = d.department_id(+) and e.salary between j.lowest_sal and j.highest_sal;

--ANSI표준
select e.last_name, e.salary, j.grade_level, d.department_name
from employees e left outer join departments d
on e.department_id = d.department_id
join job_grades j
on e.salary between j.lowest_sal and j.highest_sal
where instr(e.last_name, 'a', 1, 2) >= 2;

-- 문제 53 141번 사원의 job_id와 동일한 job_id를 가진 사원들 중에 141번 사원의 급여보다 더 많이 받는 사원을 출력해주세요
select *
from employees
where job_id = (select job_id
                from employees
                where employee_id = 141)
and salary > (select salary
                from employees
                where employee_id = 141);
                
-- 문제 54 최소월급을 받은 사원들의 정보를 출력해주세요.
select *
from employees
where salary = (select min(salary)
                from employees);

-- 문제 55 평균 급여가 가장 낮은 job_id를 찾아 주세요.
select job_id
from employees
group by job_id
having avg(salary) = (select min(avg(salary))
                      from employees
                      group by job_id);
                      
-- 문제 56 부서별로 최소 급여자들을 출력해주세요.
select *
from employees
where salary in (select min(salary) from employees group by department_id)
order by department_id;

-- 문제 57 last_name 에 문자 "u"가 포함된 사원과 같은 부서에 근무하는 모든 사원의 employee_id, last_name 을 출력하세요.
select employee_id, last_name
from employees
where department_id in (select distinct department_id from employees where last_name like '%u%');

-- 문제 58 부서 위치(location_id) ID 가 1700 인 모든 사원의 last_name, department_id, job_id 를 출력하세요.(조인, 서브쿼리)
--오라클
select e.last_name, e.department_id, e.job_id
from employees e, departments d
where e.department_id = d.department_id
and d.location_id = 1700;

--ANSI표준
select e.last_name, e.department_id, e.job_id
from employees e join departments d
on e.department_id = d.department_id
where d.location_id = 1700;

--서브쿼리
select last_name, department_id, job_id
from employees
where department_id in (select department_id from departments where location_id = 1700);

-- 문제 59 King 에게 보고하는 모든 사원의 last_name 및 salary 출력하세요.(조인, 서브쿼리)
--오라클
select e.last_name, e.salary
from employees e, employees m
where e.manager_id = m.employee_id
and m.last_name = 'King';

--ANSI표준
select e.last_name, e.salary
from employees e join employees m
on e.manager_id = m.employee_id
where m.last_name = 'King';

--서브쿼리
select last_name, salary
from employees
where manager_id in (select distinct employee_id from employees where last_name = 'King');

-- 문제 60 부서 이름(department_name) 이 Executive 부서의 모든 사원에 대한 department_id, last_name, job_id  출력하세요.
--오라클
select e.department_id, e.last_name, e.job_id
from employees e, departments d
where e.department_id = d.department_id
and d.department_name = 'Executive';

--ANSI표준
select e.department_id, e.last_name, e.job_id
from employees e join departments d
on e.department_id = d.department_id
where d.department_name = 'Executive';

--서브쿼리
select department_id, last_name, job_id
from employees
where department_id = (select department_id from departments where department_name = 'Executive');

-- 문제 61 60부서에 소속된 모든 사원의 급여(salary)보다 높은(max) 급여를 받는 모든 사원 출력하세요.
select *
from employees
where salary > all (select salary from employees where department_id = 60);

select *
from employees
where salary > (select max(salary) from employees where department_id = 60);

-- 문제 62 전체 평균 급여보다 많은 급여를 받고 last_name에 "u"가 포함된 사원이 있는 부서에서 근무하는 모든 사원의 employee_id, last_name, salary 출력하세요
select employee_id, last_name, salary
from employees
where salary > (select avg(salary) from employees)
and department_id in (select distinct department_id from employees where last_name like '%u%');

-- 문제 63 관리자 사원들의 정보를 출력해주세요 
select *
from employees
where employee_id in (select distinct manager_id from employees);

-- 문제 64 관리자가 아닌 사원들의 정보를 출력해 주세요
-- 서브쿼리에 null 값이 있을 경우 not in 연산자를 사용할 수 없음 
select *
from employees
where employee_id not in (select distinct manager_id from employees where manager_id is not null);

select *
from employees
where employee_id != all (select distinct manager_id from employees where manager_id is not null);

-- 문제 65 last_name에 Davies 사원보다 늦게 입사한 사원 중에 급여가 Davies 사원의 급여 이하로 받고 있는 사원들을 출력해주세요.
--서브쿼리
select *
from employees
where salary <= (select salary from employees where last_name = 'Davies')
and hire_date > (select hire_date from employees where last_name = 'Davies');

--오라클
select e.*
from employees e, employees d
where e.salary <= d.salary
and e.hire_date > d.hire_date
and d.last_name = 'Davies';

--ANSI표준
select e.*
from employees e join employees d
on e.salary <= d.salary
and e.hire_date > d.hire_date
where d.last_name = 'Davies';

-- 문제 66 자신의 부서 평균 급여보다 더 많은 급여를 받는 사원들의 정보를 출력해주세요
select *
from employees o
where o.salary > (select avg(salary) from employees where department_id = o.department_id);

-- 문제 67 두번 이상 job_id를 바꾼 사원 출력해주세요.
select j.*
from job_history j
where 2 <= (select count(employee_id) from job_history where employee_id = j.employee_id)
order by j.employee_id;

-- 문제 68 관리자 사원에 대해서 출력해주세요
select *
from employees e
where employee_id in (select distinct manager_id from employees where manager_id is not null);

select *
from employees o
where exists (select 'x'--문법 오류를 막기 위한 의미없는 표현 'x'
              from employees
              where manager_id = o.employee_id);
              
-- 문제 69 관리자가 아닌 사원에 대해서 출력해주세요
select *
from employees e
where employee_id not in (select distinct manager_id from employees where manager_id is not null);

select *
from employees o
where not exists (select 'x'
              from employees
              where manager_id = o.employee_id);

-- 문제 70 사원이 없는 부서 정보만 출력해주세요
select *
from departments
where department_id not in (select department_id from employees where department_id is not null);

select *
from departments d
where not exists (select 'x' from employees where department_id = d.department_id);

-- 문제 71 자신의 부서안에서 자신보다 늦게 입사하고 자신보다 급여를 많이받는 사람이 있는 사람들을 찾아주세요
select *
from employees e
where exists (select 'x' from employees where department_id = e.department_id and salary > e.salary and hire_date > e.hire_date)
and e.department_id = 50;

select distinct e.*
from employees e, employees l
where e.hire_date < l.hire_date 
and e.salary < l.salary
and e.department_id = l.department_id
and e.department_id = 50;

-- 문제 72 사원수가 3명 미만인 부서번호, 부서이름, 인원수를 출력해주세요
select d.department_id, d.department_name, m.peoples
from departments d, (select department_id, count(employee_id) peoples from employees where department_id is not null group by department_id having count(employee_id) < 3) m
where d.department_id = m.department_id
order by d.department_id;

select d.department_id, d.department_name, count(*)
from employees e, departments d
where e.department_id = d.department_id
group by d.department_id, d.department_name
having count(*) < 3
order by d.department_id;

--inline view를 통해 join의 양을 줄일 수 있다

-- 문제 73번 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요.
select count(*) as TOTAL, count(decode(extract(year from hire_date), 2005, 1)) as "2005", count(decode(extract(year from hire_date), 2006, 1)) as "2006", count(decode(extract(year from hire_date), 2007, 1)) as "2007", count(decode(extract(year from hire_date), 2008, 1)) as "2008"
from employees;

select to_char(hire_date, 'yyyy'), count(*) from employees group by to_char(hire_date, 'yyyy');

select 
       decode(hire_year, '2001', people) as "2001",
       decode(hire_year, '2002', people) as "2002",
       decode(hire_year, '2003', people) as "2003",
       decode(hire_year, '2004', people) as "2004",
       decode(hire_year, '2005', people) as "2005",
       decode(hire_year, '2006', people) as "2006",
       decode(hire_year, '2007', people) as "2007",
       decode(hire_year, '2008', people) as "2008"
from (select to_char(hire_date, 'yyyy') hire_year, count(*) people from employees group by to_char(hire_date, 'yyyy'));

SELECT 
       max(decode(year,'2001',cn)) "2001",
       max(decode(year,'2002',cn)) "2002",
       max(decode(year,'2003',cn)) "2003",
       max(decode(year,'2004',cn)) "2004",   
       max(decode(year,'2005',cn)) "2005",
       max(decode(year,'2006',cn)) "2006",
       max(decode(year,'2007',cn)) "2007",
       max(decode(year,'2008',cn)) "2008"       
FROM (
              SELECT to_char(hire_date, 'yyyy') year, count(*) cn
              FROM employees
              GROUP BY(to_char(hire_date, 'yyyy')));

-- 문제 74 평균 급여가 가장 높은 부서의 부서 번호와 최고, 최저, 평균 급여를 출력하세요.
select department_id, max(salary), min(salary), avg(salary) as average
from employees
group by department_id
having avg(salary) = (select max(avg(salary)) from employees group by department_id);

-- 부서별 최고, 최저, 평균급여 테이블
select department_id, max(salary), min(salary), avg(salary) as average
from employees
group by department_id;

-- 최고 평균급여 테이블
select max(avg(salary)) from employees group by department_id;


-- 문제 75 사원 수가 가장 많은 부서이름, 도시, 인원수를 출력해주세요.
select d.department_name, l.city, e.cn
from (select department_id, count(*) cn from employees group by department_id having count(*) 
      = (select max(count(*)) from employees group by department_id)) e join departments d
on e.department_id = d.department_id
join locations l
on d.location_id = l.location_id;      

-- 문제 76 사원 채용 수가 가장 많은 요일을 출력해주세요.
select to_char(hire_date, 'day'), count(*)
from employees
group by to_char(hire_date, 'day')
having count(*) = (select max(count(*)) from employees group by to_char(hire_date, 'day'));

-- 문제 77 사원 채용 수가 가장 많은 요일에 입사한 사원들의 last_name, 요일을 출력해주세요.
select last_name, to_char(hire_date, 'day')
from employees
where to_char(hire_date, 'day') in (select to_char(hire_date, 'day') from employees group by to_char(hire_date, 'day')
having count(*) = (select max(count(*)) from employees group by to_char(hire_date, 'day')));

-- 문제 78 부서별로 인원수를 출력주세요.
select 
       max(decode(department_id, '10', cn)) as "10",
       max(decode(department_id, '20', cn)) as "20",
       max(decode(department_id, '30', cn)) as "30",
       max(decode(department_id, '40', cn)) as "40",
       max(decode(department_id, '50', cn)) as "50",
       max(decode(department_id, '60', cn)) as "60",
       max(decode(department_id, '70', cn)) as "70",
       max(decode(department_id, '80', cn)) as "80",
       max(decode(department_id, '90', cn)) as "90",
       max(decode(department_id, '100', cn)) as "100",
       max(decode(department_id, '110', cn)) as "110",
       max(decode(department_id, null, cn)) as "부서가 없는 사원"
from (select department_id, count(*) cn from employees group by department_id);

-- 문제 79 부서 번호와 급여가 커미션을 받는 사원의 부서 번호 및 급여와 일치하는 모든  사원의 last_name, department_id, salary 를 표시하는 query 를 작성하세요.
select last_name, department_id, salary
from employees
where (department_id, salary) in (select department_id, salary from employees where commission_pct is not null);

--커미션을 받는 사원 테이블
select department_id, salary from employees where commission_pct is not null;

-- 문제 80 급여와 커미션이 location_id가 1700 에 있는 사원의 급여 및 커미션과 일치하는 사원의 last_name, department_name, salary를 출력해주세요.
select e.last_name, d.department_name, e.salary
from employees e join departments d
on e.department_id = d.department_id
where (salary, nvl(e.commission_pct, 0)) in (select e.salary, nvl(e.commission_pct, 0) from employees e, departments d where e.department_id = d.department_id and d.location_id = 1700);

-- location_id = 1700인 사원들의 급여와 커미션
select e.salary, nvl(e.commission_pct, 0) 
from employees e, departments d 
where e.department_id = d.department_id and d.location_id = 1700;

-- 문제 81 select department_id, department_name from departments where location_id = 1700
select last_name, hire_date, salary, commission_pct
from employees
where (salary, nvl(commission_pct, 0)) = (select salary, nvl(commission_pct, 0) from employees where last_name = 'Johnson')
and last_name not like 'Johnson';

-- Johnson의 급여와 커미션
select salary, commission_pct from employees where last_name = 'Johnson';

-- 문제 82 부서의 총 급여가 전체 부서의 평균 급여보다 많은 부서의 이름과 총 급여를 표시하도록 query를 작성하세요.
--null 부서 미포함
select d.department_name, sum(e.salary)
from employees e join departments d
on e.department_id = d.department_id
group by d.department_name
having sum(e.salary) > (select avg(dep_sum) from (select department_id, sum(salary) dep_sum from employees where department_id is not null group by department_id));

--null 부서 포함
select d.department_name, sum(e.salary)
from employees e join departments d
on e.department_id = d.department_id
group by d.department_name
having sum(salary) > (select avg(dep_sum) from (select department_id, sum(salary) dep_sum from employees group by department_id));

--null 부서 포함(선생님 답)
select d.department_name, e.average
from (select department_id, sum(salary) average from employees group by department_id having sum(salary) > (select avg(average) from (select sum(salary) average from employees group by department_id))) e, departments d
where e.department_id = d.department_id;

-- 전체 부서의 총급여 평균
select avg(dep_sum)
from (select department_id, sum(salary) dep_sum from employees where department_id is not null group by department_id);

-- 각 부서별 총급여
select department_id, sum(salary)
from employees
where department_id is not null
group by department_id;

--with: 재사용이 가능한 가상테이블 생성
with
dept_cost as (select d.department_name, sum(e.salary) as sumsal  from employees e, departments d where e.department_id = d.department_id(+) group by d.department_name), 
avg_cost as (select sum(sumsal) / count(*) as deptavg from dept_cost)
select *
from dept_cost
where sumsal > (select deptavg from avg_cost);

-- 문제 83  job_id가  ST_CLERK 을 포함하지 않는 부서에 대한 department_id를 출력해주세요.
SELECT department_id
FROM departments
WHERE department_id NOT IN (SELECT DISTINCT department_id FROM employees WHERE job_id = 'ST_CLERK');

-- 값의 존재/비존재 여부를 찾기 위해서는 correlated subquery를 사용하는 것이 적합하다
SELECT department_id
FROM departments d
WHERE NOT EXISTS (SELECT 'x' FROM employees WHERE department_id = d.department_id AND job_id = 'ST_CLERK');
  
-- job_id가 ST_CLERK인 사원을 가진 부서
SELECT DISTINCT department_id
FROM employees
WHERE job_id = 'ST_CLERK';

-- 문제 84 부서가 소재하지 않는 국가의 리스트가 필요합니다. 해당 국가의 country_id, country_name을 출력해주세요.
-- in / not in 사용
-- 부서가 있는 나라들의 테이블
select distinct country_id
from locations
where location_id in (select location_id from departments);

-- 전체 나라 테이블에서 부서가 있는 나라들을 제외한 테이블
select country_id, country_name
from countries
where country_id not in (select distinct country_id from locations l where location_id in (select location_id from departments));

-- exists / not exists 사용
--부서가 있는 나라들의 테이블
select distinct country_id
from locations l
where exists (select 'x' from departments where location_id = l.location_id);

-- 전체 나라 테이블에서 부서가 있는 나라들을 제외한 테이블
select country_id, country_name
from countries o
where not exists (select 'x' from locations l where exists (select 'x' from departments where location_id = l.location_id) and l.country_id = o.country_id);

-- 집합연산자 사용 / sort를 하게되고 동일한 테이블을 여러번 사용하게 됨
select country_id, country_name
from countries
minus
select l.country_id, c.country_name
from departments d, locations l, countries c
where l.country_id = c.country_id
and d.locations_id = l.location_id

--not exists 사용 / join을 잘 활용하자 / 1족 -> m족 비교
select country_id, country_name
from countries c
where not exists (select 'x' from locations l, departments d where d.location_id = l.location_id and l.country_id = c.country_id);

-- 문제 85 사원들의 employee_id, last_name, department_name을 출력하는데 소속부서가 없는 사원도 출력하시고, 소속사원이 없는 부서도 출력하세요. ANSI표준 조인, 오라클 전용 조인으로 만드세요.
--오라클
--department_id = null을 포함
select e.employee_id, e.last_name, d.department_name
from employees e, departments d
where e.department_id = d.department_id(+)
union all
--employee_id = null을 포함
select e.employee_id, e.last_name, d.department_name
from employees e, departments d
where e.department_id(+) = d.department_id
and e.department_id is null;


--ANSI표준
select e.employee_id, e.last_name, d.department_name
from employees e full outer join departments d
on e.department_id = d.department_id;

-- union all & not exists
select e.employee_id, e.last_name, d.department_name
from employees e, departments d
where e.department_id = d.department_id(+)
union all
select null, null, d.department_name
from departments d
where not exists (select 'x' from employees e where e.department_id = d.department_id); 

-- 문제 86 1,2,3,4를 한꺼번에 출력해주세요.
-- 1. department_id, job_id, manager_id 기준으로 총액 급여를 출력
-- 2. department_id, job_id 기준으로 총액급여출력
-- 3. department_id 기준으로 총액급여 출력
-- 4. 전체 총액 급여를 출력

select department_id, job_id, manager_id, sum(salary) Total
from employees
group by department_id, job_id, manager_id
union all
select department_id, job_id, null, sum(salary)
from employees
group by department_id, job_id
union all
select department_id, null, null, sum(salary)
from employees
group by department_id
union all
select null, null, null, sum(salary)
from employees
order by 1, 2, 3, 4;


-- 1. department_id, job_id, manager_id 기준으로 총액 급여를 출력
select department_id, job_id, manager_id, sum(salary)
from employees
group by department_id, job_id, manager_id;

-- 2. department_id, job_id 기준으로 총액급여출력
select department_id, job_id, null, sum(salary)
from employees
group by department_id, job_id;

-- 3. department_id 기준으로 총액급여 출력
select department_id, null, null, sum(salary)
from employees
group by department_id;

-- 4. 전체 총액 급여를 출력
select null, null, null, sum(salary)
from employees;

--roll up연산자
-- group by 절에서 지정한 열 리스트를 오른쪽에서 왼쪽으로 한 컬럼씩 줄여가며 그룹화
select department_id, job_id, manager_id, sum(salary)
from employees
group by rollup (department_id, job_id, manager_id);

--cube 연산자
-- group by 절에 지정된 가능한 모든 그룹화
select department_id, job_id, manager_id, sum(salary)
from employees
group by cube (department_id, job_id, manager_id);

group by rollup(a, b, c)
sum(sal) = {a, b, c}
sum(sal) = {a, b}
sum(sal) = {a}
sum(sal) = {}

group by cube(a, b, c)
sum(sal) = {a, b, c}
sum(sal) = {a, b}
sum(sal) = {a, c}
sum(sal) = {b, c}
sum(sal) = {a}
sum(sal) = {b}
sum(sal) = {c}
sum(sal) = {}

-- 문제 87 1, 2 한꺼본에 출력해주세요
-- 1. department_id, manager_id 기준 급여 총 합
-- 2. department_id, job_id 기준 급여 총 합
select department_id, manager_id, null, sum(salary)
from employees
group by department_id, manager_id
union all
select department_id, null, job_id, sum(salary)
from employees
group by department_id, job_id;

-- 1. department_id, manager_id 기준 급여 총 합
select department_id, manager_id, sum(salary)
from employees
group by department_id, manager_id;

-- 2. department_id, job_id 기준 급여 총 합
select department_id, job_id, sum(salary)
from employees
group by department_id, job_id;

--grouping sets 연산자
select department_id, job_id, manager_id, sum(salary)
from employees
group by grouping sets ((department_id, manager_id), (department_id, job_id), ());

-- 문제 88  년도별로 입사한 인원수, 전체 인원수를 출력해주세요
SELECT 
       max(decode(year,'2001',cn)) "2001",
       max(decode(year,'2002',cn)) "2002",
       max(decode(year,'2003',cn)) "2003",
       max(decode(year,'2004',cn)) "2004",   
       max(decode(year,'2005',cn)) "2005",
       max(decode(year,'2006',cn)) "2006",
       max(decode(year,'2007',cn)) "2007",
       max(decode(year,'2008',cn)) "2008",
       sum(cn) "총인원수"
FROM (
              SELECT to_char(hire_date, 'yyyy') year, count(*) cn
              FROM employees
              GROUP BY(to_char(hire_date, 'yyyy')));

-- rollup 활용              
SELECT 
       max(decode(year,'2001',cn)) "2001",
       max(decode(year,'2002',cn)) "2002",
       max(decode(year,'2003',cn)) "2003",
       max(decode(year,'2004',cn)) "2004",   
       max(decode(year,'2005',cn)) "2005",
       max(decode(year,'2006',cn)) "2006",
       max(decode(year,'2007',cn)) "2007",
       max(decode(year,'2008',cn)) "2008",
       max(decode(year,null,cn)) "총인원수"
FROM (
              SELECT to_char(hire_date, 'yyyy') year, count(*) cn
              FROM employees
              GROUP BY rollup(to_char(hire_date, 'yyyy')));

-- 문제 89 달별 입사한 인원수, 총인원수를 출력해주세요.
SELECT 
       max(decode(hire_month,01,cn)) "1월",
       max(decode(hire_month,02,cn)) "2월",
       max(decode(hire_month,03,cn)) "3월",
       max(decode(hire_month,04,cn)) "4월",
       max(decode(hire_month,05,cn)) "5월",
       max(decode(hire_month,06,cn)) "6월",
       max(decode(hire_month,07,cn)) "7월",
       max(decode(hire_month,08,cn)) "8월",
       max(decode(hire_month,09,cn)) "9월",
       max(decode(hire_month,10,cn)) "10월",
       max(decode(hire_month,11,cn)) "11월",
       max(decode(hire_month,12,cn)) "12월",
       sum(cn) "총인원수"
FROM (
              SELECT to_char(hire_date, 'mm') hire_month, count(*) cn
              FROM employees
              GROUP BY(to_char(hire_date, 'mm')));              
              
 -- rollup 활용   
 SELECT 
       max(decode(hire_month,01,cn)) "1월",
       max(decode(hire_month,02,cn)) "2월",
       max(decode(hire_month,03,cn)) "3월",
       max(decode(hire_month,04,cn)) "4월",
       max(decode(hire_month,05,cn)) "5월",
       max(decode(hire_month,06,cn)) "6월",
       max(decode(hire_month,07,cn)) "7월",
       max(decode(hire_month,08,cn)) "8월",
       max(decode(hire_month,09,cn)) "9월",
       max(decode(hire_month,10,cn)) "10월",
       max(decode(hire_month,11,cn)) "11월",
       max(decode(hire_month,12,cn)) "12월",
       max(decode(hire_month,null,cn)) "총인원수"
FROM (SELECT to_char(hire_date, 'mm') hire_month, count(*) cn
      FROM employees
      GROUP BY rollup(to_char(hire_date, 'mm')));   
      
-- to_char(hire_date, 'month')로 나온 1자리 월 뒤에는 공백 1칸이 있다      
 SELECT 
       max(decode(hire_month,'1월 ',cn)) "1월",
       max(decode(hire_month,'2월 ',cn)) "2월",
       max(decode(hire_month,'3월 ',cn)) "3월",
       max(decode(hire_month,'4월 ',cn)) "4월",
       max(decode(hire_month,'5월 ',cn)) "5월",
       max(decode(hire_month,'6월 ',cn)) "6월",
       max(decode(hire_month,'7월 ',cn)) "7월",
       max(decode(hire_month,'8월 ',cn)) "8월",
       max(decode(hire_month,'9월 ',cn)) "9월",
       max(decode(hire_month,'10월',cn)) "10월",
       max(decode(hire_month,'11월',cn)) "11월",
       max(decode(hire_month,'12월',cn)) "12월",
       max(decode(hire_month,null,cn)) "총인원수"
FROM (SELECT to_char(hire_date, 'month') hire_month, count(*) cn
      FROM employees
      GROUP BY rollup(to_char(hire_date, 'month')));         
      
SELECT to_char(hire_date, 'month') hire_month, count(*) cn
FROM employees
GROUP BY rollup(to_char(hire_date, 'month'));

--문제 90 새로운 user를 생성하세요
-- 유저이름: insa default tablespace : users temporary tablespace : temp 	users tablespace 사용량 : 1m

create user insa
identified by oracle
default tablespace users
temporary tablespace temp
quota 1m on users;

select * from dba_sys_privs where grantee = 'insa';

-- 문제 91 insa유저에게 create session, create table 시스템 권한을 부여해주세요
grant create session, create table to insa;

-- 문제 92 insa 유저가 사용할 수 있는 users tablespace quota 값을 unlimited로 수정하세요
alter user insa
quota unlimited on users;

select * from dba_ts_quotas;
select * from user_ts_quotas;

-- 문제 93 hr유저가 소유한 employees 테이블의 select 객체 권한을 insa유저에게 부여해 주세요
grant select on hr.employees to insa;

--회수
revoke select on hr.employees from insa;

-- 문제 94 hr유저가 소유한 departments 테이블의 select 객체 권한을 insa유저에게 부여해주세요
grant select on hr.departments to insa;

-- 문제 95  insa 유저는 테이블논리적설계.pdf에 ERD(Entity Relationship Diagram)을 확인 한후 table instance chart를  보면서 테이블을 구성하세요.

create table dept
(dept_id number(3) constraint dept_id_pk primary key,
 dept_name varchar2(50) constraint dept_nn not null 
                        constraint dept_uk unique,
 mgr number(5));
 
 create table emp
 (id number(5) constraint emp_id_pk primary key,
  name varchar2(50) constraint emp_name_nn not null,
  hire_date date constraint emp_date_nn not null,
  sal number(8, 2) constraint emp_sal_ck check(sal > 100),
  mgr number(5),
  dept_id number(3),
  constraint emp_dept_id_fk foreign key(dept_id) references dept(dept_id),
  constraint emp_mgr_fk foreign key(mgr) references emp(id));
  
  desc emp;
  desc dept;

/* [문제96] hr.departments 테이블의 department_id, department_name, manager_id 데이터를 
insa 유저의 dept 테이블로 insert 한후 영구히 저장하세요. */
drop table dept purge;
select * from user_constraints where table_name = 'DEPT';

alter table dept
drop primary key cascade;

create table dept
as select department_id, department_name, manager_id from hr.departments;

select * from dept;

commit;

/* [문제97] hr.employees 테이블의 employee_id, last_name, hire_date, salary, manager_id, 
department_id 데이터를 insa 유저의 emp 테이블로 insert 한후 영구히 저장하세요. */
select * from emp;
desc emp;
drop table emp purge;

create table emp
as select employee_id, last_name, hire_date, salary, manager_id, department_id from hr.employees where 1=2;

select * from user_tab_privs;

insert all
into emp(employee_id, last_name, hire_date, salary, manager_id, department_id) values(employee_id, last_name, hire_date, salary, manager_id, department_id)
select * from hr.employees;

rollback;

insert into emp(employee_id, last_name, hire_date, salary, manager_id, department_id)
select employee_id, last_name, hire_date, salary, manager_id, department_id
from hr.employees;

commit;

/* [문제98] insa유저의 dept 테이블의 부서정보 중에 소속사원이 없는 부서정보를 삭제한 후 영구히 저장하세요. */
delete from dept d
where not exists(select 'x' from emp where department_id = d.department_id);

commit;

/* [문제99] 사원들 중에 근무연수가 15년 이상 이면서 급여는 10000이상 급여를 받는 사원들은 emp_1테이블에 
사번, 이름, 입사일, 근무연수,  급여 정보를 입력하고 근무연수가 15년 이상이면서 급여는 10000미만 급여를 
받는 사원들은 emp_2테이블에 사번, 이름, 입사일, 근무연수, 급여 정보를 입력하세요. */
create table emp_1
(employee_id number,
 last_name varchar2(20) constraint emp1_name_nn not null,
 hire_date date,
 work_year number,
 salary number constraint emp1_salary_nn not null,
 constraint emp1_id_pk primary key(employee_id))
tablespace users;
desc emp_1

create table emp_2
as select * from emp_1 where 1=2;
desc emp_2;

insert first
when work_year >= 15 and salary >= 10000 then
into emp_1(employee_id, last_name, hire_date, work_year, salary) values(employee_id, last_name, hire_date, work_year, salary)
when work_year >= 15 and salary < 10000 then
into emp_2(employee_id, last_name, hire_date, work_year, salary) values(employee_id, last_name, hire_date, work_year, salary)
select employee_id, last_name, hire_date, (months_between(sysdate, hire_date)/ 12) as work_year, salary from employees;

select * from emp_1;
select * from emp_2;


-- 문제 100 EMPLOYEES 테이블을 복제 EMP_COPY 이름으로 복제하세요.
create table emp_copy
as select * from hr.employees;
-- CTAS로 복제시 not null 제약조건만 복제된다.

--문제 101 EMP_COPY테이블에 employee_id에 emp_copy_id_pk 이름으로 primary key 제약조건을 추가하세요. 
alter table emp_copy
add constraints emp_id_pk primary key(employee_id);
	
--문제 102 EMP_COPY 테이블에 department_name varchar2(30) 컬럼을 추가하세요.
alter table emp_copy
add department_name varchar2(30);

--문제 103 DEPARTMENTS 테이블에 있는 department_name을 기준으로 EMP_COPY 테이블에 department_name에 값을 수정하세요.
--단 UPDATE문을 이용해서 해결한 후 수정된 정보를 확인하고 ROLLBACK 하세요.
update emp_copy e
set department_name = (select department_name from departments where department_id = e.department_id);

select department_id, department_name from emp_copy;	

rollback;

select department_id, department_name from emp_copy;	

--문제 104 DEPARTMENTS 테이블에 있는 department_name을 기준으로 EMP_COPY 테이블에 department_name에 값을 수정하세요.
--단 MERGE문을 이용해서 해결한 후  수정된 정보를 영구히 저장하세요.
merge into emp_copy e
using (select department_id, department_name from departments) d
on (e.department_id = d.department_id)
when matched then
update set e.department_name = d.department_name;

select department_id, department_name from emp_copy;

commit;

--문제 105 EMP_COPY 테이블에 department_name에 값을 NULL 값으로 수정하세요. 
--단 MERGE문을 이용해서 해결한 후 ROLLBACK 하세요.
merge into emp_copy e
using (select department_id from departments) d
on (e.department_id = d.department_id)
when matched then
update set e.department_name = null;

select department_name from emp_copy;

rollback;

select department_name from emp_copy;

-- 문제 106 사원들의 급여가 5000 미만일 경우 employee_id, salary 정보를 SPECIAL_SAL 테이블에 입력하고 
--아니면 employee_id, hire_date, salary정보를 SAL_HISTORY 테이블에 입력하고 
--또는  employee_id, manager_id, salary 정보를  MGR_HISTORY 테이블에 입력한다.

create table special_sal
(employee_id number,
 salary number)
 tablespace users;
  
create table sal_history
(employee_id number,
 hire_date date,
 salary number);
  
create table mgr_history
(employee_id number,
 manager_id number,
 salary number);
 
insert all
when sal < 5000 then
into special_sal(employee_id, salary) values (empid, sal)
else
into sal_history(employee_id, hire_date, salary) values (empid, hiredate, sal)
into mgr_history(employee_id, manager_id, salary) values (empid, mgrid, sal)
select employee_id as empid, salary as sal, hire_date as hiredate, manager_id as mgrid from employees;
 
select * from special_sal;
select * from sal_history;
select * from mgr_history;

--다른 답
insert first
when sal < 5000 then
into special_sal(employee_id, salary) values (empid, sal)
else
into sal_history(employee_id, hire_date, salary) values(empid, hiredate, sal)
into mgr_history(employee_id, manager_id, salary) values(empid, mgrid, sal)
select employee_id as empid, salary as sal, hire_date as hiredate, manager_id as mgrid from employees;

--문제 107 emp.csv 파일의 데이터를 분석하려고 한다. external table를 생성하세요.
--권한 확인
select * from user_tab_privs where table_name = 'DATA_DIR';
select * from all_directories where directory_name = 'DATA_DIR';

-- external table은 dml사용 불가(읽기 전용) / index 없음
create table empxt
(id number,
 name varchar2(30),
 hire_date date,
 job_id varchar2(20),
 department_id number)
 organization external
 (type oracle_loader
  default directory data_dir
  access parameters
   (records delimited by newline -- 한행의 끝은 문서의 끝이 아니라 새로운 줄이 있음.
    badfile 'empxt.bad'
    logfile 'empxt.log'
    fields terminated by ',' -- 필드 구분자
    missing field values are null -- 빈 값을 대체하여 null 입력
     (id, name, hire_date char date_format date mask "YYYYMMDD", job_id, department_id))
  location('emp.csv'))
reject limit unlimited; --오류 허용 / 거의 필수적

-- 주석이 달려있으면 실행 시 오류 발생
create table empxt
(id number,
 name varchar2(30),
 hire_date date,
 job_id varchar2(20),
 department_id number)
 organization external
 (type oracle_loader
  default directory data_dir
  access parameters
   (records delimited by newline
    badfile 'empxt.bad'
    logfile 'empxt.log'
    fields terminated by ','
    missing field values are null
     (id, name, hire_date char date_format date mask "YYYYMMDD", job_id, department_id))
  location('emp.csv'))
reject limit unlimited;

select * from empxt;

-- 문제 108 부서이름별 총액급여, 평균급여, 최고급여, 최저급여를 출력하는 query문을 작성한 후, dept_sal_vw view를 생성하세요.
create or replace view dept_sal_vw
as select d.department_name, sum(e.salary) as sumsal, avg(e.salary) as avgsal, max(e.salary) as maxsal, min(e.salary) as minsal from employees e join departments d on e.department_id = d.department_id group by d.department_name;

create or replace view dept_sal_vw
as select d.department_name, e.sumsal, e.avgsal, e.maxsal, e.minsal from departments d join (select department_id, sum(salary) as sumsal, avg(salary) as avgsal, max(salary) as maxsal, min(salary) as minsal from employees group by department_id) e on d.department_id = e.department_id;

select * from dept_sal_vw;
