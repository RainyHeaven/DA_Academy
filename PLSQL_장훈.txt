/*[문제1] 화면의 결과 처럼 프로그램을 작성하세요.
TODAY'S : 2018-07-04
TOMORROW'S : 2018-07-05*/
BEGIN
dbms_output.put_line('TODAY''S : ' || to_char(SYSDATE, 'YYYY-MM-DD'));
dbms_output.put_line(q'[TOMORROW'S : ]'|| to_char(sysdate+1, 'YYYY-MM-DD'));
END;
/


-- [문제2] 전체 사원의 평균 급여를 출력 하는 프로그램 만드세요.  프로그램 수행이 끝난 후에도 전체 사원의 평균값을 이용해서 전체 사원의 평균 급여 보다 많이 받는 사원의 정보 select 문장을 작성하세요.
var b_deptavg number

begin
  select avg(salary) into :b_deptavg from employees;
  dbms_output.put_line('전체 사원의 평균 급여: ' || round(:b_deptavg));
end;
/

select * from employees where salary > :b_deptavg;

/*[문제3] 사원 번호를 입력값으로 받아서 그사원의 사번, 이름, 급여 정보를 출력하는 프로그램을 작성하세요.
<화면 결과>
결과=> 사원번호: 100, 사원이름: King, 사원급여: 24000*/

var b_empid number
exec :b_empid := 100

declare
  v_lname employees.last_name%type;
  v_sal employees.salary%type;

begin
  select last_name, salary into v_lname, v_sal from employees where employee_id = :b_empid;
  dbms_output.put_line('결과=> 사원번호: ' || :b_empid || ', 사원이름: ' || v_lname || ', 사원급여: ' || v_sal);

end;
/

/*[문제4] 사원 번호를 입력값으로 받아서 입사일, 급여 정보를 출력하는 프로그램을 작성하세요.
<화면 결과>
hire date is : 2003년 6월 17일
Salary is : ￦24,000.00 */

-- employee_id 확인 : 100번
select employee_id from employees
where hire_date = to_date('20030617', 'yyyymmdd')
and salary = 24000;

var b_empid number
exec :b_empid := 100

declare
  v_hdate employees.hire_date%type;
  v_sal employees.salary%type;

begin
  select hire_date, salary into v_hdate, v_sal from employees where employee_id = :b_empid;
  dbms_output.put_line('Hire date is : ' || to_char(v_hdate, 'YYYY"년" fmMM"월" DD"일"'));
  dbms_output.put_line('Salary is : ' || ltrim(to_char(v_sal, 'l999g999d00'))); -- to_char의 l 때문에 왼쪽 공백이 생겨 ltrim으로 지워줌
end;
/

/*<문제5> 부서테이블에 신규 부서를 입력하는 프로그램을 작성하려고 합니다.
부서 이름만 입력값으로 받고 부서코드는 마지막 부서 코드에 10을 증가해서 부서코드를
넣고 관리자번호, 부서 위치는 null값으로 입력하는 프로그램을 작성하세요.
화면출력 처럼 출력하세요.(dept 테이블을 생성한후 프로그램을 만드세요) 

<화면출력>
신규 부서 번호는 280, 부서 이름 It 입니다. */

drop table dept purge;
create table dept as select * from departments;

alter table dept add constraint dept_dept_id_pk primary key(department_id);

var b_dname varchar2(10)
exec :b_dname := 'It'

declare
  new_deptid departments.department_id%type;

begin
  select max(department_id)+10 into new_deptid from dept;
  insert into dept(department_id, department_name)
  values(new_deptid, :b_dname);
  dbms_output.put_line('신규 부서 번호는 ' || new_deptid || ', 부서 이름 ' || :b_dname || '입니다.');

end;
/

/*[문제6]사원번호를 입력값으로 받아서 그 사원의 급여를 10%인상하는 프로그램을 수행하세요.
화면의 출력되는 결과는 수정 전 월급과 수정 후 월급이 아래와 같이 출력 후 transaction은 rollback 하세요.
수정 전 월급 : 24000
수정 후 월급 : 26400 */

drop table emp purge;
create table emp as select * from employees;

alter table emp add constraint emp_empid_pk primary key(employee_id);

var b_id number
execute :b_id := 100

declare
  sal emp.salary%type;

begin
  select salary into sal from emp where employee_id = :b_id;
  update emp set salary = salary * 1.1 where employee_id = :b_id;
  if sql%found then
    dbms_output.put_line('수정 전 월급 : ' || sal);
    dbms_output.put_line('수정 후 월급 : ' || (sal * 1.1));
    rollback;
  else
    dbms_output.put_line('수정에 실패했습니다')
  end if;

end;
/


declare
  v_sal emp.salary%type;
  v_name emp.last_name%type;

begin
  select salary into v_sal from emp where employee_id = :b_id;
  dbms_output.put_line('수정 전 월급 : ' || v_sal);
  
  -- returning: DML문장에 fetch기능을 추가함 / 여러 column에 적용 가능 / 1개 row만 적용
  update emp set salary = salary * 1.1 where employee_id = :b_id returning salary, last_name into v_sal, v_name;
  dbms_output.put_line('수정 후 월급 : ' || (v_sal) || '사원이름은 : ' || v_name);
  
  rollback;

end;
/

/*[문제7] 사원번호를 입력값으로 받아서 그 사원을 삭제하는 프로그램을 수행하세요.
화면의 출력되는 결과는 아래와 같이 출력 후 transaction은 rollback 하세요.
(emp 테이블 사용하세요.)
<화면출력>
삭제된 사원의 사원 번호는 100 이고  사원의 이름은 King 입니다. */

var b_id number
execute :b_id := 100

declare
  v_name emp.last_name%type;

begin
  delete from emp where employee_id = :b_id returning last_name into v_name;
  dbms_output.put_line('삭제된 사원의 사원 번호는 ' || :b_id || ' 이고 사원의 이름은 ' || v_name || ' 입니다.');
  rollback;

end;
/
select * from emp where employee_id = 100;

/*[문제8] 부서코드를 입력값으로 받아서 그 부서의 근무하는 사원의 인원수를 출력하시고 
그 부서 사원들의 급여중에 10000 미만인 사원만 10% 인상한 급여로 수정하는 프로그램을 작성하세요.
화면출력한 후 rollback 하세요.(emp 테이블 사용하세요)
<화면출력>
20 부서의 인원수는  2명 입니다.
20 부서의 수정된 ROW의 수는 1 입니다. */

var b_id number
execute :b_id := 20

declare
  v_cnt number;

begin
  select count(*) into v_cnt from emp where department_id = :b_id;
  update emp set salary = salary * 1.1 where department_id = :b_id and salary < 10000;
  dbms_output.put_line(:b_id || ' 부서의 인원수는 ' || v_cnt || '명 입니다.');
  dbms_output.put_line(:b_id || ' 부서의 수정된 ROW의 수는 ' || sql%rowcount || ' 입니다.');
  rollback;
end;
/

/*[문제9] 나이를 입력값으로 받아서 유아, 어린이, 청소년, 성인 출력해주세요
유아 1세 이상 6세 미만
어린이 기준 : 6세 이상 13 미만
청소년 13이상 19세 미만
성인 19세 이상 */
var b_myage number
exec :b_myage := 15

begin 
  if :b_myage >= 1 and :b_myage < 6 then dbms_output.put_line('유아 입니다');
  elsif :b_myage >= 6 and :b_myage < 13 then dbms_output.put_line('어린이 입니다');
  elsif :b_myage >= 13 and :b_myage < 19 then dbms_output.put_line('청소년 입니다');
  elsif :b_myage >= 19 then dbms_output.put_line('성인 입니다');
  else dbms_output.put_line('올바른 나이를 입력해주세요');
  end if;
  
end;
/

-- [문제10] 숫자를 입력값 받아서 짝수 인지 홀수 인지를 출력하는 프로그램을 작성하세요.
var v_a number
execute :v_a := 7

begin
  if mod(:v_a, 2) = 1 then dbms_output.put_line('홀수입니다.');
  elsif mod(:v_a, 2) = 0 then dbms_output.put_line('짝수입니다.');
  else dbms_output.put_line('올바른 숫자를 입력하세요');
  end if;

end;
/

/*[문제11] 급여, 커미션를 입력 값으로 받아서 두값을 더하는 프로그램을 만드세요.
<화면출력>
두 바인드 변수에 값을 입력해주세요
<화면출력>
급여만 입력되었습니다.10000
<화면출력>
커미션만 입력되었습니다.10 
<화면출력>
10010 */
var b_sal number
var b_comm number
exec :b_sal := 10000;
exec :b_comm := 10;

begin
  if :b_comm is null and :b_sal is not null then dbms_output.put_line('급여만 입력되었습니다.' || :b_sal);
  elsif :b_sal is null and :b_comm is not null then dbms_output.put_line('커미션만 입력되었습니다.' || :b_comm);
  elsif :b_sal is not null and :b_comm is not null then dbms_output.put_line(:b_sal + :b_comm);
  else dbms_output.put_line('두 바인드 변수에 값을 입력해주세요.');
  end if;

end;
/

/*[문제12] 두개의 숫자를 입력해서 해당 숫자의 차이값을 출력하세요.
숫자를 어떻게 입력하던 큰 숫자에서 작은 숫자로 빼기를 하세요.*/

var v_a number
var v_b number
execute :v_a := 10
execute :v_b := 7

print v_a v_b

begin
  if :v_a > :v_b then dbms_output.put_line(:v_a - :v_b);
  else dbms_output.put_line(:v_b - :v_a);
  end if;

end;
/

/*[문제13] 사원번호를 입력값으로 받아서 그 사원의 근무개월수를 출력하고 근무개월수가
150개월 이상이면 급여를 20% 인상한 급여로 수정, 
149개월 보다 작거나 같고 100개월 보다 크거나 같으면  10%인상한 급여로 수정,
100개월 미만인 근무자는 아무 작업을 수행하지 않는 프로그램을 작성하세요.
테스트가 끝나면 rollback 합니다.(emp 테이블 사용)
<화면 출력>
100 사원은 근무개월수가 154 입니다. 급여는 20% 수정되었습니다.
<화면 출력>
166 사원은 근무개월수가 97 입니다. 100 개월 미만이므로  급여 수정 안됩니다. */

var b_empid number
exec :b_empid := 100

declare 
  v_wmonth number;
  
begin
  select trunc(months_between(sysdate, hire_date), 0) into v_wmonth from emp where employee_id = :b_empid;
  
  if v_wmonth >= 150 then update emp set salary = salary * 1.2 where employee_id = :b_empid; dbms_output.put_line(:b_empid || '사원은 근무개월수가 ' || v_wmonth || '입니다. 급여가 20% 인상되었습니다.');
  elsif v_wmonth between 100 and 149 then update emp set salary = salary * 1.1 where employee_id = :b_empid; dbms_output.put_line(:b_empid || '사원은 근무개월수가 ' || v_wmonth || '입니다. 급여가 10% 인상되었습니다.');
  else dbms_output.put_line(:b_empid || '사원은 근무개월수가 ' || v_wmonth || '입니다. 100개월 미만이므로 급여 변동이 없습니다.');
  end if;
    
  rollback;
  
end;
/

-- 문제 14번 : 문제13번을 case문으로 해결하시오
declare 
  v_wmonth number;
  
begin
  select trunc(months_between(sysdate, hire_date), 0) into v_wmonth from emp where employee_id = :b_empid;
  
  case
  when v_wmonth >= 150 then update emp set salary = salary * 1.2 where employee_id = :b_empid; dbms_output.put_line(:b_empid || '사원은 근무개월수가 ' || v_wmonth || '입니다. 급여가 20% 인상되었습니다.');
  when v_wmonth between 100 and 149 then update emp set salary = salary * 1.1 where employee_id = :b_empid; dbms_output.put_line(:b_empid || '사원은 근무개월수가 ' || v_wmonth || '입니다. 급여가 10% 인상되었습니다.');
  else dbms_output.put_line(:b_empid || '사원은 근무개월수가 ' || v_wmonth || '입니다. 100개월 미만이므로 급여 변동이 없습니다.');
  end case;
    
  rollback;
  
end;
/

/*[문제15] 화면의 숫자 1 부터 10 까지 출력하는 프로그램을 작성합니다. 단 4,8번은 출력하지 마세요.
<화면출력>
1
2
3
5
6
7
9
10 */
-- if문
declare
  i number := 1;

begin
  loop 
    if i >= 1 and i <= 10 and i != 4 and i != 8 then dbms_output.put_line(i);
    elsif i > 10 then exit;
    end if;
    i := i + 1;
  end loop;

end;
/

declare
  i number := 1;

begin
  loop 
    if i = 4 or i = 8 then null;
    else dbms_output.put_line(i);
    end if;
    i := i + 1;
    exit when i > 10;
  end loop;

end;
/

-- while문
declare
  i number := 1;
  
begin
  while i <= 11 loop
    if i >= 1 and i <= 10 and i != 4 and i != 8 then dbms_output.put_line(i);
    elsif i > 10 then exit;
    end if;
    i := i + 1;
  end loop;

end;
/

-- for문
begin
  for i in 1..10 loop
    if i >= 1 and i <= 10 and i != 4 and i != 8 then dbms_output.put_line(i);
    end if;
  end loop;

end;
/

begin 
  for i in 1..10 loop
    if i = 4 or i = 8 then null;
    else dbms_output.put_line(i);
    end if;
  end loop;

end;
/

begin 
  for i in 1..10 loop
    if i != 4 and i != 8 then dbms_output.put_line(i);
    end if;
  end loop;

end;
/


--[문제16] 1번부터 100까지 짝수만 출력하세요.(기본 loop, while loop, for loop)
--loop
declare
  i number := 1;

begin
  loop
    if mod(i, 2) = 0 then dbms_output.put_line(i);
    elsif i > 100 then exit;
    end if;
    i := i + 1;
  end loop;

end;
/

-- while
declare
  i number := 1;

begin
  while i <= 100 loop
    if mod(i, 2) = 0 then dbms_output.put_line(i);
    end if;
    i := i + 1;
  end loop;

end;
/

-- for
begin
  for i in 1 .. 100 loop
    if mod(i, 2) = 0 then dbms_output.put_line(i);
    end if;
  end loop;

end;
/

-- [문제17] 1번부터 100까지 홀수만 출력하세요.
--loop
declare
  i number := 1;

begin
  loop
    if i > 100 then exit;
    elsif mod(i, 2) = 1 then dbms_output.put_line(i); 
    end if;
    i := i + 1;
  end loop;

end;
/

-- while
declare
  i number := 1;

begin
  while i <= 100 loop
    if mod(i, 2) = 1 then dbms_output.put_line(i);
    end if;
    i := i + 1;
  end loop;

end;
/

-- for
begin
  for i in 1 .. 100 loop
    if mod(i, 2) = 1 then dbms_output.put_line(i);
    end if;
  end loop;

end;
/

/*[문제18] 구구단 2단 출력하는 프로그램을 작성하세요.
2 * 1 = 2
2 * 2 = 4
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
2 * 6 = 12
2 * 7 = 14
2 * 8 = 16
2 * 9 = 18*/

declare
  v_dan number := 2;

begin
  for i in 1..9 loop
    dbms_output.put_line(v_dan || ' * ' || i || ' = ' || v_dan * i);
  end loop;

end;
/

-- [문제19] 단을 입력값으로 받아서 그 단에 대해서만 출력하시고 만약에 단 입력값이 없으면 전체 구구단이 출력되도록 작성하세요.
var b_dan number
execute :b_dan := 2
execute :b_dan := null

begin
  if :b_dan is not null then
    dbms_output.put_line('구구단 ' || :b_dan || '단입니다.');
    for i in 1..9 loop
      dbms_output.put_line(:b_dan || ' * ' || i || ' = ' || :b_dan * i);
    end loop;
  else
    for i in 2..9 loop
    dbms_output.put_line('구구단 ' || i || '단입니다.');
      for j in 1..9 loop
        dbms_output.put_line(i || ' * ' || j || ' = ' || i * j);
      end loop;
    dbms_output.put_line('');
    end loop;
  end if;
end;
/

/*[문제20] 사원 테이블의 employee_id, last_name 을 출력하는 프로그램입니다.
       사원번호는 100번 부터 해서 5씩 증가한 정보를 출력하시고 120번으로 끝내도록 해주세요.
<화면 출력>
100  King
105  Austin
110  Chen
115  khoo
120  Weiss */

declare
  v_empid number := 100;
  v_lname employees.last_name%type;

begin
  while v_empid <= 120 loop
    select last_name into v_lname from employees where employee_id = v_empid;
    dbms_output.put_line(v_empid || '번 사원의 이름은 ' || v_lname || '입니다.');
    v_empid := v_empid + 5;
  end loop;

end;
/

/*[문제21] 사원 번호를 입력 값으로 받아서 그 사원의 급여를 출력하는 프로그램을 작성합니다. 
또한 급여 1000당 별(*) 하나를 출력해주세요.(반복문을 이용하세요)
<화면출력>
employee_id => 200  salary => 4400
star is => ****     */

-- 반복문 활용
var b_empid number;
exec :b_empid := 200;
declare 
  v_sal employees.salary%type;
  v_star varchar2(10) := '';
  
begin
  select salary into v_sal from employees where employee_id = :b_empid;
  dbms_output.put_line('employee_id => ' || :b_empid || ' salary => ' || v_sal);
  
  for i in 1..trunc(v_sal/1000) loop
    v_star := v_star || '*';
  end loop;
  dbms_output.put_line('star is => ' || v_star);
  
end;
/

--substr활용
var b_empid number;
exec :b_empid := 200;
declare 
  v_sal employees.salary%type;
  v_star varchar2(10) := '**********';

begin
  select salary into v_sal from employees where employee_id = :b_empid;
  dbms_output.put_line('employee_id => ' || :b_empid || ' salary => ' || v_sal);
  dbms_output.put_line('star is => ' || substr(v_star, 0, trunc(v_sal/1000)));
  
end;
/

-- rpad활용
var b_empid number;
exec :b_empid := 200;
declare 
  v_sal employees.salary%type;

begin
  select salary into v_sal from employees where employee_id = :b_empid;
  dbms_output.put_line('employee_id => ' || :b_empid || ' salary => ' || v_sal);
  dbms_output.put_line('star is =>' || rpad(' ', trunc(v_sal/1000)+1, '*'));
  
end;
/

-- put 활용
var b_empid number;
exec :b_empid := 200;
declare 
  v_sal employees.salary%type;
  
begin
  select salary into v_sal from employees where employee_id = :b_empid;
  dbms_output.put_line('employee_id => ' || :b_empid || ' salary => ' || v_sal);
  
  for i in 1..trunc(v_sal/1000) loop
    dbms_output.put('*'); -- 출력내용을 쌓아두는 명령
  end loop;
  dbms_output.new_line; -- 쌓인 내용을 출력하는 명령
  
end;
/

/* 22번 문제: continue문을 사용하지 않고 같은 기능을 구현하기
declare
  v_total number := 0;

begin
  for i in 1..10 loop
    v_total := v_total + i;
    dbms_output.put_line('Total is : ' || v_total);
    continue when i > 5; --11g에서 등장
    v_total := v_total + i;
    dbms_output.put_line('Out of loop total is : ' || v_total);
  end loop;
  
end;
/  */
-- if문 활용
declare
  v_total number := 0;

begin
  for i in 1..10 loop
    v_total := v_total + i;
    dbms_output.put_line('Total is : ' || v_total);
    if i <= 5 then
      v_total := v_total + i;
      dbms_output.put_line('Out of loop total is : ' || v_total);
    end if;
  end loop;
  
end;
/
-- sub loop 활용
declare
  v_total number := 0;

begin
  for i in 1..10 loop
    v_total := v_total + i;
    dbms_output.put_line('Total is : ' || v_total);
    loop
      exit when i > 5
      v_total := v_total + i;
      dbms_output.put_line('Out of loop total is : ' || v_total);
      exit;
    end loop;
  end loop;
  
end;
/

/* 문제 23 continue문을 쓰지 않고 
declare
  v_total number := 0;
  
begin
  <<toploop>>
  for i in 1..10 loop
    v_total := v_total + i;
    dbms_output.put_line('Total is : ' || v_total);
    for j in 1..10 loop
      continue toploop when i+j > 5; -- continue문의 활용: 돌아갈 loop문을 지정할 수 있음
      v_total := v_total + i;
      dbms_output.put_line(v_total);
    end loop;
  end loop;

end;
/  */
-- exit when 활용
declare
  v_total number := 0;
  
begin
  <<toploop>>
  for i in 1..10 loop
    v_total := v_total + i;
    dbms_output.put_line('Total is : ' || v_total);
    for j in 1..10 loop
      exit when i+j > 5;
      v_total := v_total + i;
      dbms_output.put_line(v_total);
    end loop;
  end loop;

end;
/

-- [문제24]구구단 2단을 for loop를 이용해서 출력하세요. 단 2 * 6은 제외 시켜주세요.
-- if 활용
begin
  for i in 1..9 loop
    if i != 6 then
      dbms_output.put_line('2 * ' || i || ' = ' || 2*i);
    end if;
  end loop;

end;
/

-- continue 활용
begin
  for i in 1..9 loop
    continue when i = 6;
    dbms_output.put_line('2 * ' || i || ' = ' || 2*i);
  end loop;

end;
/

/*[문제25] 배열 변수에 있는 100,101,102,103,104, 200 사원들의 근무한 개월수를 출력하고 근무개월수가 150개월이상 되었으면 급여(salary)를 10% 인상한 급여로 수정하는 프로그램 작성하세요.
<출력 결과>
100는 근무개월수가 166 입니다. 급여는 10% 인상되었습니다.
101는 근무개월수가 139 입니다. 급여는 인상할 수 없습니다.
102는 근무개월수가 195 입니다. 급여는 10% 인상되었습니다.
103는 근무개월수가 135 입니다. 급여는 인상할 수 없습니다.
104는 근무개월수가 119 입니다. 급여는 인상할 수 없습니다.
200는 근무개월수가 163 입니다. 급여는 10% 인상되었습니다. */

declare 
  type empid_type is table of number index by binary_integer;
  v_empid empid_type;
  v_wmonth number;

begin
  v_empid(1) := 100;
  v_empid(2) := 101;
  v_empid(3) := 102;
  v_empid(4) := 103;
  v_empid(5) := 104;
  v_empid(6) := 200;
  for i in v_empid.first..v_empid.last loop
    select trunc(months_between(sysdate, hire_date)) into v_wmonth from emp where employee_id = v_empid(i);
    if v_wmonth >= 150 then
      update emp set salary = salary * 1.1 where employee_id = v_empid(i);
      dbms_output.put_line(v_empid(i) || '는 근무개월수가 ' || v_wmonth || '입니다. 급여는 10% 인상되었습니다.');
    else
      dbms_output.put_line(v_empid(i) || '는 근무개월수가 ' || v_wmonth || '입니다. 급여는 인상할 수 없습니다.');
    end if;
  end loop;
  rollback;
end;
/

/*[문제26] 배열변수안에 있는 사원 번호 값을 기준으로 (100,110,200) 
그 사원의 last_name, hire_date, department_name 정보를 배열변수에 담아놓은 후 
화면에 출력하는 프로그램을 작성하세요.
<화면결과>
100 사원의 이름은 King, 입사한 날짜는 2003-06-17, 근무 부서이름은 Executive 입니다.
110 사원의 이름은 Chen, 입사한 날짜는 2005-09-28, 근무 부서이름은 Finance 입니다.
200 사원의 이름은 whalen, 입사한 날짜는 2003-09-17, 근무 부서이름은 administration 입니다. */

declare 
  type rec_type is record(id number, last_name employees.last_name%type, hire_date employees.hire_date%type, department_name departments.department_name%type);
  type tab_type is table of rec_type index by pls_integer;
  v_tab tab_type;
begin
  v_tab(1).id := 100;
  v_tab(2).id := 110;
  v_tab(3).id := 200;
  for i in v_tab.first..v_tab.last loop
    select e.last_name, e.hire_date, d.department_name into v_tab(i).last_name, v_tab(i).hire_date, v_tab(i).department_name from emp e, departments d where e.department_id = d.department_id and employee_id = v_tab(i).id;
    dbms_output.put_line(v_tab(i).id || '사원의 이름은 ' || v_tab(i).last_name || ', 입사한 날짜는 ' || to_char(v_tab(i).hire_date, 'yyyy-mm-dd') || ', 근무 부서이름은 ' || v_tab(i).department_name || '입니다.');
  end loop;

end;
/

/*[문제27]배열 변수에 있는 100,101,102,103,104, 200 사원번호를 기준으로 사원 이름, 근무개월수 150개월이상 되었으면 급여(salary)를 10% 인상한 급여로 수정한 후 , 인상 전 급여, 인상 후 급여를 출력하는  프로그램을 작성하세요.
사원 번호 : 100 사원 이름 :  King    근무개월수 :  166 인상 전 급여 : 24000 인상 후 급여 : 26400
사원 번호 : 101 사원 이름 :  Kochhar 근무개월수 :  139 17000 급여는 인상할 수 없습니다.
사원 번호 : 102 사원 이름 :  De Haan 근무개월수 :  195 인상 전 급여 : 17000 인상 후 급여 : 18700
사원 번호 : 103 사원 이름 :  Hunold  근무개월수 :  135 9000 급여는 인상할 수 없습니다.
사원 번호 : 104 사원 이름 :  ernst   근무개월수 :  119 6000 급여는 인상할 수 없습니다.
사원 번호 : 200 사원 이름 :  Whalen  근무개월수 :  163 인상 전 급여 : 4400 인상 후 급여 : 4840 */

declare
  type rec_emp_type is record(lname emp.last_name%type, wmonth number, sal emp.salary%type);
  type tab_num_type is table of number;
  v_empid tab_num_type := tab_num_type(100, 101, 102, 103, 104, 200);
  v_sal rec_emp_type;
  v_newsal emp.salary%type;
  
begin
  for i in v_empid.first..v_empid.last loop
    select last_name, trunc(months_between(sysdate, hire_date)), salary into v_sal.lname, v_sal.wmonth, v_sal.sal from employees where employee_id = v_empid(i);
    if v_sal.wmonth >= 150 then
      update emp set salary = salary * 1.1 where employee_id = v_empid(i) returning salary into v_newsal;
      dbms_output.put_line('사원 번호 : ' || v_empid(i) || ' 사원 이름 : ' || rpad(v_sal.lname, 8, ' ') || '근무개월수 : ' || v_sal.wmonth || ' 인상 전 급여 : ' || v_sal.sal || ' 인상 후 급여 : ' || v_newsal);
    else
      dbms_output.put_line('사원 번호 : ' || v_empid(i) || ' 사원 이름 : ' || rpad(v_sal.lname, 8, ' ') || '근무개월수 : ' || v_sal.wmonth || ' ' || v_sal.sal || ' 급여는 인상할 수 없습니다.');
    end if;
  end loop;
  rollback;

end;
/

/*[문제28] 배열에 1,2,4,5,6,10,20,21,55,60,22,8,0,6,20,40,6,9 값이 있습니다.
	 찾는 숫자의 배열 위치 정보 총갯수 정보를 출력하세요.
<화면결과>
20 값은 배열에 7,15 위치에 있으며 총 2 개 있습니다.
100 값은 없습니다. */
declare
  type target_num_type is table of number;
  type loc_num_type is table of number index by pls_integer;
  v_tlist target_num_type := target_num_type(1,2,4,5,6,10,20,21,55,60,22,8,0,6,20,40,6,9);
  v_loc loc_num_type;
  v_target number;
  v_loc_char varchar2(100);

begin  
  v_target := 20;
  for i in v_tlist.first..v_tlist.last loop
    if v_tlist(i) = v_target then
      v_loc(i) := i;
    end if;
  end loop;
  
  if v_loc.count > 0 then
    for i in v_loc.first..v_loc.last loop
      if v_loc.exists(i) then
        v_loc_char := v_loc_char || ',' || v_loc(i);
      end if;
    end loop;
    dbms_output.put_line(v_target || ' 값은 배열에 ' || ltrim(v_loc_char, ',') || '위치에 있으며 총 ' || v_loc.count || '개 있습니다.');
  else
    dbms_output.put_line(v_target || ' 값은 없습니다.');
  end if;

end;
/

/*[문제29] 사원의 last_name 값을 입력 받아서 그 사원의 employee_id, last_name, department_name 출력하고 
만약의 없는 last_name을 입력 할경우에는  "Hong 이라는 사원은 존재하지 않습니다."  출력 하는 프로그램을 만드세요.
입력값 : king
Employee Id = 156 Name = King Department Name = Sales
Employee Id = 100 Name = King Department Name = Executive

입력값 : hong
hong 이라는 사원은 존재하지 않습니다. */

var ename varchar2(10);
exec :ename := 'hong';

declare
  cursor emp_cur is select e.employee_id, d.department_name from employees e, departments d where e.department_id = d.department_id and e.last_name = initcap(:ename);
  
begin  
  for emp_rec in emp_cur loop
    if emp_cur%found then
      dbms_output.put_line('Employee Id = ' || emp_rec.employee_id || ' Name = ' || initcap(:ename) || ' Department Name = ' || emp_rec.department_name);
    else -- fetch된 결과가 없을 시 for문을 바로 탈출해버려 else문은 실행되지 않음
      dbms_output.put_line(initcap(:ename) || '이라는 사원은 존재하지 않습니다.');
    end if;
  end loop;

end;
/

declare
  cursor emp_cur is select e.employee_id, d.department_name from employees e, departments d where e.department_id = d.department_id and e.last_name = initcap(:ename);
  v_result emp_cur%rowtype;
  
begin  
  open emp_cur;
  loop
    fetch emp_cur into v_result;
    if emp_cur%rowcount = 0 then
      dbms_output.put_line(initcap(:ename) || '이라는 사원은 존재하지 않습니다.');
      exit;
    elsif emp_cur%notfound then
      exit;
    end if;
    dbms_output.put_line('Employee Id = ' || v_result.employee_id || ' Name = ' || initcap(:ename) || ' Department Name = ' || v_result.department_name);
  end loop;
  close emp_cur;
    
end;
/

declare
 cursor c1 is select e.employee_id, e.last_name, d.department_name from employees e, departments d where e.department_id = d.department_id and e.last_name = initcap(:ename);
 v_c number := 0;

begin
  for v_rec in c1 loop
    DBMS_OUTPUT.PUT_LINE('Employee Id = ' || v_rec.employee_id ||' Name = ' || v_rec.last_name ||' Department Name = '||v_rec.department_name);
    v_c := c1%rowcount;
  end loop;
      
  if v_c = 0 then 
    dbms_output.put_line(initcap(:ename) ||' 이라는 사원은 존재하지 않습니다.');
  else
    DBMS_OUTPUT.PUT_LINE(initcap(:ename) ||' 이라는 사원은 '|| v_c ||' 명 입니다.');
  end if;
  
end;
/

/* [문제30] 2006년도에 입사한 사원들의 근무 도시이름별로 급여의 총액, 평균을 출력하세요.
<화면출력>
Seattle 도시에 근무하는 사원들의 총액급여는 ￦10,400 이고 평균급여는 ￦5,200 입니다.
South San Francisco 도시에 근무하는 사원들의 총액급여는 ￦37,800 이고 평균급여는 ￦2,907 입니다.
Southlake 도시에 근무하는 사원들의 총액급여는 ￦13,800 이고 평균급여는 ￦6,900 입니다.
oxford 도시에 근무하는 사원들의 총액급여는 ￦59,100 이고 평균급여는 ￦8,442 입니다. */

declare
  cursor sal2006 is select l.city, sum(e.salary) as sumsal, round(avg(e.salary)) as avgsal
                    from employees e, departments d, locations l
                    where e.department_id = d.department_id
                    and d.location_id = l.location_id
                    and e.hire_date between to_date('20060101', 'yyyymmdd') and to_date('20061231 235959', 'yyyymmdd hh24miss')
                    group by l.city;

begin
  for sal_rec in sal2006 loop
    dbms_output.put_line(sal_rec.city || ' 도시에 근무하는 사원들의 총액급여는 ' || trim(to_char(sal_rec.sumsal, 'l999g999')) || ' 이고 평균급여는 ' || trim(to_char(sal_rec.avgsal, 'l999g999')) || ' 입니다.');
  end loop;
  
end;
/
-- bulk collect into 활용
declare
  type rec_type is record(city locations.city%type, sumsal number, avgsal number);
  type tab_type is table of rec_type;
  v_tab tab_type;

begin
  select l.city, sum(e.salary) as sumsal, round(avg(e.salary)) as avgsal
  bulk collect into v_tab
  from employees e, departments d, locations l
  where e.department_id = d.department_id
  and d.location_id = l.location_id
  and e.hire_date between to_date('20060101', 'yyyymmdd') and to_date('20061231 235959', 'yyyymmdd hh24miss')
  group by l.city;
  
  for i in v_tab.first..v_tab.last loop
    dbms_output.put_line(v_tab(i).city || ' 도시에 근무하는 사원들의 총액급여는 ' || trim(to_char(v_tab(i).sumsal, 'l999g999')) || ' 이고 평균급여는 ' || trim(to_char(v_tab(i).avgsal, 'l999g999')) || ' 입니다.');
  end loop;

end;
/

-- 커서 선언 없이 for문에 바로 select문을 넣을 시 자동으로 커서 생성됨
-- 명시적 커서이지만 이름이 없음 -> 커서의 속성을 확인할 수 없음
begin 
  for v_rec in (select l.city, sum(e.salary) as sumsal, round(avg(e.salary)) as avgsal
                    from employees e, departments d, locations l
                    where e.department_id = d.department_id
                    and d.location_id = l.location_id
                    and e.hire_date between to_date('20060101', 'yyyymmdd') and to_date('20061231 235959', 'yyyymmdd hh24miss')
                    group by l.city;) loop
    dbms_output.put_line(sal_rec.city || ' 도시에 근무하는 사원들의 총액급여는 ' || trim(to_char(sal_rec.sumsal, 'l999g999')) || ' 이고 평균급여는 ' || trim(to_char(sal_rec.avgsal, 'l999g999')) || ' 입니다.');
  end loop;
  
end;
/

/*[문제31] 30번 부서 사원들의 이름, 급여, 근무개월수, 부서이름을 출력하고 그 사원들 중에 근무개월수가 150개월 이상인 사원들의 급여를 10%인상하는 프로그램을 작성하세요.
<화면 출력>
사원이름 : Raphaely 급여 : 11000 근무개월수 : 172 부서 이름 :  Purchasing
Raphaely 10%인상 급여로 수정했습니다.
사원이름 : Khoo 급여 : 3100 근무개월수 : 167 부서 이름 :  Purchasing
Khoo 10%인상 급여로 수정했습니다.
사원이름 : Baida 급여 : 2900 근무개월수 : 136 부서 이름 :  Purchasing
사원이름 : tobias 급여 : 2800 근무개월수 : 141 부서 이름 :  purchasing
사원이름 : Himuro 급여 : 2600 근무개월수 : 125 부서 이름 :  Purchasing
사원이름 : Colmenares 급여 : 2500 근무개월수 : 116 부서 이름 :  Purchasing */
-- rowid 활용
declare
  cursor sal_cur is select e.rowid, e.last_name, e.salary, trunc(months_between(sysdate, e.hire_date)) as wmonth, d.department_name from emp e, departments d where e.department_id = 30 and d.department_id = 30;
  
begin
  for sal_rec in sal_cur loop
    dbms_output.put_line('사원이름 : ' || sal_rec.last_name || ' 급여 : ' || sal_rec.salary || ' 근무개월수 : ' || sal_rec.wmonth || ' 부서 이름 : ' || sal_rec.department_name );
    if sal_rec.wmonth >= 150 then    
      update emp set salary = salary * 1.1 where rowid = sal_rec.rowid;
      if sql%found then
        dbms_output.put_line(sal_rec.last_name || ' 10%인상 급여로 수정했습니다.');
      end if;
    end if;
  end loop;
  rollback;

end;
/
-- for update & current of 활용
declare
  cursor sal_cur is select e.last_name, e.salary, trunc(months_between(sysdate, e.hire_date)) as wmonth, d.department_name from emp e, departments d where e.department_id = 30 and d.department_id = 30
  for update of e.last_name nowait;
  v_newsal number
  
begin
  for sal_rec in sal_cur loop
    dbms_output.put_line('사원이름 : ' || sal_rec.last_name || ' 급여 : ' || sal_rec.salary || ' 근무개월수 : ' || sal_rec.wmonth || ' 부서 이름 : ' || sal_rec.department_name );
    if sal_rec.wmonth >= 150 then
      update emp set salary = salary * 1.1 where current of sal_cur; -- current of 를 쓸때는 returning 절 사용 불가
      if sql%found then
        dbms_output.put_line(sal_rec.last_name || ' 10%인상 급여인 '|| v_newsal ||'로 수정했습니다.');
      end if;
    end if;
  end loop;
  rollback;

end;
/

-- bulk collect into 활용
declare
  type rec_type is record(rowid varchar2(18), lname emp.last_name%type, sal emp.salary%type, wmonth number, deptname departments.department_name%type);
  type tab_type is table of rec_type;
  v_tab tab_type;
  v_newsal number;
  
begin
  select e.rowid, e.last_name, e.salary, trunc(months_between(sysdate, e.hire_date)) as wmonth, d.department_name bulk collect into v_tab from emp e, departments d where e.department_id = 30 and d.department_id = 30;
  
  for i in v_tab.first..v_tab.last loop
    dbms_output.put_line('사원이름 : ' || v_tab(i).lname || ' 급여 : ' || v_tab(i).sal || ' 근무개월수 : ' || v_tab(i).wmonth || ' 부서 이름 : ' || v_tab(i).deptname );
    if v_tab(i).wmonth >= 150 then
      update emp set salary = salary * 1.1 where rowid = v_tab(i).rowid returning salary into v_newsal;
      if sql%found then
        dbms_output.put_line(v_tab(i).lname || ' 10%인상 급여인 '|| v_newsal ||'로 수정했습니다.');
      end if;
    end if;
  end loop;
  rollback;

end;
/

--[문제32] 사원테이블에 부서코드를 입력값으로 받아서 그 사원들의 employee_id, last_name, salary, job_id를 출력하는 프로그램을 생성하세요. 단   부서코드중에 50,80, null 값이 입력되면 full table scan 그외 부서 코드값이 입력 입력되면 index range scan으로 실행계획을 분리하세요.
var b_id number
execute :b_id := 50
execute :b_id := 10
execute :b_id := null

-- 건수확인(분포도 확인)
select department_id, count(*) from emp group by department_id order by department_id;
/*
10	1
20	2
30	6
40	1
50	45
60	5
70	1
80	34
90	3
100	6
110	2
null 1
*/
-- 인덱스 확인 & 생성
select * from user_indexes where table_name = 'EMP';
create index emp_deptid_idx on emp(department_id);

declare
  type emp_rec_type is record(empid emp.employee_id%type, lname emp.last_name%type, sal emp.salary%type, jobid emp.job_id%type);
  type emp_tab_type is table of emp_rec_type;
  v_tab emp_tab_type;

begin 
  if :b_id in (50, 80) then
    select /*+ full(emp) parallel(emp, 2)*/employee_id, last_name, salary, job_id bulk collect into v_tab from emp where department_id = :b_id;
    dbms_output.put_line(:b_id || '번 부서 사원의 정보입니다.');
    for i in v_tab.first..v_tab.last loop
      dbms_output.put_line('사원ID: ' || v_tab(i).empid || ' 이름: ' || v_tab(i).lname || ' 급여: ' || trim(to_char(v_tab(i).sal, 'l999g999g999')) || ' 직책: ' || v_tab(i).jobid);
    end loop;
  elsif :b_id is null then
    select /*+ full(emp)*/employee_id, last_name, salary, job_id bulk collect into v_tab from emp where department_id is null;
    dbms_output.put_line('부서가 없는 사원의 정보입니다.');
    for i in v_tab.first..v_tab.last loop
      dbms_output.put_line('사원ID: ' || v_tab(i).empid || ' 이름: ' || v_tab(i).lname || ' 급여: ' || trim(to_char(v_tab(i).sal, 'l999g999g999')) || ' 직책: ' || v_tab(i).jobid);
    end loop;
  else 
    select /*+ index_rs(emp emp_empid_pk)*/employee_id, last_name, salary, job_id bulk collect into v_tab from emp where department_id = :b_id;
    dbms_output.put_line(:b_id || '번 부서 사원의 정보입니다.');
    for i in v_tab.first..v_tab.last loop
      dbms_output.put_line('사원ID: ' || v_tab(i).empid || ' 이름: ' || v_tab(i).lname || ' 급여: ' || trim(to_char(v_tab(i).sal, 'l999g999g999')) || ' 직책: ' || v_tab(i).jobid);
    end loop;  
  end if;

end;
/

/*[문제33] 사원 번호를 입력 값으로 받아서 사원의 번호, 이름, 부서이름 정보를 출력하는 프로그램을 작성합니다.
단 100번 사원이 입력값으로 들어오면 예외사항이 발생하도록 해야 합니다.
또한 없는 사원번호 값이 들어오면 예외사항 처리을 만들어 주세요.
<화면 결과>
SQL> var b_id number
SQL> execute :b_id := 200
Result=> 사원번호 : 200, 사원이름 : Whalen, 부서이름 : Administration
SQL> execute :b_id := 100
100 사원은 조회할수 없습니다.
SQL> execute :b_id := 300
300 사원은 존재하지 않습니다. */

var b_id number
exec :b_id := 300

declare
  type emp_rec is record(lname emp.last_name%type, dname departments.department_name%type);
  v_rec emp_rec;
  vip exception;
  
begin
  if :b_id = 100 then
    raise vip;
  else
    select e.last_name, d.department_name into v_rec from employees e, departments d where e.department_id = d.department_id and e.employee_id = :b_id;
    dbms_output.put_line('Result=> 사원번호 : ' || :b_id || ', 사원이름 : ' || v_rec.lname || ', 부서이름 : ' || v_rec.dname);
  end if;

exception
  when vip then
    dbms_output.put_line(:b_id || ' 사원은 조회할 수 없습니다.');
  
  when no_data_found then
    dbms_output.put_line(:b_id || ' 사원은 존재하지 않습니다.');

end;
/

/*[문제34] 사원들 중에 job_id가 'SA_REP' 사원들의 이름, 부서 이름을 출력하고 부서 배치를 받지 않는
사원들에 대해서는 "부서 배치를 못 받았습니다." 출력해야 합니다.
또한 출력할때 카운터 수를 출력해주세요.(조인은 이용하지 마세요)
1 사원이름 : Tucker, 부서이름 : Sales
2 사원이름 : Bernstein, 부서이름 : Sales
3 사원이름 : Hall, 부서이름 : Sales
4 사원이름 : Olsen, 부서이름 : Sales
5 사원이름 : Cambrault, 부서이름 : Sales
6 사원이름 : Tuvault, 부서이름 : Sales
7 사원이름 : King, 부서이름 : Sales
8 사원이름 : Sully, 부서이름 : Sales
9 사원이름 : McEwen, 부서이름 : Sales
10 사원이름 : Smith, 부서이름 : Sales
11 사원이름 : Doran, 부서이름 : Sales
12 사원이름 : Sewall, 부서이름 : Sales
13 사원이름 : Vishney, 부서이름 : Sales
14 사원이름 : Greene, 부서이름 : Sales
15 사원이름 : Marvins, 부서이름 : Sales
16 사원이름 : Lee, 부서이름 : Sales
17 사원이름 : Ande, 부서이름 : Sales
18 사원이름 : Banda, 부서이름 : Sales
19 사원이름 : Ozer, 부서이름 : Sales
20 사원이름 : Bloom, 부서이름 : Sales
21 사원이름 : Fox, 부서이름 : Sales
22 사원이름 : Smith, 부서이름 : Sales
23 사원이름 : Bates, 부서이름 : Sales
24 사원이름 : Kumar, 부서이름 : Sales
25 사원이름 : Abel, 부서이름 : Sales
26 사원이름 : Hutton, 부서이름 : Sales
27 사원이름 : Taylor, 부서이름 : Sales
28 사원이름 : Livingston, 부서이름 : Sales
29 사원이름 : grant, 부서이름 : 부서 배치를 못 받았습니다.
30 사원이름 : Johnson, 부서이름 : Sales */

declare
  type emp_rec_type is record(lname emp.last_name%type, deptid emp.department_id%type);
  type emp_tab_type is table of emp_rec_type;
  v_emp_tab emp_tab_type;
  v_deptname departments.department_name%type;
  
begin
  select last_name, department_id bulk collect into v_emp_tab from emp where job_id = 'SA_REP';
  for i in v_emp_tab.first..v_emp_tab.last loop
    if v_emp_tab(i).deptid is null then
      dbms_output.put_line( i || ' 사원이름 : ' ||v_emp_tab(i).lname || ', 부서이름: 부서 배치를 못 받았습니다.');
    else
      select department_name into v_deptname from departments where department_id = v_emp_tab(i).deptid;
      dbms_output.put_line( i || ' 사원이름 : ' ||v_emp_tab(i).lname || ', 부서이름: ' || v_deptname);
    end if;
  end loop;

end;
/

-- departments 테이블에 접근하는 횟수를 줄여보자 -> **스칼라 서브쿼리**를 쓰자
declare
  type emp_rec_type is record(lname emp.last_name%type, deptid emp.department_id%type);
  type emp_tab_type is table of emp_rec_type;
  v_emp_tab emp_tab_type;
  type deptid_tab_type is table of departments.department_name%type index by pls_integer;
  v_deptid_tab deptid_tab_type;
  
begin
  select last_name, department_id bulk collect into v_emp_tab from emp where job_id = 'SA_REP';
  for i in v_emp_tab.first..v_emp_tab.last loop
    if v_emp_tab(i).deptid is not null then
      v_deptid_tab(v_emp_tab(i).deptid) := null;
    end if;
  end loop;
  
  for i in v_deptid_tab.first..v_deptid_tab.last loop
    select department_name into v_deptid_tab(i) from departments where department_id = i;
  end loop;
  
  for i in v_emp_tab.first..v_emp_tab.last loop
    if v_emp_tab(i).deptid is null then
      dbms_output.put_line( i || ' 사원이름 : ' ||v_emp_tab(i).lname || ', 부서이름: 부서 배치를 못 받았습니다.');
    else
      dbms_output.put_line( i || ' 사원이름 : ' ||v_emp_tab(i).lname || ', 부서이름: ' || v_deptid_tab(v_emp_tab(i).deptid));
    end if;
  end loop;
  
end;
/

/**선생님 답들**/
DECLARE
 cursor emp_cursor is
	SELECT last_name, department_id FROM employees WHERE job_id = 'SA_REP';
 v_dept_name departments.department_name%type;
 v_c number := 1;
BEGIN
	FOR c_rec IN emp_cursor LOOP
		begin
			SELECT department_name INTO v_dept_name FROM departments WHERE department_id = c_rec.department_id;
			dbms_output.put_line(v_c||  ' 사원이름 : '||c_rec.last_name ||', 부서이름 : '||v_dept_name);
			v_c := v_c+1;

    EXCEPTION
      when no_data_found then 
      dbms_output.put_line(v_c||  ' 사원이름 : '||c_rec.last_name ||', 부서이름 : 부서 배치를 못 받았습니다.');
       v_c := v_c + 1;
    END;
  END LOOP;

END;
/

DECLARE
  v_dept_name departments.department_name%type;
  v_c number := 1;

BEGIN
	FOR c_rec IN (SELECT last_name, department_id FROM  employees WHERE job_id = 'SA_REP') LOOP
    begin
      SELECT department_name INTO v_dept_name	FROM departments WHERE department_id = c_rec.department_id;
			dbms_output.put_line(v_c||  ' 사원이름 : '||c_rec.last_name ||', 부서이름 : '||v_dept_name);
			v_c := v_c+1;
    EXCEPTION
      when no_data_found then 
        dbms_output.put_line(v_c||  ' 사원이름 : '||c_rec.last_name ||', 부서이름 : 부서배치를 못 받았습니다.');
        v_c := v_c + 1;
    end;
  END LOOP;

END;
/

declare
  cursor emp_cursor is select last_name, department_id from employees	where job_id = 'SA_REP';
  c_rec emp_cursor%rowtype;
  v_dept_name departments.department_name%type;
  v_c number := 1;

BEGIN
  open emp_cursor;
  LOOP
    FETCH emp_cursor INTO c_rec;
    EXIT WHEN emp_cursor%NOTFOUND;
  	begin
			SELECT department_name INTO v_dept_name FROM departments WHERE department_id = c_rec.department_id;
			dbms_output.put_line(v_c||  ' 사원이름 : '||c_rec.last_name ||', 부서이름 : '||v_dept_name);
			v_c := v_c+1;
    EXCEPTION
      WHEN no_data_found THEN 
        dbms_output.put_line(v_c||  ' 사원이름 : '||c_rec.last_name ||', 부서이름 : 부서 배치를 못 받았습니다.');
		    v_c := v_c + 1;
    END;     
	END LOOP;
  CLOSE emp_cursor;

END;
/

DECLARE
 CURSOR emp_cursor IS	SELECT last_name, department_id FROM  employees	WHERE job_id = 'SA_REP';
 TYPE emp_tab_type IS TABLE OF emp_cursor%rowtype;
 v_tab emp_tab_type;
 v_dept_name departments.department_name%type;
 v_c number := 1;

BEGIN
 OPEN emp_cursor;
 FETCH emp_cursor BULK COLLECT INTO v_tab;
  FOR i IN v_tab.first..v_tab.last LOOP
		begin
      SELECT department_name INTO v_dept_name	FROM departments WHERE department_id = v_tab(i).department_id;
      dbms_output.put_line(v_c||  ' 사원이름 : '||v_tab(i).last_name ||', 부서이름 : '||v_dept_name);
			v_c := v_c+1;
    EXCEPTION
      WHEN no_data_found THEN 
        dbms_output.put_line(v_c||  ' 사원이름 : '||v_tab(i).last_name ||', 부서이름 : 부서 배치를 못 받았습니다.');
		    v_c := v_c + 1;
    END;
	end loop;
  CLOSE emp_cursor;

END;
/

/*****스칼라 서브쿼리!! 활용: 동일한 값이 들어갈 때 캐시기능을 적용*****/
DECLARE
 cursor emp_cursor is	select rownum no, e.last_name, 
  nvl((select  department_name from departments where department_id = e.department_id), '부서 배치를 못받았습니다.') dept_name	from employees e	where  e.job_id = 'SA_REP';
 TYPE emp_tab_type IS TABLE OF emp_cursor%rowtype;
 v_tab emp_tab_type;

BEGIN
  open emp_cursor;
  fetch emp_cursor bulk collect into v_tab;
  FOR i IN v_tab.first..v_tab.last LOOP
    dbms_output.put_line(v_tab(i).no||  ' 사원이름 : '||v_tab(i).last_name ||', 부서이름 : '||v_tab(i).dept_name);
  end loop;
  CLOSE emp_cursor;

END;
/


DECLARE
 TYPE emp_rec_type IS RECORD(no number, name varchar2(30), dept_name varchar2(50));
 TYPE emp_tab_type IS TABLE OF emp_rec_type;
 v_tab emp_tab_type;
BEGIN
	select rownum, e.last_name, nvl((select department_name from departments where department_id = e.department_id), '부서 배치를 못받았습니다.') 
  bulk collect into v_tab FROM employees e WHERE  e.job_id = 'SA_REP';
  for i in v_tab.first..v_tab.last loop
  	dbms_output.put_line(v_tab(i).no||  ' 사원이름 : '||v_tab(i).name ||', 부서이름 : '||v_tab(i).dept_name);
  END LOOP;

end;
/

/*[문제35] 전체 사원 들의 사번, 이름, 급여, 입사일, 근무연수를 출력합니다.
또한 근무연수가 13년 이상이고 급여는 10000 미만인 사원들은 예외사항이 발생하도록 한 후 
메시지 출력하고  프로그램 수행이 완료된 후에 분석할수있도록  years 테이블에 정보가 입력이 되도록 프로그램을 작성합니다. 근무연수는 소수점은 버리세요
SQL> create table years(id number, name varchar2(30), sal number, year number);
<화면 출력>
....
201, Hartstein, 13000, 04/02/17, 12
202, Fay, 6000, 05/08/17, 10
203, Mavris, 6500, 02/06/07, 13
사원 203 근무연수는 13 년이고 급여는 6500 입니다.
204, Baer, 10000, 02/06/07, 13
205, Higgins, 12008, 02/06/07, 13
206, Gietz, 8300, 02/06/07, 13
사원 206 근무연수는 13 년이고 급여는 8300 입니다.
....
SQL> select * from years; */
create table years(id number, name varchar2(30), sal number, year number);
select * from years;
truncate table years; --테이블 데이터 전체 삭제 & rollback 불가능

-- exception 없이 구현
declare
  type emp_rec_type is record(id emp.employee_id%type, name emp.last_name%type, sal emp.salary%type, hdate emp.hire_date%type, wyear number);
  type emp_tab_type is table of emp_rec_type;
  v_emp_tab emp_tab_type;
    
begin
  select employee_id, last_name, salary, hire_date, trunc(months_between(sysdate, hire_date)/12) bulk collect into v_emp_tab from emp;
  for i in v_emp_tab.first..v_emp_tab.last loop
    dbms_output.put_line(v_emp_tab(i).id || ', ' || v_emp_tab(i).name || ', ' || v_emp_tab(i).sal || ', ' || v_emp_tab(i).hdate || ', ' || v_emp_tab(i).wyear);
    if v_emp_tab(i).wyear >= 13 and v_emp_tab(i).sal < 10000 then
      dbms_output.put_line('사원 ' || v_emp_tab(i).id || ' 근무연수는 ' || v_emp_tab(i).wyear || ' 년이고 급여는 ' || v_emp_tab(i).sal || ' 입니다.');
      insert into years values (v_emp_tab(i).id, v_emp_tab(i).name, v_emp_tab(i).sal, v_emp_tab(i).wyear);
    end if;
  end loop;
  
end;
/

-- exception 통해서 구현
declare
  type emp_rec_type is record(id emp.employee_id%type, name emp.last_name%type, sal emp.salary%type, hdate emp.hire_date%type, wyear number);
  type emp_tab_type is table of emp_rec_type;
  v_emp_tab emp_tab_type;
  minor exception;
    
begin
  select employee_id, last_name, salary, hire_date, trunc(months_between(sysdate, hire_date)/12) bulk collect into v_emp_tab from emp;
  for i in v_emp_tab.first..v_emp_tab.last loop
    begin
      dbms_output.put_line(v_emp_tab(i).id || ', ' || v_emp_tab(i).name || ', ' || v_emp_tab(i).sal || ', ' || v_emp_tab(i).hdate || ', ' || v_emp_tab(i).wyear);
      if v_emp_tab(i).wyear >= 13 and v_emp_tab(i).sal < 10000 then
        raise minor;
      end if;
    
    exception
      when minor then
        dbms_output.put_line('사원 ' || v_emp_tab(i).id || ' 근무연수는 ' || v_emp_tab(i).wyear || ' 년이고 급여는 ' || v_emp_tab(i).sal || ' 입니다.');
        insert into years values (v_emp_tab(i).id, v_emp_tab(i).name, v_emp_tab(i).sal, v_emp_tab(i).wyear);
    end;
  end loop;
  commit;
end;
/

-- [문제36] 사원번호를 입력값으로 받아서 그사원의 급여를 10%인상하는 프로시저를 생성하세요. 프로시저이름은 raise_sal로 생성하세요.
create or replace procedure raise_sal(id number)
is 
begin
  update emp set salary = salary * 1.1 where employee_id = id;
  if sql%found then 
    dbms_output.put_line(id || '사원의 급여를 수정했습니다.');
  else
    dbms_output.put_line(id || '사원이 존재하지 않습니다.');
  end if;
  
end;
/

/*[문제37] 사원번호를 입력 값으로 받아서 그 사원의 이름, 급여, 부서 이름을 출력하는 query_emp 프로시저 생성하세요.
단 100번 사원이 입력 값으로 들어오면 프로그램은 아무런 작업하지 않고 종료 될 수 있어야 합니다. 
또한 사원이 없을 경우 예외 사항 처리해주세요.

SQL> execute query_emp(100)
PL/SQL procedure successfully completed.

SQL> execute query_emp(101)
사원 이름: Kochhar 사원 급여: 17000 사원 부서 이름: Executive
PL/SQL procedure successfully completed.

SQL> execute query_emp(300)
300 존재하지 않는 사원입니다.
pl/sql procedure successfully completed. */
exec query_emp(100);
show error;
-- exception으로 100번 사원 제외
create or replace procedure query_emp(p_empid in number)
is
  e_vip exception;
  type emp_rec_type is record(lname employees.last_name%type, sal employees.salary%type, dname departments.department_name%type);
  v_emp_rec emp_rec_type;
  
begin
  if p_empid = 100 then
    raise e_vip;
  else
    select last_name, salary, (select department_name from departments where department_id = e.department_id) into v_emp_rec from employees e where employee_id = p_empid;
    dbms_output.put_line('사원 이름: ' || v_emp_rec.lname || ' 사원 급여: ' || v_emp_rec.sal || ' 사원 부서 이름: ' || v_emp_rec.dname);
  end if;

exception
  when e_vip then
    null;
    
  when no_data_found then
    dbms_output.put_line(p_empid || ' 존재하지 않는 사원입니다.');

end query_emp; -- 메인블럭 종료
/
-- if문으로 100번 사원제외
create or replace procedure query_emp1(p_empid in number)
is
  type emp_rec_type is record(lname employees.last_name%type, sal employees.salary%type, dname departments.department_name%type);
  v_emp_rec emp_rec_type;
  
begin
  if p_empid = 100 then
    null;
  else
    select last_name, salary, (select department_name from departments where department_id = e.department_id) into v_emp_rec from employees e where employee_id = p_empid;
    dbms_output.put_line('사원 이름: ' || v_emp_rec.lname || ' 사원 급여: ' || v_emp_rec.sal || ' 사원 부서 이름: ' || v_emp_rec.dname);
  end if;

exception 
  when no_data_found then
    dbms_output.put_line(p_empid || ' 존재하지 않는 사원입니다.');

end query_emp1;
/

-- return문 *프로시저의 return문은 함수의 return과 다르다
create or replace procedure query_emp1(p_empid in number)
is
  type emp_rec_type is record(lname employees.last_name%type, sal employees.salary%type, dname departments.department_name%type);
  v_emp_rec emp_rec_type;
  
begin
  if p_empid = 100 then
    return; -- return문을 만나면 프로그램 바로 종료.
  else
    select last_name, salary, (select department_name from departments where department_id = e.department_id) into v_emp_rec from employees e where employee_id = p_empid;
    dbms_output.put_line('사원 이름: ' || v_emp_rec.lname || ' 사원 급여: ' || v_emp_rec.sal || ' 사원 부서 이름: ' || v_emp_rec.dname);
  end if;

exception 
  when no_data_found then
    dbms_output.put_line(p_empid || ' 존재하지 않는 사원입니다.');

end query_emp1;
/

/*[문제38] 사원번호를 입력값으로 받아서 그 사원의 근무개월수를 출력하고 근무개월수가
180개월 이상이면 급여를 20% 인상한 급여로 수정, 
179개월 보다 작거나 같고 150개월 보다 크거나 같으면  10%인상한 급여로 수정,
150개월 미만인 근무자는 아무 작업을 수행하지 않는 프로그램을 작성하세요.
테스트가 끝나면 rollback 합니다.

begin
  sal_update_proc(100);
  rollback;
end;
/

100 사원은 근무개월수가 166 입니다. 이전 급여는 24000 수정된 급여는 26400 입니다.

begin
  sal_update_proc(103);
  rollback;
end;
/

103 사원은 근무개월수가 136 입니다. 150 개월 미만입니다.9000 급여는 수정 안됩니다. */
-- 테스트
begin
  sal_update_proc(104);
  rollback;
end;
/

create or replace procedure sal_update_proc(p_id in number)
is
  v_wmonth number;
  v_sal emp.salary%type;
  v_nsal v_sal%type;

begin
  select trunc(months_between(sysdate, hire_date)), salary into v_wmonth, v_sal from emp where employee_id = p_id;
  if v_wmonth >= 180 then
    update emp set salary = salary * 1.2 where employee_id = p_id returning salary into v_nsal;
  elsif v_wmonth between 150 and 179 then
    update emp set salary = salary * 1.1 where employee_id = p_id returning salary into v_nsal;
  else
    dbms_output.put_line(p_id||' 사원은 근무개월수가 '||v_wmonth||' 입니다. 150 개월 미만입니다. 급여는 '||v_sal||' 에서 수정되지 않습니다.');
    return;
  end if;
  dbms_output.put_line(p_id||' 사원은 근무개월수가 '||v_wmonth||' 입니다. 이전 급여는 '||v_sal||' 수정된 급여는 '||v_nsal||' 입니다.');

exception
  when no_data_found then
    dbms_output.put_line('없는 사원 번호입니다.');
  
end sal_update_proc;
/

-- rowid scan으로 튜닝
create or replace procedure sal_update_proc(p_id in number)
is
  v_wmonth number;
  v_sal emp.salary%type;
  v_nsal v_sal%type;
  v_rowid rowid;
  v_pct number;

begin
  select rowid, trunc(months_between(sysdate, hire_date)), salary into v_rowid, v_wmonth, v_sal from emp where employee_id = p_id;
  if v_wmonth >= 180 thend
    v_pct := 1.2;
  elsif v_wmonth between 150 and 179 then
    v_pct := 1.1;
  else
    dbms_output.put_line(p_id||' 사원은 근무개월수가 '||v_wmonth||' 입니다. 150 개월 미만입니다. 급여는 '||v_sal||' 에서 수정되지 않습니다.');
    return;
  end if;
  update emp set salary = salary * v_pct where rowid = v_rowid returning salary into v_nsal;
  dbms_output.put_line(p_id||' 사원은 근무개월수가 '||v_wmonth||' 입니다. 이전 급여는 '||v_sal||' 수정된 급여는 '||v_nsal||' 입니다.');

exception
  when no_data_found then
    dbms_output.put_line('없는 사원 번호입니다.');
    
  when others then
    dbms_output.put_line(sqlcode);
    dbms_output.put_line(sqlerrm);
  
end sal_update_proc;
/

/*[문제39] 급여에 3.3%를 계산하는 tax 함수를 생성하세요.
SQL> SELECT employee_id, last_name, salary, tax(salary) FROM employees;
EMPLOYEE_ID LAST_NAME                SALARY TAX(SALARY)
----------- -------------------- ---------- -----------
        100 King                    35138.4   1159.5672
        101 Kochhar                   22627     746.691
        102 de haan                 24889.7    821.3601
        103 Hunold                     9000         297 */
        
create or replace function tax(sal number)
return number
is

begin
  return sal * 0.033;

exception
  when no_data_found then
    return 0;
    
end tax;
/

select employee_id, last_name, salary, tax(salary) from employees;

drop function tax;

/*[문제40] 급여를 계산하는 get_annual_comp 함수를 생성하세요.
SQL> SELECT employee_id,
     (salary*12) + (commission_pct*salary*12) ann_sal,
     get_annual_comp(salary,commission_pct) ann_sal2
     FROM employees;
EMPLOYEE_ID    ANN_SAL   ANN_SAL2  
----------- ---------- ---------- 
        100                288000    
        101                204000     
        102                204000    
        103                108000     */
create or replace function get_annual_comp(sal number, comm_pct number)
return number
is

begin
  return nvl((sal * 12),0) + nvl((sal * 12 * comm_pct), 0);

end get_annual_comp;
/

select employee_id, (salary*12) + (commission_pct*salary*12) ann_sal, get_annual_comp(salary,commission_pct) ann_sal2 from employees;

/* 문제 41: 문제 40번을 nvl함수를 쓰지 않고 해결하세요 */
create or replace function get_annual_comp(sal number, comm_pct number)
return number
is

begin
  if sal is not null and comm_pct is not null then
    return (sal * 12) + (sal * 12 * comm_pct);
  elsif sal is not null and comm_pct is null then
    return (sal * 12);
  else
    return 0;
  end if;
    
end get_annual_comp;
/

/*[문제42] 사원번호를 입력값으로 받아서 그 사원의 근무 년수를 구하는 함수를 생성하세요. 
단 없는 사원번호가 들어오면 내가 만든 오류번호,메시지가 출력되도록 해야합니다. 
<함수 수행> 
execute dbms_output.put_line(get_year(100)) 
12 
select employee_id, last_name, get_year(employee_id) years_func 
from employees 
order by 1; 
EMPLOYEE_ID LAST_NAME  YEARS_FUNC 
----------- ---------- ----------  
        100 King               12        
        101 Kochhar            10          
        102 De Haan            15          
        103 hunold             10          
execute dbms_output.put_line(get_year(300)) 

begin  
dbms_output.put_line(get_year(300)); 
end; 
/ 
* 
ERROR at line 1: 
ORA-20000: 300번 사원은 존재하지 않습니다. 
ORA-06512: at "HR.GET_YEAR", line 14 
ora-01403: no data found 
ora-06512: at line 1  */
execute dbms_output.put_line(get_year(100));
select employee_id, last_name, get_year(employee_id) years_func from employees;
execute dbms_output.put_line(get_year(300));

create or replace function get_year(p_id number)
return number
is 
  v_wyear number;
  
begin
  select trunc(months_between(sysdate, hire_date)/12) into v_wyear from employees where employee_id = p_id;
  return v_wyear;
exception
  when no_data_found then
    raise_application_error(-20000, p_id||'번 사원은 존재하지 않습니다.', True);

end get_year;
/

/*[문제43] 부서코드를 입력값으로 받아서 부서이름을 return 하는 함수를 만들어주세요. 
부서코드가 없을 경우 '알수없는 부서'가 return해야 합니다. 
<함수 수행결과> 
select employee_id, last_name, department_id, dept_name_func(department_id) dept_name 
from employees; 
EMPLOYEE_ID LAST_NAME            DEPARTMENT_ID DEPT_NAME 
----------- -------------------- ------------- -------------------- 
        177 Livingston                      80 Sales 
        178 grant                              알수없는 부서 
         
exec dbms_output.put_line(dept_name_func(20)) 
marketing */
select employee_id, last_name, department_id, dept_name_func(department_id) dept_name from employees;
exec dbms_output.put_line(dept_name_func(20));

create or replace function dept_name_func(p_deptid number)
return varchar2
is
  v_dname departments.department_name%type;
  
begin
  select department_name into v_dname from departments where department_id = p_deptid;
  return v_dname;
  
exception
  when no_data_found then
    return '알수없는 부서';

end dept_name_func;
/

--문제점 : 함수가 사원테이블의 row건수만큼 돌아간다 
--해결 : 캐시 기능이 있는 scalar서브쿼리를 사용하자 

/*deterministic 
- 함수에 선언하는 힌트 : 캐시기능이 돌아가게 한다 
  (여기서는 부서코드의 종류의 수만큼(같은 부서코드는 1번만 수행) 함수가 돌아간다) */
  
create or replace function dept_name_func(p_deptid number)
return varchar2
deterministic
is
  v_dname departments.department_name%type;
  
begin
  select department_name into v_dname from departments where department_id = p_deptid;
  return v_dname;
  
exception
  when no_data_found then
    return '알수없는 부서';

end dept_name_func;
/

/*[문제44] 문자타입 컬럼 이지만 테이블에 있는 데이터는 숫자형식만 들어 가 있어야 하는데  
그렇지 않는 데이터를 확인 하는 함수를 생성하세요. null 또는 문자가 들어 있으면 0출력 숫자는 1 출력하세요. 
desc locations 
 Name                                      Null?    Type 
 ----------------------------------------- -------- ------------------------- 
 LOCATION_ID                               NOT NULL NUMBER(4) 
 STREET_ADDRESS                                     VARCHAR2(40) 
 POSTAL_CODE                                        VARCHAR2(12) 
 CITY                                      NOT NULL VARCHAR2(30) 
 STATE_PROVINCE                                     VARCHAR2(25) 
 COUNTRY_ID                                         CHAR(2) 

select postal_code, as_number(postal_code)  from locations; 
POSTAL_CODE              AS_NUMBER(POSTAL_CODE) 
------------------------ ---------------------- 
                                              0 
00989                                         1 
10934                                         1 
1689                                          1 
6823                                          1 
26192                                         1 
99236                                         1 
50090                                         1 
98199                                         1 
m5v 2L7                                       0 
ysw 9T2                                       0  */

select postal_code, as_number(postal_code)  from locations;

-- if문 활용
create or replace function as_number(p_code varchar2)
return number
is
  v_num number;
begin
  if p_code is null then
    return 0;
  else
    v_num := to_number(p_code);
    return 1;
  end if;

exception
  when others then
    return 0;
    
end as_number;
/

-- nvl 활용
create or replace function as_number(p_code varchar2)
return number
is
  v_num number;
begin
  v_num := to_number(nvl(p_code, 'Null'));
  return 1;

exception
  when others then
    return 0;
  
end as_number;
/

/*[문제45] 1부터100까지 합을 구하는 함수를 생성하세요. 
단 인수값으로 0이 들어오면 전체 합을 구하고, 1이 들어오면 홀수만 합을 구하고,  
2가 들어오면 짝수만 합을 구하고, 다른 숫자값이 들어오면 오류가 나도록 해야 합니다. 
<함수 호출> 
exec dbms_output.put_line(calc(0)) 
5050 
exec dbms_output.put_line(calc(1)) 
2500 
exec dbms_output.put_line(calc(2)) 
2550 
exec dbms_output.put_line(calc(3)) 
BEGIN dbms_output.put_line(calc(3)); END; 
* 
ERROR at line 1: 
ORA-20000: 인수값으로 0(전체),1(홀수),2(짝수)값만 입력값입니다. 
ORA-06512: at "HR.CALC", line 23 
ora-06512: at line 1 */
exec dbms_output.put_line(calc(0));
exec dbms_output.put_line(calc(1));
exec dbms_output.put_line(calc(2));
exec dbms_output.put_line(calc(3));

create or replace function calc(p_num number)
return number
is
  v_sum number := 0;
begin
  if p_num = 0 then
    for i in 1..100 loop
      v_sum := v_sum + i;
    end loop;
    return v_sum;
    
  elsif p_num = 1 then
    for i in 1..100 loop
      if mod(i, 2) = 1 then
        v_sum := v_sum + i;
      end if;
    end loop;
    return v_sum;
    
  elsif p_num = 2 then
    for i in 1..100 loop
      if mod(i, 2) = 0 then
        v_sum := v_sum + i;
      end if;
    end loop;
    return v_sum;
    
  else 
    raise_application_error(-20000, '인수값으로 0(전체), 1(홀수), 2(짝수)값만 입력값입니다.', True);
  end if;

end calc;
/

/*[문제46] 사원번호를 입력값으로 받아서 그 사원의 소득순위를 기준으로 1위 ~ 3위 고소득, 4위 ~ 8위 중소득, 그외 순위는 저소득이라는 값을 출력한다. 
select employee_id, salary, income(employee_id) income 
from employees 
order by 2 desc; 
EMPLOYEE_ID     SALARY INCOME 
----------- ---------- ---------- 
        100      24000 고소득 
        102      17000 고소득 
        101      17000 고소득 
        145      14000 고소득 
        146      13500 중소득 
        108    13208.8 중소득 
        205      12008 중소득  */

select employee_id, salary, income(employee_id) income from employees;

-- 2차원배열 활용
create or replace function income(p_id number)
return varchar2
is
  type emp_rec_type is record(id employees.employee_id%type, rank number);
  type emp_tab_type is table of emp_rec_type;
  v_emp_tab emp_tab_type;

begin
  select employee_id, rank()over(order by salary desc) bulk collect into v_emp_tab from employees order by employee_id;
  if v_emp_tab(p_id - 99).rank <= 3 then
    return '고소득';
  elsif v_emp_tab(p_id - 99).rank between 4 and 8 then
    return '중소득';
  else
    return '저소득';
  end if;
  
end income;
/

show error;
-- 인라인뷰 활용
create or replace function income(p_id number)
return varchar2
is
  v_rank number;
begin
  select rank into v_rank from (select employee_id, rank()over(order by salary desc) as rank from employees) where employee_id = p_id;
  if v_rank <= 3 then
    return '고소득';
  elsif v_rank between 4 and 8 then
    return '중소득';
  else
    return '저소득';
  end if;
end income;
/

/*[문제47] 사원번호를 입력값으로 받아서 사번, 이름, 부서이름을 출력하는 프로시저를 생성하세요.
SQL> exec id_proc(100)
사원번호 : 100  사원 이름 : King  부서이름 : Executive
PL/SQL procedure successfully completed.

SQL> exec id_proc(200)
사원번호 : 200  사원 이름 : Whalen  부서이름 : Administration
PL/SQL procedure successfully completed.

SQL> exec id_proc(300)
300사원은 존재하지 않습니다.
pl/sql procedure successfully completed. */
exec id_proc(100);
exec id_proc(200);
exec id_proc(300);

create or replace procedure id_proc(p_id number)
is
  type emp_rec_type is record(lname employees.last_name%type, dname departments.department_name%type);
  v_emp_rec emp_rec_type;
  
begin
  select last_name, (select department_name from departments where department_id = e.department_id) into v_emp_rec from employees e where employee_id = p_id;
  dbms_output.put_line('사원번호 : '||p_id||' 사원 이름 : '||v_emp_rec.lname||' 부서이름 : '||v_emp_rec.dname);
  
exception
  when no_data_found then
    dbms_output.put_line(p_id||'사원은 존재하지 않습니다.');
  
  when others then
    dbms_output.put_line(sqlerrm);
  
end id_proc;
/

/* [문제48] 사원이름을 입력값으로 받아서 사원번호, 이름, 부서이름을 출력하는 프로시저를 생성하세요.
SQL> exec name_proc('de haan')
사원번호 : 102  사원 이름 : De Haan  부서이름 : Executive
PL/SQL procedure successfully completed.

SQL> exec name_proc('king')
사원번호 : 156  사원 이름 : King  부서이름 : Sales
사원번호 : 100  사원 이름 : King  부서이름 : Executive
PL/SQL procedure successfully completed.

SQL> exec name_proc('hong')
hong 사원은 존재하지 않습니다.
PL/SQL procedure successfully completed. */
exec name_proc('de haan');
exec name_proc('king');
exec name_proc('hong');

create or replace procedure name_proc(p_name in varchar2)
is
  type emp_rec_type is record(id employees.employee_id%type, dname departments.department_name%type);
  type emp_tab_type is table of emp_rec_type;
  v_emp_tab emp_tab_type;
  v_name employees.last_name%type;
  
begin
  v_name := initcap(p_name);
  select employee_id, (select department_name from departments where department_id = e.department_id) bulk collect into v_emp_tab from employees e where last_name = v_name;
  if v_emp_tab.count = 0 then
    dbms_output.put_line(p_name||' 사원은 존재하지 않습니다');
  else
    for i in v_emp_tab.first..v_emp_tab.last loop
      dbms_output.put_line('사원번호 : '||v_emp_tab(i).id||' 사원 이름 : '||v_name||' 부서이름 : '||v_emp_tab(i).dname);
    end loop;
  end if;
  
exception
  when others then
    dbms_output.put_line(sqlerrm);
    
end name_proc;
/

/*[문제49] 사원번호 또는 사원이름을 입력값으로 받아서 사원번호, 이름, 부서이름을 출력하는 패키지를 생성하세요.
SQL> execute emp_find.find(100)
사원번호: 100 사원이름: King 부서이름: Executive
PL/SQL procedure successfully completed.

SQL> execute emp_find.find(500)
500사원은 존재하지 않습니다.
PL/SQL procedure successfully completed.

SQL> execute emp_find.find('king')
사원번호: 156 사원이름: King 부서이름: Sales
사원번호: 100 사원이름: King 부서이름: Executive
PL/SQL procedure successfully completed.

SQL> execute emp_find.find('de haan')
사원번호: 102 사원이름: De Haan 부서이름: Executive
PL/SQL procedure successfully completed.

SQL> execute emp_find.find('hong')
Hong사원은 존재하지 않습니다.
PL/SQL procedure successfully completed. */
execute emp_find.find(100);
execute emp_find.find(500);
execute emp_find.find('king');
execute emp_find.find('de haan');
execute emp_find.find('hong');

create or replace package emp_find
is
  type emp_rec_type is record(id employees.employee_id%type, lname employees.last_name%type, dname departments.department_name%type);
  type emp_tab_type is table of emp_rec_type;
  v_emp_rec emp_rec_type;
  v_emp_tab emp_tab_type;
  procedure find(p_id in number);
  procedure find(p_name in varchar2);

end emp_find;
/


create or replace package body emp_find
is
  procedure find(p_id number)
  is
  begin
    select employee_id, last_name, (select department_name from departments where department_id = e.department_id) into v_emp_rec from employees e where employee_id = p_id;
    dbms_output.put_line('사원번호 : '||p_id||' 사원 이름 : '||v_emp_rec.lname||' 부서이름 : '||v_emp_rec.dname);
  exception
    when no_data_found then
      dbms_output.put_line(p_id||'사원은 존재하지 않습니다.');
    when others then
      dbms_output.put_line(sqlerrm);
  end find;
  
  procedure find(p_name in varchar2)
  is    
  begin
    select employee_id, last_name, (select department_name from departments where department_id = e.department_id) bulk collect into v_emp_tab from employees e where last_name = initcap(p_name);
    if v_emp_tab.count = 0 then
      dbms_output.put_line(p_name||' 사원은 존재하지 않습니다');
    else
      for i in v_emp_tab.first..v_emp_tab.last loop
        dbms_output.put_line('사원번호 : '||v_emp_tab(i).id||' 사원 이름 : '||v_emp_tab(i).lname||' 부서이름 : '||v_emp_tab(i).dname);
      end loop;
    end if;
    
  exception
    when others then
      dbms_output.put_line(sqlerrm);
      
  end find;

end emp_find;
/

/*[문제50] 사원들의 급여를 10% 인상하는 프로그램을 생성해주세요. 
declare
   v_num  emp_pkg.numlist := emp_pkg.numlist(100,103,107,110,112,115,160,170,180,190,200);
begin 
    emp_pkg.update_sal(v_num);
end;
/
사원번호 : 100        사원이름 : King       수정 급여 : 29040
사원번호 : 103        사원이름 : Hunold     수정 급여 : 9900
사원번호 : 107        사원이름 : Lorentz    수정 급여 : 4620
사원번호 : 110        사원이름 : Chen       수정 급여 : 9020
사원번호 : 112        사원이름 : Urman      수정 급여 : 8580
사원번호 : 115        사원이름 : Khoo       수정 급여 : 3410
사원번호 : 160        사원이름 : Doran      수정 급여 : 8250
사원번호 : 170        사원이름 : Fox        수정 급여 : 10560
사원번호 : 180        사원이름 : Taylor     수정 급여 : 3520
사원번호 : 190        사원이름 : gates      수정 급여 : 3190
사원번호 : 200        사원이름 : Whalen     수정 급여 : 5808 */
-- 테스트
declare
   v_num  emp_pkg.numlist := emp_pkg.numlist(100,103,107,110,112,115,160,170,180,190,200);
begin 
    emp_pkg.update_sal(v_num);
end;
/
rollback;

create or replace package emp_pkg
is
  type numlist is table of number;
  procedure update_sal(p_list numlist);
  
end emp_pkg;
/

create or replace package body emp_pkg
is
  procedure update_sal(p_list numlist)
  is    
    type emp_rec_type is record(lname employees.last_name%type, nsal employees.salary%type);
    type emp_tab_type is table of emp_rec_type;
    v_emp_tab emp_tab_type;
    
  begin
    forall i in p_list.first..p_list.last
      update employees set salary = salary * 1.1 where employee_id = p_list(i) returning last_name, salary bulk collect into v_emp_tab;
    for i in p_list.first..p_list.last loop
      dbms_output.put_line('사원번호 : '||rpad(p_list(i), 10, ' ')||'사원이름 : '||rpad(v_emp_tab(i).lname, 10, ' ')||'수정 급여 : '||rpad(v_emp_tab(i).nsal, 10, ' '));
    end loop;
  end update_sal;

end emp_pkg;
/

/*[문제51] 배열변수에 값을 비교하는 익명블록 프로그램을 작성하세요. 
v_1 := 1,2,3,4,5
v_2 := 1,3

<화면결과>

2 없는 값입니다.
4 없는 값입니다.
5 없는 값입니다. */

-- v_1 기준으로 v_2에 없는 값 출력
declare
  type numlist is table of number;
  v_1 numlist;
  v_2 numlist;
  
begin
  v_1 := numlist(1, 2, 3, 4, 5);
  v_2 := numlist(1, 3);
  for i in v_1.first..v_1.last loop
    for j in v_2.first..v_2.last loop
      if v_1(i) = v_2(j) then
        exit;
      elsif j = v_2.last then
        dbms_output.put_line(v_1(i)||' 없는 값입니다.');
      end if;
    end loop;
  end loop;
  
end;
/

-- 두개를 전부 비교하여 일치하지 않는 값을 정렬하여 출력
-- for 문을 각각 돌려 출력하는 형식
declare
  type numlist is table of number;
  v_1 numlist;
  v_2 numlist;
  type output is table of number index by pls_integer;
  v_output output;
  
begin
  v_1 := numlist(1, 3, 4, 5);
  v_2 := numlist(1, 2, 3, 6, 7);
  -- v_1 - v_2
  for i in v_1.first..v_1.last loop
    for j in v_2.first..v_2.last loop
      if v_1(i) = v_2(j) then
        exit;
      elsif j = v_2.last then
        v_output(v_1(i)) := v_1(i);
        -- dbms_output.put_line(v_1(i)||' 없는 값입니다.');
      end if;
    end loop;
  end loop;
  
  -- v_2 - v_1
  for i in v_2.first..v_2.last loop
    for j in v_1.first..v_1.last loop
      if v_2(i) = v_1(j) then
        exit;
      elsif j = v_1.last then
        v_output(v_2(i)) := v_2(i);
        --dbms_output.put_line(v_2(i)||' 없는 값입니다.');
      end if;
    end loop;
  end loop;
  
  -- 정렬하여 출력
  for i in v_output.first..v_output.last loop
    if v_output.exists(i) then
      dbms_output.put_line(v_output(i)||' 는 없는 값입니다.');
    end if;
  end loop;
  
end;
/

-- 제3의 배열을 만들고 교집합(중첩된 값)을 제외한 값을 확인
declare
  type numlist is table of number;
  v_1 numlist;
  v_2 numlist;
  type listsum is table of number index by pls_integer;
  v_listsum listsum;

begin
  v_1 := numlist(1, 3, 4, 5);
  v_2 := numlist(1, 2, 3, 6, 7);

  for i in v_1.first..v_1.last loop
    if v_listsum.exists(v_1(i)) then
      v_listsum(v_1(i)) := v_listsum(v_1(i)) + 1;
    else
      v_listsum(v_1(i)) := 1;
    end if;
  end loop;
  
  for i in v_2.first..v_2.last loop
    if v_listsum.exists(v_2(i)) then
      v_listsum(v_2(i)) := v_listsum(v_2(i)) + 1;
    else
      v_listsum(v_2(i)) := 1;
    end if;
  end loop;
  
  for i in v_listsum.first..v_listsum.last loop
    if v_listsum(i) = 1 then
      dbms_output.put_line(i||' 없는 값입니다.');
    end if;
  end loop;
  
end;
/

/*[문제52] 사원들의 급여를 10% 인상하는 프로그램을 생성해주세요.
declare
   v_num  emp_pkg.numlist := emp_pkg.numlist(100,103,107,110,112,115,160,170,250,180,190,200,250,300);
begin 
    emp_pkg.update_sal(v_num);
    rollback;
end;
/
사원번호 : 100        사원이름 : King       수정 급여 : 29040
사원번호 : 103        사원이름 : Hunold     수정 급여 : 9900
사원번호 : 107        사원이름 : Lorentz    수정 급여 : 4620
사원번호 : 110        사원이름 : Chen       수정 급여 : 9020
사원번호 : 112        사원이름 : Urman      수정 급여 : 8580
사원번호 : 115        사원이름 : Khoo       수정 급여 : 3410
사원번호 : 160        사원이름 : Doran      수정 급여 : 8250
사원번호 : 170        사원이름 : Fox        수정 급여 : 10560
사원번호 : 180        사원이름 : Taylor     수정 급여 : 3520
사원번호 : 190        사원이름 : Gates      수정 급여 : 3190
사원번호 : 200        사원이름 : Whalen     수정 급여 : 5808
250 처리되지 않는 값입니다.
300 처리되지 않는 값입니다. */
-- 테스트
declare
   v_num  emp_pkg.numlist := emp_pkg.numlist(100,103,107,110,112,115,160,170,250,180,190,200,250,300);
begin 
    emp_pkg.update_sal(v_num);
    rollback;
end;
/

-- 풀이
create or replace package emp_pkg
is
  type numlist is table of number;
  procedure update_sal(p_list numlist);
  
end emp_pkg;
/

create or replace package body emp_pkg
is
  procedure update_sal(p_list numlist)
  is    
    type emp_rec_type is record(empid employees.employee_id%type, lname employees.last_name%type, nsal employees.salary%type);
    type emp_tab_type is table of emp_rec_type;
    v_emp_tab emp_tab_type;
    
  begin
    forall i in p_list.first..p_list.last
      update employees set salary = salary * 1.1 where employee_id = p_list(i) returning employee_id, last_name, salary bulk collect into v_emp_tab;  
    for i in p_list.first..p_list.last loop
      for j in v_emp_tab.first..v_emp_tab.last loop
        if p_list(i) = v_emp_tab(j).empid then
          dbms_output.put_line('사원번호 : '||rpad(v_emp_tab(j).empid, 10, ' ')||'사원이름 : '||rpad(v_emp_tab(j).lname, 10, ' ')||'수정 급여 : '||rpad(v_emp_tab(j).nsal, 10, ' '));
          exit;
        elsif j = v_emp_tab.last then
          dbms_output.put_line(p_list(i)||' 처리되지 않는 값입니다.');
        end if;
      end loop;
    end loop;
  end update_sal;

end emp_pkg;
/

-- 예시와 같이 오류를 모아 중첩된 값 없애고 순서대로 출력하기
create or replace package emp_pkg
is
  type numlist is table of number;
  procedure update_sal(p_list numlist);
  
end emp_pkg;
/

create or replace package body emp_pkg
is
  procedure update_sal(p_list numlist)
  is    
    type emp_rec_type is record(empid employees.employee_id%type, lname employees.last_name%type, nsal employees.salary%type);
    type emp_tab_type is table of emp_rec_type;
    v_emp_tab emp_tab_type;
    type error_tab_type is table of number index by pls_integer;
    v_error error_tab_type;
    
  begin
    forall i in p_list.first..p_list.last
      update employees set salary = salary * 1.1 where employee_id = p_list(i) returning employee_id, last_name, salary bulk collect into v_emp_tab;  
    for i in v_emp_tab.first..v_emp_tab.last loop
      dbms_output.put_line('사원번호 : '||rpad(v_emp_tab(i).empid, 10, ' ')||'사원이름 : '||rpad(v_emp_tab(i).lname, 10, ' ')||'수정 급여 : '||rpad(v_emp_tab(i).nsal, 10, ' '));
    end loop;
    
    for i in p_list.first..p_list.last loop
      for j in v_emp_tab.first..v_emp_tab.last loop
        if p_list(i) = v_emp_tab(j).empid then
          exit;
        elsif j = v_emp_tab.last then
          v_error(p_list(i)) := 1;
        end if;
      end loop;
    end loop;
    
    for i in v_error.first..v_error.last loop
      if v_error.exists(i) then
        dbms_output.put_line(i||' 처리되지 않는 값입니다.');
      end if;
    end loop;
  end update_sal;

end emp_pkg;
/

/*[문제 53] 입력값으로 받은 숫자들의 합을 구하는 함수, 평균을 구하는 함수를 패키지에서 생성하세요.
declare
 v_num agg_pack.num_type := agg_pack.num_type(10,5,2,1,8,9,20,21);
begin
  dbms_output.put_line('합 : '||agg_pack.sum_fc(v_num));
  dbms_output.put_line('평균 : '||agg_pack.avg_fc(v_num));
end;
/
합 : 76
평균 : 9.5 */
-- 테스트
declare
 v_num agg_pack.num_type := agg_pack.num_type(10,5,2,1,8,9,20,21);
begin
  dbms_output.put_line('합 : '||agg_pack.sum_fc(v_num));
  dbms_output.put_line('평균 : '||agg_pack.avg_fc(v_num));
end;
/

-- 풀이
create or replace package agg_pack
is
  type num_type is table of number;
  function sum_fc(p_num in num_type) return number;
  function avg_fc(p_num in num_type) return number;

end agg_pack; 
/

create or replace package body agg_pack
is   
  function sum_fc(p_num in num_type)
  return number
  is
    v_sum number := 0;
  begin
    for i in p_num.first..p_num.last loop
      v_sum := (v_sum + p_num(i));
    end loop;
    return v_sum;
  end sum_fc;
  
  function avg_fc(p_num in num_type)
  return number
  is 
    v_avg number;
  begin
    v_avg := (sum_fc(p_num)/p_num.count);
    return v_avg;
  end avg_fc;

end agg_pack;
/

-- [문제54] 10,10,10,20,20,40,40,50,50,50,60,60,60,30,30,30,30 빈도수를 배열을 이용해서 구하세요.
declare
  type nlist_type is table of number;
  type result_type is table of number index by pls_integer;
  v_nlist nlist_type := nlist_type(10, 10, 10, 20, 20, 40, 40, 50, 50, 50, 60, 60, 60, 30, 30, 30, 30);
  v_result result_type;
  i number;
begin
  for i in v_nlist.first..v_nlist.last loop
    if v_result.exists(v_nlist(i)) then
      v_result(v_nlist(i)) := v_result(v_nlist(i)) + 1;
    else
      v_result(v_nlist(i)) := 1;
    end if;
  end loop;
  
  /* for문 활용
  for i in v_result.first..v_result.last loop
    if v_result.exists(i) then
      dbms_output.put_line(i||'의 빈도수 '||v_result(i));
    end if;
  end loop; */
  
  i := v_result.first;
  
  -- next 활용
  loop
    dbms_output.put_line(i||'의 빈도수 '||v_result(i));
    i := v_result.next(i);
    exit when v_result.next(i) is null;
  end loop;
  
end;
/

-- [문제55] 배열 변수에  20, 9, 8, 200,10, 3, 7, 11,100,101,210,5 값들이 쌓여 있습니다. 최대값을 구하는 프로그램을 작성하세요.
declare
  type numlist is table of number;
  v_nlist numlist;
  v_max number;
  
begin
  v_nlist := numlist(20, 9, 8, 200,10, 3, 7, 11,100,101,210,5);
  v_max := v_nlist(1);
  for i in 2..v_nlist.last loop
    if v_nlist(i) > v_max then
      v_max := v_nlist(i);
    end if;
  end loop;
  dbms_output.put_line('최대값은 '||v_max);

end;
/

-- [문제56] 배열 변수에  20, 9, 8, 200,10, 3, 7, 11,100,101,210,5 값들이 쌓여 있습니다. 최소값을 구하는 프로그램을 작성하세요.
declare
  type numlist is table of number;
  v_nlist numlist;
  v_min number;
  
begin
  v_nlist := numlist(20, 9, 8, 200,10, 3, 7, 11,100,101,210,5);
  v_min := v_nlist(1);
  for i in 2..v_nlist.last loop
    if v_nlist(i) < v_min then
      v_min := v_nlist(i);
    end if;
  end loop;
  dbms_output.put_line('최소값은 '||v_min);

end;
/

-- [문제57] 복제 테이블을 생성한후 emp_source 테이블에 dml이 발생하면 emp_target값도 함께 수행되도록 해주세요.
drop table emp_target purge;
drop table emp_source purge;

create table emp_target(id number, name varchar2(10), day timestamp default systimestamp, sal number);
create table emp_source(id number, name varchar2(10), day timestamp default systimestamp, sal number);

-- 테스트
select * from emp_source;
select * from emp_target;
insert into emp_source(id,name,day,sal) values(100,'ora1',default,1000);
commit;
update emp_source set sal = 2000 where id = 100;
update emp_source set name = 'oracle' where id = 100;
insert into emp_source(id,name,day,sal) values(2,user,default,3000);
delete from emp_source where id = 2;
rollback;

create or replace trigger auto_duplicate_trigger
after insert or delete or update on emp_source for each row
declare
begin
  if deleting then
    delete from emp_target where id = :old.id;
  elsif inserting then
    insert into emp_target(id, name, day, sal) values(:new.id, :new.name, :new.day, :new.sal);
  elsif updating then
    update emp_target set id = :new.id, name = :new.name, day = :new.day, sal = :new.sal;
  end if;
end;
/